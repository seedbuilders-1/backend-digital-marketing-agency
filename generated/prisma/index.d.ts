
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organisation
 * 
 */
export type Organisation = $Result.DefaultSelection<Prisma.$OrganisationPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceForm
 * 
 */
export type ServiceForm = $Result.DefaultSelection<Prisma.$ServiceFormPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model CaseStudy
 * 
 */
export type CaseStudy = $Result.DefaultSelection<Prisma.$CaseStudyPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model Faq
 * 
 */
export type Faq = $Result.DefaultSelection<Prisma.$FaqPayload>
/**
 * Model ServiceRequest
 * 
 */
export type ServiceRequest = $Result.DefaultSelection<Prisma.$ServiceRequestPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Password_token
 * 
 */
export type Password_token = $Result.DefaultSelection<Prisma.$Password_tokenPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Privacy_settings
 * 
 */
export type Privacy_settings = $Result.DefaultSelection<Prisma.$Privacy_settingsPayload>
/**
 * Model Notification_settings
 * 
 */
export type Notification_settings = $Result.DefaultSelection<Prisma.$Notification_settingsPayload>
/**
 * Model Plan_type
 * 
 */
export type Plan_type = $Result.DefaultSelection<Prisma.$Plan_typePayload>
/**
 * Model Billing_cycle
 * 
 */
export type Billing_cycle = $Result.DefaultSelection<Prisma.$Billing_cyclePayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ServiceRequestStatus: {
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  DECLINED: 'DECLINED',
  CANCELLED: 'CANCELLED'
};

export type ServiceRequestStatus = (typeof ServiceRequestStatus)[keyof typeof ServiceRequestStatus]


export const MilestoneStatus: {
  PENDING_ADMIN_UPLOAD: 'PENDING_ADMIN_UPLOAD',
  PENDING_CLIENT_APPROVAL: 'PENDING_CLIENT_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type MilestoneStatus = (typeof MilestoneStatus)[keyof typeof MilestoneStatus]

}

export type ServiceRequestStatus = $Enums.ServiceRequestStatus

export const ServiceRequestStatus: typeof $Enums.ServiceRequestStatus

export type MilestoneStatus = $Enums.MilestoneStatus

export const MilestoneStatus: typeof $Enums.MilestoneStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organisation`: Exposes CRUD operations for the **Organisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisation.findMany()
    * ```
    */
  get organisation(): Prisma.OrganisationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceForm`: Exposes CRUD operations for the **ServiceForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceForms
    * const serviceForms = await prisma.serviceForm.findMany()
    * ```
    */
  get serviceForm(): Prisma.ServiceFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseStudy`: Exposes CRUD operations for the **CaseStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseStudies
    * const caseStudies = await prisma.caseStudy.findMany()
    * ```
    */
  get caseStudy(): Prisma.CaseStudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **Faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.FaqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRequest`: Exposes CRUD operations for the **ServiceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRequests
    * const serviceRequests = await prisma.serviceRequest.findMany()
    * ```
    */
  get serviceRequest(): Prisma.ServiceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_token`: Exposes CRUD operations for the **Password_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_tokens
    * const password_tokens = await prisma.password_token.findMany()
    * ```
    */
  get password_token(): Prisma.Password_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacy_settings`: Exposes CRUD operations for the **Privacy_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privacy_settings
    * const privacy_settings = await prisma.privacy_settings.findMany()
    * ```
    */
  get privacy_settings(): Prisma.Privacy_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_settings`: Exposes CRUD operations for the **Notification_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_settings
    * const notification_settings = await prisma.notification_settings.findMany()
    * ```
    */
  get notification_settings(): Prisma.Notification_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_type`: Exposes CRUD operations for the **Plan_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_types
    * const plan_types = await prisma.plan_type.findMany()
    * ```
    */
  get plan_type(): Prisma.Plan_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billing_cycle`: Exposes CRUD operations for the **Billing_cycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billing_cycles
    * const billing_cycles = await prisma.billing_cycle.findMany()
    * ```
    */
  get billing_cycle(): Prisma.Billing_cycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organisation: 'Organisation',
    Service: 'Service',
    ServiceForm: 'ServiceForm',
    Plan: 'Plan',
    Invoice: 'Invoice',
    CaseStudy: 'CaseStudy',
    Testimonial: 'Testimonial',
    Faq: 'Faq',
    ServiceRequest: 'ServiceRequest',
    Milestone: 'Milestone',
    Contact: 'Contact',
    Otp: 'Otp',
    Conversation: 'Conversation',
    Message: 'Message',
    Password_token: 'Password_token',
    Notification: 'Notification',
    Privacy_settings: 'Privacy_settings',
    Notification_settings: 'Notification_settings',
    Plan_type: 'Plan_type',
    Billing_cycle: 'Billing_cycle',
    Subscription: 'Subscription',
    Role: 'Role'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organisation" | "service" | "serviceForm" | "plan" | "invoice" | "caseStudy" | "testimonial" | "faq" | "serviceRequest" | "milestone" | "contact" | "otp" | "conversation" | "message" | "password_token" | "notification" | "privacy_settings" | "notification_settings" | "plan_type" | "billing_cycle" | "subscription" | "role"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organisation: {
        payload: Prisma.$OrganisationPayload<ExtArgs>
        fields: Prisma.OrganisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findFirst: {
            args: Prisma.OrganisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findMany: {
            args: Prisma.OrganisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>[]
          }
          create: {
            args: Prisma.OrganisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          createMany: {
            args: Prisma.OrganisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          update: {
            args: Prisma.OrganisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          aggregate: {
            args: Prisma.OrganisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisation>
          }
          groupBy: {
            args: Prisma.OrganisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceForm: {
        payload: Prisma.$ServiceFormPayload<ExtArgs>
        fields: Prisma.ServiceFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          findMany: {
            args: Prisma.ServiceFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>[]
          }
          create: {
            args: Prisma.ServiceFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          createMany: {
            args: Prisma.ServiceFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          update: {
            args: Prisma.ServiceFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceForm>
          }
          groupBy: {
            args: Prisma.ServiceFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFormCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceFormCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      CaseStudy: {
        payload: Prisma.$CaseStudyPayload<ExtArgs>
        fields: Prisma.CaseStudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseStudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseStudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findFirst: {
            args: Prisma.CaseStudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseStudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findMany: {
            args: Prisma.CaseStudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          create: {
            args: Prisma.CaseStudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          createMany: {
            args: Prisma.CaseStudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CaseStudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          update: {
            args: Prisma.CaseStudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          deleteMany: {
            args: Prisma.CaseStudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseStudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CaseStudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          aggregate: {
            args: Prisma.CaseStudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseStudy>
          }
          groupBy: {
            args: Prisma.CaseStudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseStudyCountArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      Faq: {
        payload: Prisma.$FaqPayload<ExtArgs>
        fields: Prisma.FaqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FaqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FaqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          findFirst: {
            args: Prisma.FaqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FaqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          findMany: {
            args: Prisma.FaqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>[]
          }
          create: {
            args: Prisma.FaqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          createMany: {
            args: Prisma.FaqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FaqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          update: {
            args: Prisma.FaqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          deleteMany: {
            args: Prisma.FaqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FaqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FaqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          aggregate: {
            args: Prisma.FaqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaq>
          }
          groupBy: {
            args: Prisma.FaqGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqGroupByOutputType>[]
          }
          count: {
            args: Prisma.FaqCountArgs<ExtArgs>
            result: $Utils.Optional<FaqCountAggregateOutputType> | number
          }
        }
      }
      ServiceRequest: {
        payload: Prisma.$ServiceRequestPayload<ExtArgs>
        fields: Prisma.ServiceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findFirst: {
            args: Prisma.ServiceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findMany: {
            args: Prisma.ServiceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          create: {
            args: Prisma.ServiceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          createMany: {
            args: Prisma.ServiceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          update: {
            args: Prisma.ServiceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          aggregate: {
            args: Prisma.ServiceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRequest>
          }
          groupBy: {
            args: Prisma.ServiceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Password_token: {
        payload: Prisma.$Password_tokenPayload<ExtArgs>
        fields: Prisma.Password_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Password_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Password_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          findFirst: {
            args: Prisma.Password_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Password_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          findMany: {
            args: Prisma.Password_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>[]
          }
          create: {
            args: Prisma.Password_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          createMany: {
            args: Prisma.Password_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Password_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          update: {
            args: Prisma.Password_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          deleteMany: {
            args: Prisma.Password_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Password_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Password_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Password_tokenPayload>
          }
          aggregate: {
            args: Prisma.Password_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_token>
          }
          groupBy: {
            args: Prisma.Password_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.Password_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Password_tokenCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Privacy_settings: {
        payload: Prisma.$Privacy_settingsPayload<ExtArgs>
        fields: Prisma.Privacy_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Privacy_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Privacy_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          findFirst: {
            args: Prisma.Privacy_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Privacy_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          findMany: {
            args: Prisma.Privacy_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>[]
          }
          create: {
            args: Prisma.Privacy_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          createMany: {
            args: Prisma.Privacy_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Privacy_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          update: {
            args: Prisma.Privacy_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          deleteMany: {
            args: Prisma.Privacy_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Privacy_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Privacy_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Privacy_settingsPayload>
          }
          aggregate: {
            args: Prisma.Privacy_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacy_settings>
          }
          groupBy: {
            args: Prisma.Privacy_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Privacy_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Privacy_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Privacy_settingsCountAggregateOutputType> | number
          }
        }
      }
      Notification_settings: {
        payload: Prisma.$Notification_settingsPayload<ExtArgs>
        fields: Prisma.Notification_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Notification_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Notification_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          findFirst: {
            args: Prisma.Notification_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Notification_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          findMany: {
            args: Prisma.Notification_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>[]
          }
          create: {
            args: Prisma.Notification_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          createMany: {
            args: Prisma.Notification_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Notification_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          update: {
            args: Prisma.Notification_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          deleteMany: {
            args: Prisma.Notification_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Notification_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Notification_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Notification_settingsPayload>
          }
          aggregate: {
            args: Prisma.Notification_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_settings>
          }
          groupBy: {
            args: Prisma.Notification_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Notification_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_settingsCountAggregateOutputType> | number
          }
        }
      }
      Plan_type: {
        payload: Prisma.$Plan_typePayload<ExtArgs>
        fields: Prisma.Plan_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Plan_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Plan_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          findFirst: {
            args: Prisma.Plan_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Plan_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          findMany: {
            args: Prisma.Plan_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>[]
          }
          create: {
            args: Prisma.Plan_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          createMany: {
            args: Prisma.Plan_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Plan_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          update: {
            args: Prisma.Plan_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          deleteMany: {
            args: Prisma.Plan_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Plan_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Plan_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Plan_typePayload>
          }
          aggregate: {
            args: Prisma.Plan_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_type>
          }
          groupBy: {
            args: Prisma.Plan_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.Plan_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_typeCountAggregateOutputType> | number
          }
        }
      }
      Billing_cycle: {
        payload: Prisma.$Billing_cyclePayload<ExtArgs>
        fields: Prisma.Billing_cycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Billing_cycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Billing_cycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          findFirst: {
            args: Prisma.Billing_cycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Billing_cycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          findMany: {
            args: Prisma.Billing_cycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>[]
          }
          create: {
            args: Prisma.Billing_cycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          createMany: {
            args: Prisma.Billing_cycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Billing_cycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          update: {
            args: Prisma.Billing_cycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          deleteMany: {
            args: Prisma.Billing_cycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Billing_cycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Billing_cycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Billing_cyclePayload>
          }
          aggregate: {
            args: Prisma.Billing_cycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilling_cycle>
          }
          groupBy: {
            args: Prisma.Billing_cycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Billing_cycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.Billing_cycleCountArgs<ExtArgs>
            result: $Utils.Optional<Billing_cycleCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organisation?: OrganisationOmit
    service?: ServiceOmit
    serviceForm?: ServiceFormOmit
    plan?: PlanOmit
    invoice?: InvoiceOmit
    caseStudy?: CaseStudyOmit
    testimonial?: TestimonialOmit
    faq?: FaqOmit
    serviceRequest?: ServiceRequestOmit
    milestone?: MilestoneOmit
    contact?: ContactOmit
    otp?: OtpOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    password_token?: Password_tokenOmit
    notification?: NotificationOmit
    privacy_settings?: Privacy_settingsOmit
    notification_settings?: Notification_settingsOmit
    plan_type?: Plan_typeOmit
    billing_cycle?: Billing_cycleOmit
    subscription?: SubscriptionOmit
    role?: RoleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    messages: number
    notifications: number
    notification_settings: number
    otps: number
    password_tokens: number
    privacy_settings: number
    created_roles: number
    services: number
    service_requests: number
    subscriptions: number
    testimonials: number
    plan_types: number
    Invoice: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    notification_settings?: boolean | UserCountOutputTypeCountNotification_settingsArgs
    otps?: boolean | UserCountOutputTypeCountOtpsArgs
    password_tokens?: boolean | UserCountOutputTypeCountPassword_tokensArgs
    privacy_settings?: boolean | UserCountOutputTypeCountPrivacy_settingsArgs
    created_roles?: boolean | UserCountOutputTypeCountCreated_rolesArgs
    services?: boolean | UserCountOutputTypeCountServicesArgs
    service_requests?: boolean | UserCountOutputTypeCountService_requestsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    testimonials?: boolean | UserCountOutputTypeCountTestimonialsArgs
    plan_types?: boolean | UserCountOutputTypeCountPlan_typesArgs
    Invoice?: boolean | UserCountOutputTypeCountInvoiceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotification_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Notification_settingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPassword_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Password_tokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrivacy_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Privacy_settingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreated_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountService_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlan_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Plan_typeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type OrganisationCountOutputType
   */

  export type OrganisationCountOutputType = {
    caseStudies: number
    contacts: number
  }

  export type OrganisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudies?: boolean | OrganisationCountOutputTypeCountCaseStudiesArgs
    contacts?: boolean | OrganisationCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationCountOutputType
     */
    select?: OrganisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountCaseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    plans: number
    caseStudies: number
    testimonials: number
    faqs: number
    service_requests: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | ServiceCountOutputTypeCountPlansArgs
    caseStudies?: boolean | ServiceCountOutputTypeCountCaseStudiesArgs
    testimonials?: boolean | ServiceCountOutputTypeCountTestimonialsArgs
    faqs?: boolean | ServiceCountOutputTypeCountFaqsArgs
    service_requests?: boolean | ServiceCountOutputTypeCountService_requestsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCaseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTestimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaqWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountService_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    service_requests: number
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_requests?: boolean | PlanCountOutputTypeCountService_requestsArgs
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountService_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type ServiceRequestCountOutputType
   */

  export type ServiceRequestCountOutputType = {
    milestones: number
  }

  export type ServiceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | ServiceRequestCountOutputTypeCountMilestonesArgs
  }

  // Custom InputTypes
  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequestCountOutputType
     */
    select?: ServiceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type Plan_typeCountOutputType
   */

  export type Plan_typeCountOutputType = {
    plans: number
  }

  export type Plan_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | Plan_typeCountOutputTypeCountPlansArgs
  }

  // Custom InputTypes
  /**
   * Plan_typeCountOutputType without action
   */
  export type Plan_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_typeCountOutputType
     */
    select?: Plan_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Plan_typeCountOutputType without action
   */
  export type Plan_typeCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }


  /**
   * Count Type Billing_cycleCountOutputType
   */

  export type Billing_cycleCountOutputType = {
    plans: number
  }

  export type Billing_cycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | Billing_cycleCountOutputTypeCountPlansArgs
  }

  // Custom InputTypes
  /**
   * Billing_cycleCountOutputType without action
   */
  export type Billing_cycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycleCountOutputType
     */
    select?: Billing_cycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Billing_cycleCountOutputType without action
   */
  export type Billing_cycleCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    tel: string | null
    country: string | null
    city: string | null
    address: string | null
    category: string | null
    pfp_url: string | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string | null
    status: string | null
    role_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    tel: string | null
    country: string | null
    city: string | null
    address: string | null
    category: string | null
    pfp_url: string | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string | null
    status: string | null
    role_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    tel: number
    country: number
    city: number
    address: number
    category: number
    pfp_url: number
    id_url: number
    business_status: number
    registered_with_a_business: number
    password: number
    status: number
    role_id: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    city?: true
    address?: true
    category?: true
    pfp_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    city?: true
    address?: true
    category?: true
    pfp_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    city?: true
    address?: true
    category?: true
    pfp_url?: true
    id_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    tel: string
    country: string
    city: string | null
    address: string
    category: string
    pfp_url: string | null
    id_url: JsonValue | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string
    status: string
    role_id: string
    created_at: Date | null
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    tel?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    category?: boolean
    pfp_url?: boolean
    id_url?: boolean
    business_status?: boolean
    registered_with_a_business?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notification_settings?: boolean | User$notification_settingsArgs<ExtArgs>
    organisation?: boolean | User$organisationArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    password_tokens?: boolean | User$password_tokensArgs<ExtArgs>
    privacy_settings?: boolean | User$privacy_settingsArgs<ExtArgs>
    created_roles?: boolean | User$created_rolesArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    service_requests?: boolean | User$service_requestsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    plan_types?: boolean | User$plan_typesArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    tel?: boolean
    country?: boolean
    city?: boolean
    address?: boolean
    category?: boolean
    pfp_url?: boolean
    id_url?: boolean
    business_status?: boolean
    registered_with_a_business?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "tel" | "country" | "city" | "address" | "category" | "pfp_url" | "id_url" | "business_status" | "registered_with_a_business" | "password" | "status" | "role_id" | "created_at" | "deleted_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notification_settings?: boolean | User$notification_settingsArgs<ExtArgs>
    organisation?: boolean | User$organisationArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    password_tokens?: boolean | User$password_tokensArgs<ExtArgs>
    privacy_settings?: boolean | User$privacy_settingsArgs<ExtArgs>
    created_roles?: boolean | User$created_rolesArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    service_requests?: boolean | User$service_requestsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    testimonials?: boolean | User$testimonialsArgs<ExtArgs>
    plan_types?: boolean | User$plan_typesArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    Invoice?: boolean | User$InvoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notification_settings: Prisma.$Notification_settingsPayload<ExtArgs>[]
      organisation: Prisma.$OrganisationPayload<ExtArgs> | null
      otps: Prisma.$OtpPayload<ExtArgs>[]
      password_tokens: Prisma.$Password_tokenPayload<ExtArgs>[]
      privacy_settings: Prisma.$Privacy_settingsPayload<ExtArgs>[]
      created_roles: Prisma.$RolePayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      service_requests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      testimonials: Prisma.$TestimonialPayload<ExtArgs>[]
      plan_types: Prisma.$Plan_typePayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>
      Invoice: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      tel: string
      country: string
      city: string | null
      address: string
      category: string
      pfp_url: string | null
      id_url: Prisma.JsonValue | null
      business_status: boolean | null
      registered_with_a_business: boolean | null
      password: string
      status: string
      role_id: string
      created_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_settings<T extends User$notification_settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notification_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organisation<T extends User$organisationArgs<ExtArgs> = {}>(args?: Subset<T, User$organisationArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    password_tokens<T extends User$password_tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$password_tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privacy_settings<T extends User$privacy_settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$privacy_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_roles<T extends User$created_rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$created_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_requests<T extends User$service_requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$service_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonials<T extends User$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, User$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan_types<T extends User$plan_typesArgs<ExtArgs> = {}>(args?: Subset<T, User$plan_typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Invoice<T extends User$InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, User$InvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly tel: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly category: FieldRef<"User", 'String'>
    readonly pfp_url: FieldRef<"User", 'String'>
    readonly id_url: FieldRef<"User", 'Json'>
    readonly business_status: FieldRef<"User", 'Boolean'>
    readonly registered_with_a_business: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly role_id: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly deleted_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notification_settings
   */
  export type User$notification_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    where?: Notification_settingsWhereInput
    orderBy?: Notification_settingsOrderByWithRelationInput | Notification_settingsOrderByWithRelationInput[]
    cursor?: Notification_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * User.organisation
   */
  export type User$organisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    where?: OrganisationWhereInput
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * User.password_tokens
   */
  export type User$password_tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    where?: Password_tokenWhereInput
    orderBy?: Password_tokenOrderByWithRelationInput | Password_tokenOrderByWithRelationInput[]
    cursor?: Password_tokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * User.privacy_settings
   */
  export type User$privacy_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    where?: Privacy_settingsWhereInput
    orderBy?: Privacy_settingsOrderByWithRelationInput | Privacy_settingsOrderByWithRelationInput[]
    cursor?: Privacy_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * User.created_roles
   */
  export type User$created_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * User.service_requests
   */
  export type User$service_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.testimonials
   */
  export type User$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    cursor?: TestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * User.plan_types
   */
  export type User$plan_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    where?: Plan_typeWhereInput
    orderBy?: Plan_typeOrderByWithRelationInput | Plan_typeOrderByWithRelationInput[]
    cursor?: Plan_typeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * User.Invoice
   */
  export type User$InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organisation
   */

  export type AggregateOrganisation = {
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  export type OrganisationMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    address: string | null
    country: string | null
    industry: string | null
    logo_url: string | null
    rc_number: string | null
    staff_size: string | null
    type: string | null
    cert_of_inc_url: string | null
    mem_of_assoc_url: string | null
    proof_of_address_url: string | null
    company_status_report_url: string | null
    created_at: Date | null
    user_id: string | null
    deleted_at: Date | null
  }

  export type OrganisationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    address: string | null
    country: string | null
    industry: string | null
    logo_url: string | null
    rc_number: string | null
    staff_size: string | null
    type: string | null
    cert_of_inc_url: string | null
    mem_of_assoc_url: string | null
    proof_of_address_url: string | null
    company_status_report_url: string | null
    created_at: Date | null
    user_id: string | null
    deleted_at: Date | null
  }

  export type OrganisationCountAggregateOutputType = {
    id: number
    name: number
    email: number
    address: number
    country: number
    industry: number
    logo_url: number
    rc_number: number
    staff_size: number
    type: number
    cert_of_inc_url: number
    mem_of_assoc_url: number
    proof_of_address_url: number
    company_status_report_url: number
    created_at: number
    user_id: number
    deleted_at: number
    _all: number
  }


  export type OrganisationMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    cert_of_inc_url?: true
    mem_of_assoc_url?: true
    proof_of_address_url?: true
    company_status_report_url?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
  }

  export type OrganisationMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    cert_of_inc_url?: true
    mem_of_assoc_url?: true
    proof_of_address_url?: true
    company_status_report_url?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
  }

  export type OrganisationCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    cert_of_inc_url?: true
    mem_of_assoc_url?: true
    proof_of_address_url?: true
    company_status_report_url?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
    _all?: true
  }

  export type OrganisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisation to aggregate.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organisations
    **/
    _count?: true | OrganisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMaxAggregateInputType
  }

  export type GetOrganisationAggregateType<T extends OrganisationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisation[P]>
      : GetScalarType<T[P], AggregateOrganisation[P]>
  }




  export type OrganisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationWhereInput
    orderBy?: OrganisationOrderByWithAggregationInput | OrganisationOrderByWithAggregationInput[]
    by: OrganisationScalarFieldEnum[] | OrganisationScalarFieldEnum
    having?: OrganisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationCountAggregateInputType | true
    _min?: OrganisationMinAggregateInputType
    _max?: OrganisationMaxAggregateInputType
  }

  export type OrganisationGroupByOutputType = {
    id: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at: Date
    user_id: string
    deleted_at: Date | null
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  type GetOrganisationGroupByPayload<T extends OrganisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    country?: boolean
    industry?: boolean
    logo_url?: boolean
    rc_number?: boolean
    staff_size?: boolean
    type?: boolean
    cert_of_inc_url?: boolean
    mem_of_assoc_url?: boolean
    proof_of_address_url?: boolean
    company_status_report_url?: boolean
    created_at?: boolean
    user_id?: boolean
    deleted_at?: boolean
    caseStudies?: boolean | Organisation$caseStudiesArgs<ExtArgs>
    contacts?: boolean | Organisation$contactsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisation"]>



  export type OrganisationSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    country?: boolean
    industry?: boolean
    logo_url?: boolean
    rc_number?: boolean
    staff_size?: boolean
    type?: boolean
    cert_of_inc_url?: boolean
    mem_of_assoc_url?: boolean
    proof_of_address_url?: boolean
    company_status_report_url?: boolean
    created_at?: boolean
    user_id?: boolean
    deleted_at?: boolean
  }

  export type OrganisationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "address" | "country" | "industry" | "logo_url" | "rc_number" | "staff_size" | "type" | "cert_of_inc_url" | "mem_of_assoc_url" | "proof_of_address_url" | "company_status_report_url" | "created_at" | "user_id" | "deleted_at", ExtArgs["result"]["organisation"]>
  export type OrganisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudies?: boolean | Organisation$caseStudiesArgs<ExtArgs>
    contacts?: boolean | Organisation$contactsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organisation"
    objects: {
      caseStudies: Prisma.$CaseStudyPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      address: string
      country: string
      industry: string
      logo_url: string
      rc_number: string
      staff_size: string
      type: string
      cert_of_inc_url: string
      mem_of_assoc_url: string
      proof_of_address_url: string
      company_status_report_url: string
      created_at: Date
      user_id: string
      deleted_at: Date | null
    }, ExtArgs["result"]["organisation"]>
    composites: {}
  }

  type OrganisationGetPayload<S extends boolean | null | undefined | OrganisationDefaultArgs> = $Result.GetResult<Prisma.$OrganisationPayload, S>

  type OrganisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganisationCountAggregateInputType | true
    }

  export interface OrganisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organisation'], meta: { name: 'Organisation' } }
    /**
     * Find zero or one Organisation that matches the filter.
     * @param {OrganisationFindUniqueArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationFindUniqueArgs>(args: SelectSubset<T, OrganisationFindUniqueArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organisation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganisationFindUniqueOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationFindFirstArgs>(args?: SelectSubset<T, OrganisationFindFirstArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisation.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationWithIdOnly = await prisma.organisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationFindManyArgs>(args?: SelectSubset<T, OrganisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organisation.
     * @param {OrganisationCreateArgs} args - Arguments to create a Organisation.
     * @example
     * // Create one Organisation
     * const Organisation = await prisma.organisation.create({
     *   data: {
     *     // ... data to create a Organisation
     *   }
     * })
     * 
     */
    create<T extends OrganisationCreateArgs>(args: SelectSubset<T, OrganisationCreateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organisations.
     * @param {OrganisationCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisation = await prisma.organisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationCreateManyArgs>(args?: SelectSubset<T, OrganisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organisation.
     * @param {OrganisationDeleteArgs} args - Arguments to delete one Organisation.
     * @example
     * // Delete one Organisation
     * const Organisation = await prisma.organisation.delete({
     *   where: {
     *     // ... filter to delete one Organisation
     *   }
     * })
     * 
     */
    delete<T extends OrganisationDeleteArgs>(args: SelectSubset<T, OrganisationDeleteArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organisation.
     * @param {OrganisationUpdateArgs} args - Arguments to update one Organisation.
     * @example
     * // Update one Organisation
     * const organisation = await prisma.organisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationUpdateArgs>(args: SelectSubset<T, OrganisationUpdateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organisations.
     * @param {OrganisationDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationDeleteManyArgs>(args?: SelectSubset<T, OrganisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisation = await prisma.organisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationUpdateManyArgs>(args: SelectSubset<T, OrganisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisation.
     * @param {OrganisationUpsertArgs} args - Arguments to update or create a Organisation.
     * @example
     * // Update or create a Organisation
     * const organisation = await prisma.organisation.upsert({
     *   create: {
     *     // ... data to create a Organisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisation we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationUpsertArgs>(args: SelectSubset<T, OrganisationUpsertArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisation.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends OrganisationCountArgs>(
      args?: Subset<T, OrganisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationAggregateArgs>(args: Subset<T, OrganisationAggregateArgs>): Prisma.PrismaPromise<GetOrganisationAggregateType<T>>

    /**
     * Group by Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organisation model
   */
  readonly fields: OrganisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caseStudies<T extends Organisation$caseStudiesArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$caseStudiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Organisation$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organisation model
   */
  interface OrganisationFieldRefs {
    readonly id: FieldRef<"Organisation", 'String'>
    readonly name: FieldRef<"Organisation", 'String'>
    readonly email: FieldRef<"Organisation", 'String'>
    readonly address: FieldRef<"Organisation", 'String'>
    readonly country: FieldRef<"Organisation", 'String'>
    readonly industry: FieldRef<"Organisation", 'String'>
    readonly logo_url: FieldRef<"Organisation", 'String'>
    readonly rc_number: FieldRef<"Organisation", 'String'>
    readonly staff_size: FieldRef<"Organisation", 'String'>
    readonly type: FieldRef<"Organisation", 'String'>
    readonly cert_of_inc_url: FieldRef<"Organisation", 'String'>
    readonly mem_of_assoc_url: FieldRef<"Organisation", 'String'>
    readonly proof_of_address_url: FieldRef<"Organisation", 'String'>
    readonly company_status_report_url: FieldRef<"Organisation", 'String'>
    readonly created_at: FieldRef<"Organisation", 'DateTime'>
    readonly user_id: FieldRef<"Organisation", 'String'>
    readonly deleted_at: FieldRef<"Organisation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organisation findUnique
   */
  export type OrganisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findUniqueOrThrow
   */
  export type OrganisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findFirst
   */
  export type OrganisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findFirstOrThrow
   */
  export type OrganisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findMany
   */
  export type OrganisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation create
   */
  export type OrganisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organisation.
     */
    data: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
  }

  /**
   * Organisation createMany
   */
  export type OrganisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationCreateManyInput | OrganisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisation update
   */
  export type OrganisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organisation.
     */
    data: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
    /**
     * Choose, which Organisation to update.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation updateMany
   */
  export type OrganisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organisations.
     */
    data: XOR<OrganisationUpdateManyMutationInput, OrganisationUncheckedUpdateManyInput>
    /**
     * Filter which Organisations to update
     */
    where?: OrganisationWhereInput
    /**
     * Limit how many Organisations to update.
     */
    limit?: number
  }

  /**
   * Organisation upsert
   */
  export type OrganisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organisation to update in case it exists.
     */
    where: OrganisationWhereUniqueInput
    /**
     * In case the Organisation found by the `where` argument doesn't exist, create a new Organisation with this data.
     */
    create: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
    /**
     * In case the Organisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
  }

  /**
   * Organisation delete
   */
  export type OrganisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter which Organisation to delete.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation deleteMany
   */
  export type OrganisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to delete
     */
    where?: OrganisationWhereInput
    /**
     * Limit how many Organisations to delete.
     */
    limit?: number
  }

  /**
   * Organisation.caseStudies
   */
  export type Organisation$caseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    cursor?: CaseStudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * Organisation.contacts
   */
  export type Organisation$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Organisation without action
   */
  export type OrganisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    isPublic: boolean | null
    heroHeadline: string | null
    heroParagraph: string | null
    heroImageUrl: string | null
    blueprintHeadline: string | null
    blueprintParagraph: string | null
    blueprintImageUrl: string | null
    bannerText: string | null
    admin_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    isPublic: boolean | null
    heroHeadline: string | null
    heroParagraph: string | null
    heroImageUrl: string | null
    blueprintHeadline: string | null
    blueprintParagraph: string | null
    blueprintImageUrl: string | null
    bannerText: string | null
    admin_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    title: number
    isPublic: number
    heroHeadline: number
    heroParagraph: number
    heroImageUrl: number
    blueprintHeadline: number
    blueprintParagraph: number
    blueprintImageUrl: number
    bannerText: number
    admin_id: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    title?: true
    isPublic?: true
    heroHeadline?: true
    heroParagraph?: true
    heroImageUrl?: true
    blueprintHeadline?: true
    blueprintParagraph?: true
    blueprintImageUrl?: true
    bannerText?: true
    admin_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    title?: true
    isPublic?: true
    heroHeadline?: true
    heroParagraph?: true
    heroImageUrl?: true
    blueprintHeadline?: true
    blueprintParagraph?: true
    blueprintImageUrl?: true
    bannerText?: true
    admin_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    title?: true
    isPublic?: true
    heroHeadline?: true
    heroParagraph?: true
    heroImageUrl?: true
    blueprintHeadline?: true
    blueprintParagraph?: true
    blueprintImageUrl?: true
    bannerText?: true
    admin_id?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    title: string
    isPublic: boolean
    heroHeadline: string | null
    heroParagraph: string | null
    heroImageUrl: string | null
    blueprintHeadline: string | null
    blueprintParagraph: string | null
    blueprintImageUrl: string | null
    bannerText: string | null
    admin_id: string
    created_at: Date | null
    deleted_at: Date | null
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isPublic?: boolean
    heroHeadline?: boolean
    heroParagraph?: boolean
    heroImageUrl?: boolean
    blueprintHeadline?: boolean
    blueprintParagraph?: boolean
    blueprintImageUrl?: boolean
    bannerText?: boolean
    admin_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    plans?: boolean | Service$plansArgs<ExtArgs>
    caseStudies?: boolean | Service$caseStudiesArgs<ExtArgs>
    testimonials?: boolean | Service$testimonialsArgs<ExtArgs>
    faqs?: boolean | Service$faqsArgs<ExtArgs>
    service_requests?: boolean | Service$service_requestsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Service$formArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    id?: boolean
    title?: boolean
    isPublic?: boolean
    heroHeadline?: boolean
    heroParagraph?: boolean
    heroImageUrl?: boolean
    blueprintHeadline?: boolean
    blueprintParagraph?: boolean
    blueprintImageUrl?: boolean
    bannerText?: boolean
    admin_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isPublic" | "heroHeadline" | "heroParagraph" | "heroImageUrl" | "blueprintHeadline" | "blueprintParagraph" | "blueprintImageUrl" | "bannerText" | "admin_id" | "created_at" | "deleted_at", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | Service$plansArgs<ExtArgs>
    caseStudies?: boolean | Service$caseStudiesArgs<ExtArgs>
    testimonials?: boolean | Service$testimonialsArgs<ExtArgs>
    faqs?: boolean | Service$faqsArgs<ExtArgs>
    service_requests?: boolean | Service$service_requestsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    form?: boolean | Service$formArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      plans: Prisma.$PlanPayload<ExtArgs>[]
      caseStudies: Prisma.$CaseStudyPayload<ExtArgs>[]
      testimonials: Prisma.$TestimonialPayload<ExtArgs>[]
      faqs: Prisma.$FaqPayload<ExtArgs>[]
      service_requests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      form: Prisma.$ServiceFormPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      isPublic: boolean
      heroHeadline: string | null
      heroParagraph: string | null
      heroImageUrl: string | null
      blueprintHeadline: string | null
      blueprintParagraph: string | null
      blueprintImageUrl: string | null
      bannerText: string | null
      admin_id: string
      created_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends Service$plansArgs<ExtArgs> = {}>(args?: Subset<T, Service$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caseStudies<T extends Service$caseStudiesArgs<ExtArgs> = {}>(args?: Subset<T, Service$caseStudiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonials<T extends Service$testimonialsArgs<ExtArgs> = {}>(args?: Subset<T, Service$testimonialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faqs<T extends Service$faqsArgs<ExtArgs> = {}>(args?: Subset<T, Service$faqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_requests<T extends Service$service_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Service$service_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    form<T extends Service$formArgs<ExtArgs> = {}>(args?: Subset<T, Service$formArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly title: FieldRef<"Service", 'String'>
    readonly isPublic: FieldRef<"Service", 'Boolean'>
    readonly heroHeadline: FieldRef<"Service", 'String'>
    readonly heroParagraph: FieldRef<"Service", 'String'>
    readonly heroImageUrl: FieldRef<"Service", 'String'>
    readonly blueprintHeadline: FieldRef<"Service", 'String'>
    readonly blueprintParagraph: FieldRef<"Service", 'String'>
    readonly blueprintImageUrl: FieldRef<"Service", 'String'>
    readonly bannerText: FieldRef<"Service", 'String'>
    readonly admin_id: FieldRef<"Service", 'String'>
    readonly created_at: FieldRef<"Service", 'DateTime'>
    readonly deleted_at: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.plans
   */
  export type Service$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Service.caseStudies
   */
  export type Service$caseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    cursor?: CaseStudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * Service.testimonials
   */
  export type Service$testimonialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    cursor?: TestimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Service.faqs
   */
  export type Service$faqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    where?: FaqWhereInput
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    cursor?: FaqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Service.service_requests
   */
  export type Service$service_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Service.form
   */
  export type Service$formArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    where?: ServiceFormWhereInput
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceForm
   */

  export type AggregateServiceForm = {
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  export type ServiceFormMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceFormMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceFormCountAggregateOutputType = {
    id: number
    service_id: number
    formFields: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServiceFormMinAggregateInputType = {
    id?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceFormMaxAggregateInputType = {
    id?: true
    service_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceFormCountAggregateInputType = {
    id?: true
    service_id?: true
    formFields?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServiceFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForm to aggregate.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceForms
    **/
    _count?: true | ServiceFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFormMaxAggregateInputType
  }

  export type GetServiceFormAggregateType<T extends ServiceFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceForm[P]>
      : GetScalarType<T[P], AggregateServiceForm[P]>
  }




  export type ServiceFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
    orderBy?: ServiceFormOrderByWithAggregationInput | ServiceFormOrderByWithAggregationInput[]
    by: ServiceFormScalarFieldEnum[] | ServiceFormScalarFieldEnum
    having?: ServiceFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFormCountAggregateInputType | true
    _min?: ServiceFormMinAggregateInputType
    _max?: ServiceFormMaxAggregateInputType
  }

  export type ServiceFormGroupByOutputType = {
    id: string
    service_id: string
    formFields: JsonValue
    created_at: Date | null
    updated_at: Date | null
    _count: ServiceFormCountAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  type GetServiceFormGroupByPayload<T extends ServiceFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    formFields?: boolean
    created_at?: boolean
    updated_at?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>



  export type ServiceFormSelectScalar = {
    id?: boolean
    service_id?: boolean
    formFields?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServiceFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "formFields" | "created_at" | "updated_at", ExtArgs["result"]["serviceForm"]>
  export type ServiceFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceForm"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      formFields: Prisma.JsonValue
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["serviceForm"]>
    composites: {}
  }

  type ServiceFormGetPayload<S extends boolean | null | undefined | ServiceFormDefaultArgs> = $Result.GetResult<Prisma.$ServiceFormPayload, S>

  type ServiceFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceFormCountAggregateInputType | true
    }

  export interface ServiceFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceForm'], meta: { name: 'ServiceForm' } }
    /**
     * Find zero or one ServiceForm that matches the filter.
     * @param {ServiceFormFindUniqueArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFormFindUniqueArgs>(args: SelectSubset<T, ServiceFormFindUniqueArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFormFindFirstArgs>(args?: SelectSubset<T, ServiceFormFindFirstArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany()
     * 
     * // Get first 10 ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFormFindManyArgs>(args?: SelectSubset<T, ServiceFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceForm.
     * @param {ServiceFormCreateArgs} args - Arguments to create a ServiceForm.
     * @example
     * // Create one ServiceForm
     * const ServiceForm = await prisma.serviceForm.create({
     *   data: {
     *     // ... data to create a ServiceForm
     *   }
     * })
     * 
     */
    create<T extends ServiceFormCreateArgs>(args: SelectSubset<T, ServiceFormCreateArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceForms.
     * @param {ServiceFormCreateManyArgs} args - Arguments to create many ServiceForms.
     * @example
     * // Create many ServiceForms
     * const serviceForm = await prisma.serviceForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceFormCreateManyArgs>(args?: SelectSubset<T, ServiceFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceForm.
     * @param {ServiceFormDeleteArgs} args - Arguments to delete one ServiceForm.
     * @example
     * // Delete one ServiceForm
     * const ServiceForm = await prisma.serviceForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceForm
     *   }
     * })
     * 
     */
    delete<T extends ServiceFormDeleteArgs>(args: SelectSubset<T, ServiceFormDeleteArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceForm.
     * @param {ServiceFormUpdateArgs} args - Arguments to update one ServiceForm.
     * @example
     * // Update one ServiceForm
     * const serviceForm = await prisma.serviceForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceFormUpdateArgs>(args: SelectSubset<T, ServiceFormUpdateArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceForms.
     * @param {ServiceFormDeleteManyArgs} args - Arguments to filter ServiceForms to delete.
     * @example
     * // Delete a few ServiceForms
     * const { count } = await prisma.serviceForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceFormDeleteManyArgs>(args?: SelectSubset<T, ServiceFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceForms
     * const serviceForm = await prisma.serviceForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceFormUpdateManyArgs>(args: SelectSubset<T, ServiceFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceForm.
     * @param {ServiceFormUpsertArgs} args - Arguments to update or create a ServiceForm.
     * @example
     * // Update or create a ServiceForm
     * const serviceForm = await prisma.serviceForm.upsert({
     *   create: {
     *     // ... data to create a ServiceForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceForm we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFormUpsertArgs>(args: SelectSubset<T, ServiceFormUpsertArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormCountArgs} args - Arguments to filter ServiceForms to count.
     * @example
     * // Count the number of ServiceForms
     * const count = await prisma.serviceForm.count({
     *   where: {
     *     // ... the filter for the ServiceForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceFormCountArgs>(
      args?: Subset<T, ServiceFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFormAggregateArgs>(args: Subset<T, ServiceFormAggregateArgs>): Prisma.PrismaPromise<GetServiceFormAggregateType<T>>

    /**
     * Group by ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceForm model
   */
  readonly fields: ServiceFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceForm model
   */
  interface ServiceFormFieldRefs {
    readonly id: FieldRef<"ServiceForm", 'String'>
    readonly service_id: FieldRef<"ServiceForm", 'String'>
    readonly formFields: FieldRef<"ServiceForm", 'Json'>
    readonly created_at: FieldRef<"ServiceForm", 'DateTime'>
    readonly updated_at: FieldRef<"ServiceForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceForm findUnique
   */
  export type ServiceFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findUniqueOrThrow
   */
  export type ServiceFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findFirst
   */
  export type ServiceFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm findFirstOrThrow
   */
  export type ServiceFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm findMany
   */
  export type ServiceFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForms to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm create
   */
  export type ServiceFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceForm.
     */
    data: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
  }

  /**
   * ServiceForm createMany
   */
  export type ServiceFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceForms.
     */
    data: ServiceFormCreateManyInput | ServiceFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceForm update
   */
  export type ServiceFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceForm.
     */
    data: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceForm to update.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm updateMany
   */
  export type ServiceFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceForms.
     */
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceForms to update
     */
    where?: ServiceFormWhereInput
    /**
     * Limit how many ServiceForms to update.
     */
    limit?: number
  }

  /**
   * ServiceForm upsert
   */
  export type ServiceFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceForm to update in case it exists.
     */
    where: ServiceFormWhereUniqueInput
    /**
     * In case the ServiceForm found by the `where` argument doesn't exist, create a new ServiceForm with this data.
     */
    create: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
    /**
     * In case the ServiceForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
  }

  /**
   * ServiceForm delete
   */
  export type ServiceFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceForm to delete.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm deleteMany
   */
  export type ServiceFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForms to delete
     */
    where?: ServiceFormWhereInput
    /**
     * Limit how many ServiceForms to delete.
     */
    limit?: number
  }

  /**
   * ServiceForm without action
   */
  export type ServiceFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    position: number | null
  }

  export type PlanSumAggregateOutputType = {
    position: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    priceUnit: string | null
    audience: string | null
    service_id: string | null
    position: number | null
    plan_typeId: string | null
    billing_cycleId: string | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: string | null
    priceUnit: string | null
    audience: string | null
    service_id: string | null
    position: number | null
    plan_typeId: string | null
    billing_cycleId: string | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    priceUnit: number
    audience: number
    features: number
    service_id: number
    position: number
    plan_typeId: number
    billing_cycleId: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    position?: true
  }

  export type PlanSumAggregateInputType = {
    position?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceUnit?: true
    audience?: true
    service_id?: true
    position?: true
    plan_typeId?: true
    billing_cycleId?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceUnit?: true
    audience?: true
    service_id?: true
    position?: true
    plan_typeId?: true
    billing_cycleId?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceUnit?: true
    audience?: true
    features?: true
    service_id?: true
    position?: true
    plan_typeId?: true
    billing_cycleId?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonValue
    service_id: string
    position: number
    plan_typeId: string | null
    billing_cycleId: string | null
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    priceUnit?: boolean
    audience?: boolean
    features?: boolean
    service_id?: boolean
    position?: boolean
    plan_typeId?: boolean
    billing_cycleId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    service_requests?: boolean | Plan$service_requestsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    Plan_type?: boolean | Plan$Plan_typeArgs<ExtArgs>
    Billing_cycle?: boolean | Plan$Billing_cycleArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>



  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    priceUnit?: boolean
    audience?: boolean
    features?: boolean
    service_id?: boolean
    position?: boolean
    plan_typeId?: boolean
    billing_cycleId?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "priceUnit" | "audience" | "features" | "service_id" | "position" | "plan_typeId" | "billing_cycleId", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    service_requests?: boolean | Plan$service_requestsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    Plan_type?: boolean | Plan$Plan_typeArgs<ExtArgs>
    Billing_cycle?: boolean | Plan$Billing_cycleArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      service_requests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      Plan_type: Prisma.$Plan_typePayload<ExtArgs> | null
      Billing_cycle: Prisma.$Billing_cyclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: string
      priceUnit: string
      audience: string
      features: Prisma.JsonValue
      service_id: string
      position: number
      plan_typeId: string | null
      billing_cycleId: string | null
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service_requests<T extends Plan$service_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$service_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Plan_type<T extends Plan$Plan_typeArgs<ExtArgs> = {}>(args?: Subset<T, Plan$Plan_typeArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Billing_cycle<T extends Plan$Billing_cycleArgs<ExtArgs> = {}>(args?: Subset<T, Plan$Billing_cycleArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'String'>
    readonly priceUnit: FieldRef<"Plan", 'String'>
    readonly audience: FieldRef<"Plan", 'String'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly service_id: FieldRef<"Plan", 'String'>
    readonly position: FieldRef<"Plan", 'Int'>
    readonly plan_typeId: FieldRef<"Plan", 'String'>
    readonly billing_cycleId: FieldRef<"Plan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.service_requests
   */
  export type Plan$service_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan.Plan_type
   */
  export type Plan$Plan_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    where?: Plan_typeWhereInput
  }

  /**
   * Plan.Billing_cycle
   */
  export type Plan$Billing_cycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    where?: Billing_cycleWhereInput
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    service_request_id: string | null
    amount: Decimal | null
    status: string | null
    due_date: Date | null
    paid_at: Date | null
    payment_method: string | null
    payment_reference: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    service_request_id: string | null
    amount: Decimal | null
    status: string | null
    due_date: Date | null
    paid_at: Date | null
    payment_method: string | null
    payment_reference: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    user_id: number
    service_request_id: number
    amount: number
    status: number
    due_date: number
    paid_at: number
    payment_method: number
    payment_reference: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    user_id?: true
    service_request_id?: true
    amount?: true
    status?: true
    due_date?: true
    paid_at?: true
    payment_method?: true
    payment_reference?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    user_id?: true
    service_request_id?: true
    amount?: true
    status?: true
    due_date?: true
    paid_at?: true
    payment_method?: true
    payment_reference?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    user_id?: true
    service_request_id?: true
    amount?: true
    status?: true
    due_date?: true
    paid_at?: true
    payment_method?: true
    payment_reference?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    user_id: string
    service_request_id: string | null
    amount: Decimal
    status: string
    due_date: Date
    paid_at: Date | null
    payment_method: string | null
    payment_reference: string | null
    created_at: Date
    updated_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    service_request_id?: boolean
    amount?: boolean
    status?: boolean
    due_date?: boolean
    paid_at?: boolean
    payment_method?: boolean
    payment_reference?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_request?: boolean | Invoice$service_requestArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    user_id?: boolean
    service_request_id?: boolean
    amount?: boolean
    status?: boolean
    due_date?: boolean
    paid_at?: boolean
    payment_method?: boolean
    payment_reference?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "service_request_id" | "amount" | "status" | "due_date" | "paid_at" | "payment_method" | "payment_reference" | "created_at" | "updated_at", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service_request?: boolean | Invoice$service_requestArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service_request: Prisma.$ServiceRequestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      service_request_id: string | null
      amount: Prisma.Decimal
      status: string
      due_date: Date
      paid_at: Date | null
      payment_method: string | null
      payment_reference: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service_request<T extends Invoice$service_requestArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$service_requestArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly user_id: FieldRef<"Invoice", 'String'>
    readonly service_request_id: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly due_date: FieldRef<"Invoice", 'DateTime'>
    readonly paid_at: FieldRef<"Invoice", 'DateTime'>
    readonly payment_method: FieldRef<"Invoice", 'String'>
    readonly payment_reference: FieldRef<"Invoice", 'String'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
    readonly updated_at: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.service_request
   */
  export type Invoice$service_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model CaseStudy
   */

  export type AggregateCaseStudy = {
    _count: CaseStudyCountAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  export type CaseStudyMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    bannerImageUrl: string | null
    challenge: string | null
    challengeImageUrl: string | null
    solution: string | null
    solutionImageUrl: string | null
    result: string | null
    resultImageUrl: string | null
    service_id: string | null
    organisationId: string | null
  }

  export type CaseStudyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    bannerImageUrl: string | null
    challenge: string | null
    challengeImageUrl: string | null
    solution: string | null
    solutionImageUrl: string | null
    result: string | null
    resultImageUrl: string | null
    service_id: string | null
    organisationId: string | null
  }

  export type CaseStudyCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    bannerImageUrl: number
    challenge: number
    challengeImageUrl: number
    solution: number
    solutionImageUrl: number
    result: number
    resultImageUrl: number
    service_id: number
    organisationId: number
    _all: number
  }


  export type CaseStudyMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    bannerImageUrl?: true
    challenge?: true
    challengeImageUrl?: true
    solution?: true
    solutionImageUrl?: true
    result?: true
    resultImageUrl?: true
    service_id?: true
    organisationId?: true
  }

  export type CaseStudyMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    bannerImageUrl?: true
    challenge?: true
    challengeImageUrl?: true
    solution?: true
    solutionImageUrl?: true
    result?: true
    resultImageUrl?: true
    service_id?: true
    organisationId?: true
  }

  export type CaseStudyCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    bannerImageUrl?: true
    challenge?: true
    challengeImageUrl?: true
    solution?: true
    solutionImageUrl?: true
    result?: true
    resultImageUrl?: true
    service_id?: true
    organisationId?: true
    _all?: true
  }

  export type CaseStudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudy to aggregate.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseStudies
    **/
    _count?: true | CaseStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseStudyMaxAggregateInputType
  }

  export type GetCaseStudyAggregateType<T extends CaseStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseStudy[P]>
      : GetScalarType<T[P], AggregateCaseStudy[P]>
  }




  export type CaseStudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithAggregationInput | CaseStudyOrderByWithAggregationInput[]
    by: CaseStudyScalarFieldEnum[] | CaseStudyScalarFieldEnum
    having?: CaseStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseStudyCountAggregateInputType | true
    _min?: CaseStudyMinAggregateInputType
    _max?: CaseStudyMaxAggregateInputType
  }

  export type CaseStudyGroupByOutputType = {
    id: string
    title: string
    subtitle: string
    bannerImageUrl: string | null
    challenge: string | null
    challengeImageUrl: string | null
    solution: string | null
    solutionImageUrl: string | null
    result: string | null
    resultImageUrl: string | null
    service_id: string
    organisationId: string | null
    _count: CaseStudyCountAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  type GetCaseStudyGroupByPayload<T extends CaseStudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseStudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseStudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
            : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
        }
      >
    >


  export type CaseStudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    bannerImageUrl?: boolean
    challenge?: boolean
    challengeImageUrl?: boolean
    solution?: boolean
    solutionImageUrl?: boolean
    result?: boolean
    resultImageUrl?: boolean
    service_id?: boolean
    organisationId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    Organisation?: boolean | CaseStudy$OrganisationArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudy"]>



  export type CaseStudySelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    bannerImageUrl?: boolean
    challenge?: boolean
    challengeImageUrl?: boolean
    solution?: boolean
    solutionImageUrl?: boolean
    result?: boolean
    resultImageUrl?: boolean
    service_id?: boolean
    organisationId?: boolean
  }

  export type CaseStudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "bannerImageUrl" | "challenge" | "challengeImageUrl" | "solution" | "solutionImageUrl" | "result" | "resultImageUrl" | "service_id" | "organisationId", ExtArgs["result"]["caseStudy"]>
  export type CaseStudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    Organisation?: boolean | CaseStudy$OrganisationArgs<ExtArgs>
  }

  export type $CaseStudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseStudy"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      Organisation: Prisma.$OrganisationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string
      bannerImageUrl: string | null
      challenge: string | null
      challengeImageUrl: string | null
      solution: string | null
      solutionImageUrl: string | null
      result: string | null
      resultImageUrl: string | null
      service_id: string
      organisationId: string | null
    }, ExtArgs["result"]["caseStudy"]>
    composites: {}
  }

  type CaseStudyGetPayload<S extends boolean | null | undefined | CaseStudyDefaultArgs> = $Result.GetResult<Prisma.$CaseStudyPayload, S>

  type CaseStudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseStudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseStudyCountAggregateInputType | true
    }

  export interface CaseStudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseStudy'], meta: { name: 'CaseStudy' } }
    /**
     * Find zero or one CaseStudy that matches the filter.
     * @param {CaseStudyFindUniqueArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseStudyFindUniqueArgs>(args: SelectSubset<T, CaseStudyFindUniqueArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseStudy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseStudyFindUniqueOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseStudyFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseStudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseStudyFindFirstArgs>(args?: SelectSubset<T, CaseStudyFindFirstArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseStudyFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseStudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany()
     * 
     * // Get first 10 CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseStudyFindManyArgs>(args?: SelectSubset<T, CaseStudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseStudy.
     * @param {CaseStudyCreateArgs} args - Arguments to create a CaseStudy.
     * @example
     * // Create one CaseStudy
     * const CaseStudy = await prisma.caseStudy.create({
     *   data: {
     *     // ... data to create a CaseStudy
     *   }
     * })
     * 
     */
    create<T extends CaseStudyCreateArgs>(args: SelectSubset<T, CaseStudyCreateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseStudies.
     * @param {CaseStudyCreateManyArgs} args - Arguments to create many CaseStudies.
     * @example
     * // Create many CaseStudies
     * const caseStudy = await prisma.caseStudy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseStudyCreateManyArgs>(args?: SelectSubset<T, CaseStudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CaseStudy.
     * @param {CaseStudyDeleteArgs} args - Arguments to delete one CaseStudy.
     * @example
     * // Delete one CaseStudy
     * const CaseStudy = await prisma.caseStudy.delete({
     *   where: {
     *     // ... filter to delete one CaseStudy
     *   }
     * })
     * 
     */
    delete<T extends CaseStudyDeleteArgs>(args: SelectSubset<T, CaseStudyDeleteArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseStudy.
     * @param {CaseStudyUpdateArgs} args - Arguments to update one CaseStudy.
     * @example
     * // Update one CaseStudy
     * const caseStudy = await prisma.caseStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseStudyUpdateArgs>(args: SelectSubset<T, CaseStudyUpdateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseStudies.
     * @param {CaseStudyDeleteManyArgs} args - Arguments to filter CaseStudies to delete.
     * @example
     * // Delete a few CaseStudies
     * const { count } = await prisma.caseStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseStudyDeleteManyArgs>(args?: SelectSubset<T, CaseStudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseStudies
     * const caseStudy = await prisma.caseStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseStudyUpdateManyArgs>(args: SelectSubset<T, CaseStudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CaseStudy.
     * @param {CaseStudyUpsertArgs} args - Arguments to update or create a CaseStudy.
     * @example
     * // Update or create a CaseStudy
     * const caseStudy = await prisma.caseStudy.upsert({
     *   create: {
     *     // ... data to create a CaseStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseStudy we want to update
     *   }
     * })
     */
    upsert<T extends CaseStudyUpsertArgs>(args: SelectSubset<T, CaseStudyUpsertArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyCountArgs} args - Arguments to filter CaseStudies to count.
     * @example
     * // Count the number of CaseStudies
     * const count = await prisma.caseStudy.count({
     *   where: {
     *     // ... the filter for the CaseStudies we want to count
     *   }
     * })
    **/
    count<T extends CaseStudyCountArgs>(
      args?: Subset<T, CaseStudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseStudyAggregateArgs>(args: Subset<T, CaseStudyAggregateArgs>): Prisma.PrismaPromise<GetCaseStudyAggregateType<T>>

    /**
     * Group by CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseStudyGroupByArgs['orderBy'] }
        : { orderBy?: CaseStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseStudy model
   */
  readonly fields: CaseStudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseStudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Organisation<T extends CaseStudy$OrganisationArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudy$OrganisationArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseStudy model
   */
  interface CaseStudyFieldRefs {
    readonly id: FieldRef<"CaseStudy", 'String'>
    readonly title: FieldRef<"CaseStudy", 'String'>
    readonly subtitle: FieldRef<"CaseStudy", 'String'>
    readonly bannerImageUrl: FieldRef<"CaseStudy", 'String'>
    readonly challenge: FieldRef<"CaseStudy", 'String'>
    readonly challengeImageUrl: FieldRef<"CaseStudy", 'String'>
    readonly solution: FieldRef<"CaseStudy", 'String'>
    readonly solutionImageUrl: FieldRef<"CaseStudy", 'String'>
    readonly result: FieldRef<"CaseStudy", 'String'>
    readonly resultImageUrl: FieldRef<"CaseStudy", 'String'>
    readonly service_id: FieldRef<"CaseStudy", 'String'>
    readonly organisationId: FieldRef<"CaseStudy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CaseStudy findUnique
   */
  export type CaseStudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findUniqueOrThrow
   */
  export type CaseStudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findFirst
   */
  export type CaseStudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findFirstOrThrow
   */
  export type CaseStudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findMany
   */
  export type CaseStudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudies to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy create
   */
  export type CaseStudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseStudy.
     */
    data: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
  }

  /**
   * CaseStudy createMany
   */
  export type CaseStudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseStudies.
     */
    data: CaseStudyCreateManyInput | CaseStudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudy update
   */
  export type CaseStudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseStudy.
     */
    data: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
    /**
     * Choose, which CaseStudy to update.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy updateMany
   */
  export type CaseStudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseStudies.
     */
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudies to update
     */
    where?: CaseStudyWhereInput
    /**
     * Limit how many CaseStudies to update.
     */
    limit?: number
  }

  /**
   * CaseStudy upsert
   */
  export type CaseStudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseStudy to update in case it exists.
     */
    where: CaseStudyWhereUniqueInput
    /**
     * In case the CaseStudy found by the `where` argument doesn't exist, create a new CaseStudy with this data.
     */
    create: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
    /**
     * In case the CaseStudy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
  }

  /**
   * CaseStudy delete
   */
  export type CaseStudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter which CaseStudy to delete.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy deleteMany
   */
  export type CaseStudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudies to delete
     */
    where?: CaseStudyWhereInput
    /**
     * Limit how many CaseStudies to delete.
     */
    limit?: number
  }

  /**
   * CaseStudy.Organisation
   */
  export type CaseStudy$OrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    where?: OrganisationWhereInput
  }

  /**
   * CaseStudy without action
   */
  export type CaseStudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    stars: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    stars: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    quote: string | null
    authorName: string | null
    authorTitle: string | null
    stars: number | null
    authorImageUrl: string | null
    service_id: string | null
    user_id: string | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    quote: string | null
    authorName: string | null
    authorTitle: string | null
    stars: number | null
    authorImageUrl: string | null
    service_id: string | null
    user_id: string | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    quote: number
    authorName: number
    authorTitle: number
    stars: number
    authorImageUrl: number
    service_id: number
    user_id: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    stars?: true
  }

  export type TestimonialSumAggregateInputType = {
    stars?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    quote?: true
    authorName?: true
    authorTitle?: true
    stars?: true
    authorImageUrl?: true
    service_id?: true
    user_id?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    quote?: true
    authorName?: true
    authorTitle?: true
    stars?: true
    authorImageUrl?: true
    service_id?: true
    user_id?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    quote?: true
    authorName?: true
    authorTitle?: true
    stars?: true
    authorImageUrl?: true
    service_id?: true
    user_id?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    quote: string
    authorName: string
    authorTitle: string
    stars: number
    authorImageUrl: string | null
    service_id: string
    user_id: string
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote?: boolean
    authorName?: boolean
    authorTitle?: boolean
    stars?: boolean
    authorImageUrl?: boolean
    service_id?: boolean
    user_id?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>



  export type TestimonialSelectScalar = {
    id?: boolean
    quote?: boolean
    authorName?: boolean
    authorTitle?: boolean
    stars?: boolean
    authorImageUrl?: boolean
    service_id?: boolean
    user_id?: boolean
  }

  export type TestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote" | "authorName" | "authorTitle" | "stars" | "authorImageUrl" | "service_id" | "user_id", ExtArgs["result"]["testimonial"]>
  export type TestimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quote: string
      authorName: string
      authorTitle: string
      stars: number
      authorImageUrl: string | null
      service_id: string
      user_id: string
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly quote: FieldRef<"Testimonial", 'String'>
    readonly authorName: FieldRef<"Testimonial", 'String'>
    readonly authorTitle: FieldRef<"Testimonial", 'String'>
    readonly stars: FieldRef<"Testimonial", 'Int'>
    readonly authorImageUrl: FieldRef<"Testimonial", 'String'>
    readonly service_id: FieldRef<"Testimonial", 'String'>
    readonly user_id: FieldRef<"Testimonial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to delete.
     */
    limit?: number
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestimonialInclude<ExtArgs> | null
  }


  /**
   * Model Faq
   */

  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    service_id: string | null
  }

  export type FaqMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    service_id: string | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    service_id: number
    _all: number
  }


  export type FaqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    service_id?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    service_id?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    service_id?: true
    _all?: true
  }

  export type FaqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faq to aggregate.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type FaqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaqWhereInput
    orderBy?: FaqOrderByWithAggregationInput | FaqOrderByWithAggregationInput[]
    by: FaqScalarFieldEnum[] | FaqScalarFieldEnum
    having?: FaqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }

  export type FaqGroupByOutputType = {
    id: string
    question: string
    answer: string
    service_id: string
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type FaqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    service_id?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faq"]>



  export type FaqSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    service_id?: boolean
  }

  export type FaqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "service_id", ExtArgs["result"]["faq"]>
  export type FaqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $FaqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faq"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      service_id: string
    }, ExtArgs["result"]["faq"]>
    composites: {}
  }

  type FaqGetPayload<S extends boolean | null | undefined | FaqDefaultArgs> = $Result.GetResult<Prisma.$FaqPayload, S>

  type FaqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FaqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqCountAggregateInputType | true
    }

  export interface FaqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faq'], meta: { name: 'Faq' } }
    /**
     * Find zero or one Faq that matches the filter.
     * @param {FaqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FaqFindUniqueArgs>(args: SelectSubset<T, FaqFindUniqueArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FaqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FaqFindUniqueOrThrowArgs>(args: SelectSubset<T, FaqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FaqFindFirstArgs>(args?: SelectSubset<T, FaqFindFirstArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FaqFindFirstOrThrowArgs>(args?: SelectSubset<T, FaqFindFirstOrThrowArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FaqFindManyArgs>(args?: SelectSubset<T, FaqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faq.
     * @param {FaqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
     */
    create<T extends FaqCreateArgs>(args: SelectSubset<T, FaqCreateArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {FaqCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faq = await prisma.faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FaqCreateManyArgs>(args?: SelectSubset<T, FaqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {FaqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
     */
    delete<T extends FaqDeleteArgs>(args: SelectSubset<T, FaqDeleteArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faq.
     * @param {FaqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FaqUpdateArgs>(args: SelectSubset<T, FaqUpdateArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {FaqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FaqDeleteManyArgs>(args?: SelectSubset<T, FaqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FaqUpdateManyArgs>(args: SelectSubset<T, FaqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {FaqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
     */
    upsert<T extends FaqUpsertArgs>(args: SelectSubset<T, FaqUpsertArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqCountArgs>(
      args?: Subset<T, FaqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): Prisma.PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faq model
   */
  readonly fields: FaqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FaqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faq model
   */
  interface FaqFieldRefs {
    readonly id: FieldRef<"Faq", 'String'>
    readonly question: FieldRef<"Faq", 'String'>
    readonly answer: FieldRef<"Faq", 'String'>
    readonly service_id: FieldRef<"Faq", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Faq findUnique
   */
  export type FaqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq findUniqueOrThrow
   */
  export type FaqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq findFirst
   */
  export type FaqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq findFirstOrThrow
   */
  export type FaqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq findMany
   */
  export type FaqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq create
   */
  export type FaqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The data needed to create a Faq.
     */
    data: XOR<FaqCreateInput, FaqUncheckedCreateInput>
  }

  /**
   * Faq createMany
   */
  export type FaqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faqs.
     */
    data: FaqCreateManyInput | FaqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faq update
   */
  export type FaqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The data needed to update a Faq.
     */
    data: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
    /**
     * Choose, which Faq to update.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq updateMany
   */
  export type FaqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faqs.
     */
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     */
    where?: FaqWhereInput
    /**
     * Limit how many Faqs to update.
     */
    limit?: number
  }

  /**
   * Faq upsert
   */
  export type FaqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The filter to search for the Faq to update in case it exists.
     */
    where: FaqWhereUniqueInput
    /**
     * In case the Faq found by the `where` argument doesn't exist, create a new Faq with this data.
     */
    create: XOR<FaqCreateInput, FaqUncheckedCreateInput>
    /**
     * In case the Faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
  }

  /**
   * Faq delete
   */
  export type FaqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter which Faq to delete.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq deleteMany
   */
  export type FaqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faqs to delete
     */
    where?: FaqWhereInput
    /**
     * Limit how many Faqs to delete.
     */
    limit?: number
  }

  /**
   * Faq without action
   */
  export type FaqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRequest
   */

  export type AggregateServiceRequest = {
    _count: ServiceRequestCountAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  export type ServiceRequestMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    service_id: string | null
    plan_name: string | null
    status: $Enums.ServiceRequestStatus | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    planId: string | null
  }

  export type ServiceRequestMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    service_id: string | null
    plan_name: string | null
    status: $Enums.ServiceRequestStatus | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    planId: string | null
  }

  export type ServiceRequestCountAggregateOutputType = {
    id: number
    user_id: number
    service_id: number
    plan_name: number
    status: number
    start_date: number
    end_date: number
    formData: number
    created_at: number
    updated_at: number
    planId: number
    _all: number
  }


  export type ServiceRequestMinAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    plan_name?: true
    status?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    planId?: true
  }

  export type ServiceRequestMaxAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    plan_name?: true
    status?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    planId?: true
  }

  export type ServiceRequestCountAggregateInputType = {
    id?: true
    user_id?: true
    service_id?: true
    plan_name?: true
    status?: true
    start_date?: true
    end_date?: true
    formData?: true
    created_at?: true
    updated_at?: true
    planId?: true
    _all?: true
  }

  export type ServiceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequest to aggregate.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRequests
    **/
    _count?: true | ServiceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type GetServiceRequestAggregateType<T extends ServiceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRequest[P]>
      : GetScalarType<T[P], AggregateServiceRequest[P]>
  }




  export type ServiceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithAggregationInput | ServiceRequestOrderByWithAggregationInput[]
    by: ServiceRequestScalarFieldEnum[] | ServiceRequestScalarFieldEnum
    having?: ServiceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRequestCountAggregateInputType | true
    _min?: ServiceRequestMinAggregateInputType
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type ServiceRequestGroupByOutputType = {
    id: string
    user_id: string
    service_id: string
    plan_name: string
    status: $Enums.ServiceRequestStatus
    start_date: Date | null
    end_date: Date | null
    formData: JsonValue
    created_at: Date
    updated_at: Date
    planId: string | null
    _count: ServiceRequestCountAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  type GetServiceRequestGroupByPayload<T extends ServiceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    service_id?: boolean
    plan_name?: boolean
    status?: boolean
    start_date?: boolean
    end_date?: boolean
    formData?: boolean
    created_at?: boolean
    updated_at?: boolean
    planId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    invoice?: boolean | ServiceRequest$invoiceArgs<ExtArgs>
    milestones?: boolean | ServiceRequest$milestonesArgs<ExtArgs>
    Plan?: boolean | ServiceRequest$PlanArgs<ExtArgs>
    conversation?: boolean | ServiceRequest$conversationArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>



  export type ServiceRequestSelectScalar = {
    id?: boolean
    user_id?: boolean
    service_id?: boolean
    plan_name?: boolean
    status?: boolean
    start_date?: boolean
    end_date?: boolean
    formData?: boolean
    created_at?: boolean
    updated_at?: boolean
    planId?: boolean
  }

  export type ServiceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "service_id" | "plan_name" | "status" | "start_date" | "end_date" | "formData" | "created_at" | "updated_at" | "planId", ExtArgs["result"]["serviceRequest"]>
  export type ServiceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    invoice?: boolean | ServiceRequest$invoiceArgs<ExtArgs>
    milestones?: boolean | ServiceRequest$milestonesArgs<ExtArgs>
    Plan?: boolean | ServiceRequest$PlanArgs<ExtArgs>
    conversation?: boolean | ServiceRequest$conversationArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      Plan: Prisma.$PlanPayload<ExtArgs> | null
      conversation: Prisma.$ConversationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      service_id: string
      plan_name: string
      status: $Enums.ServiceRequestStatus
      start_date: Date | null
      end_date: Date | null
      formData: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      planId: string | null
    }, ExtArgs["result"]["serviceRequest"]>
    composites: {}
  }

  type ServiceRequestGetPayload<S extends boolean | null | undefined | ServiceRequestDefaultArgs> = $Result.GetResult<Prisma.$ServiceRequestPayload, S>

  type ServiceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRequestCountAggregateInputType | true
    }

  export interface ServiceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRequest'], meta: { name: 'ServiceRequest' } }
    /**
     * Find zero or one ServiceRequest that matches the filter.
     * @param {ServiceRequestFindUniqueArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRequestFindUniqueArgs>(args: SelectSubset<T, ServiceRequestFindUniqueArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRequestFindUniqueOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRequestFindFirstArgs>(args?: SelectSubset<T, ServiceRequestFindFirstArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany()
     * 
     * // Get first 10 ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRequestFindManyArgs>(args?: SelectSubset<T, ServiceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRequest.
     * @param {ServiceRequestCreateArgs} args - Arguments to create a ServiceRequest.
     * @example
     * // Create one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.create({
     *   data: {
     *     // ... data to create a ServiceRequest
     *   }
     * })
     * 
     */
    create<T extends ServiceRequestCreateArgs>(args: SelectSubset<T, ServiceRequestCreateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRequests.
     * @param {ServiceRequestCreateManyArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRequestCreateManyArgs>(args?: SelectSubset<T, ServiceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceRequest.
     * @param {ServiceRequestDeleteArgs} args - Arguments to delete one ServiceRequest.
     * @example
     * // Delete one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.delete({
     *   where: {
     *     // ... filter to delete one ServiceRequest
     *   }
     * })
     * 
     */
    delete<T extends ServiceRequestDeleteArgs>(args: SelectSubset<T, ServiceRequestDeleteArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRequest.
     * @param {ServiceRequestUpdateArgs} args - Arguments to update one ServiceRequest.
     * @example
     * // Update one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRequestUpdateArgs>(args: SelectSubset<T, ServiceRequestUpdateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRequests.
     * @param {ServiceRequestDeleteManyArgs} args - Arguments to filter ServiceRequests to delete.
     * @example
     * // Delete a few ServiceRequests
     * const { count } = await prisma.serviceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRequestDeleteManyArgs>(args?: SelectSubset<T, ServiceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRequestUpdateManyArgs>(args: SelectSubset<T, ServiceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceRequest.
     * @param {ServiceRequestUpsertArgs} args - Arguments to update or create a ServiceRequest.
     * @example
     * // Update or create a ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.upsert({
     *   create: {
     *     // ... data to create a ServiceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRequest we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRequestUpsertArgs>(args: SelectSubset<T, ServiceRequestUpsertArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestCountArgs} args - Arguments to filter ServiceRequests to count.
     * @example
     * // Count the number of ServiceRequests
     * const count = await prisma.serviceRequest.count({
     *   where: {
     *     // ... the filter for the ServiceRequests we want to count
     *   }
     * })
    **/
    count<T extends ServiceRequestCountArgs>(
      args?: Subset<T, ServiceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRequestAggregateArgs>(args: Subset<T, ServiceRequestAggregateArgs>): Prisma.PrismaPromise<GetServiceRequestAggregateType<T>>

    /**
     * Group by ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRequestGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRequest model
   */
  readonly fields: ServiceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends ServiceRequest$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    milestones<T extends ServiceRequest$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Plan<T extends ServiceRequest$PlanArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$PlanArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conversation<T extends ServiceRequest$conversationArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$conversationArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRequest model
   */
  interface ServiceRequestFieldRefs {
    readonly id: FieldRef<"ServiceRequest", 'String'>
    readonly user_id: FieldRef<"ServiceRequest", 'String'>
    readonly service_id: FieldRef<"ServiceRequest", 'String'>
    readonly plan_name: FieldRef<"ServiceRequest", 'String'>
    readonly status: FieldRef<"ServiceRequest", 'ServiceRequestStatus'>
    readonly start_date: FieldRef<"ServiceRequest", 'DateTime'>
    readonly end_date: FieldRef<"ServiceRequest", 'DateTime'>
    readonly formData: FieldRef<"ServiceRequest", 'Json'>
    readonly created_at: FieldRef<"ServiceRequest", 'DateTime'>
    readonly updated_at: FieldRef<"ServiceRequest", 'DateTime'>
    readonly planId: FieldRef<"ServiceRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRequest findUnique
   */
  export type ServiceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findUniqueOrThrow
   */
  export type ServiceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findFirst
   */
  export type ServiceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findFirstOrThrow
   */
  export type ServiceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findMany
   */
  export type ServiceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequests to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest create
   */
  export type ServiceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRequest.
     */
    data: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
  }

  /**
   * ServiceRequest createMany
   */
  export type ServiceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceRequest update
   */
  export type ServiceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRequest.
     */
    data: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
    /**
     * Choose, which ServiceRequest to update.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest updateMany
   */
  export type ServiceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to update.
     */
    limit?: number
  }

  /**
   * ServiceRequest upsert
   */
  export type ServiceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRequest to update in case it exists.
     */
    where: ServiceRequestWhereUniqueInput
    /**
     * In case the ServiceRequest found by the `where` argument doesn't exist, create a new ServiceRequest with this data.
     */
    create: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
    /**
     * In case the ServiceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
  }

  /**
   * ServiceRequest delete
   */
  export type ServiceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter which ServiceRequest to delete.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest deleteMany
   */
  export type ServiceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequests to delete
     */
    where?: ServiceRequestWhereInput
    /**
     * Limit how many ServiceRequests to delete.
     */
    limit?: number
  }

  /**
   * ServiceRequest.invoice
   */
  export type ServiceRequest$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * ServiceRequest.milestones
   */
  export type ServiceRequest$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * ServiceRequest.Plan
   */
  export type ServiceRequest$PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * ServiceRequest.conversation
   */
  export type ServiceRequest$conversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
  }

  /**
   * ServiceRequest without action
   */
  export type ServiceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRequest
     */
    omit?: ServiceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    service_request_id: string | null
    title: string | null
    deadline: Date | null
    deliverable_file_url: string | null
    deliverable_file_name: string | null
    deliverable_link_url: string | null
    status: $Enums.MilestoneStatus | null
    rejection_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    service_request_id: string | null
    title: string | null
    deadline: Date | null
    deliverable_file_url: string | null
    deliverable_file_name: string | null
    deliverable_link_url: string | null
    status: $Enums.MilestoneStatus | null
    rejection_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    service_request_id: number
    title: number
    deadline: number
    deliverable_file_url: number
    deliverable_file_name: number
    deliverable_link_url: number
    status: number
    rejection_reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    service_request_id?: true
    title?: true
    deadline?: true
    deliverable_file_url?: true
    deliverable_file_name?: true
    deliverable_link_url?: true
    status?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    service_request_id?: true
    title?: true
    deadline?: true
    deliverable_file_url?: true
    deliverable_file_name?: true
    deliverable_link_url?: true
    status?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    service_request_id?: true
    title?: true
    deadline?: true
    deliverable_file_url?: true
    deliverable_file_name?: true
    deliverable_link_url?: true
    status?: true
    rejection_reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    service_request_id: string
    title: string
    deadline: Date
    deliverable_file_url: string | null
    deliverable_file_name: string | null
    deliverable_link_url: string | null
    status: $Enums.MilestoneStatus
    rejection_reason: string | null
    created_at: Date
    updated_at: Date
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_request_id?: boolean
    title?: boolean
    deadline?: boolean
    deliverable_file_url?: boolean
    deliverable_file_name?: boolean
    deliverable_link_url?: boolean
    status?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    service_request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>



  export type MilestoneSelectScalar = {
    id?: boolean
    service_request_id?: boolean
    title?: boolean
    deadline?: boolean
    deliverable_file_url?: boolean
    deliverable_file_name?: boolean
    deliverable_link_url?: boolean
    status?: boolean
    rejection_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_request_id" | "title" | "deadline" | "deliverable_file_url" | "deliverable_file_name" | "deliverable_link_url" | "status" | "rejection_reason" | "created_at" | "updated_at", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      service_request: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_request_id: string
      title: string
      deadline: Date
      deliverable_file_url: string | null
      deliverable_file_name: string | null
      deliverable_link_url: string | null
      status: $Enums.MilestoneStatus
      rejection_reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service_request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly service_request_id: FieldRef<"Milestone", 'String'>
    readonly title: FieldRef<"Milestone", 'String'>
    readonly deadline: FieldRef<"Milestone", 'DateTime'>
    readonly deliverable_file_url: FieldRef<"Milestone", 'String'>
    readonly deliverable_file_name: FieldRef<"Milestone", 'String'>
    readonly deliverable_link_url: FieldRef<"Milestone", 'String'>
    readonly status: FieldRef<"Milestone", 'MilestoneStatus'>
    readonly rejection_reason: FieldRef<"Milestone", 'String'>
    readonly created_at: FieldRef<"Milestone", 'DateTime'>
    readonly updated_at: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    pfp_url: string | null
    organisation_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pfp_url: string | null
    organisation_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    pfp_url: number
    organisation_id: number
    id_url: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    id_url?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonValue
    created_at: Date | null
    deleted_at: Date | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pfp_url?: boolean
    organisation_id?: boolean
    id_url?: boolean
    created_at?: boolean
    deleted_at?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    pfp_url?: boolean
    organisation_id?: boolean
    id_url?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pfp_url" | "organisation_id" | "id_url" | "created_at" | "deleted_at", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      pfp_url: string
      organisation_id: string
      id_url: Prisma.JsonValue
      created_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly pfp_url: FieldRef<"Contact", 'String'>
    readonly organisation_id: FieldRef<"Contact", 'String'>
    readonly id_url: FieldRef<"Contact", 'Json'>
    readonly created_at: FieldRef<"Contact", 'DateTime'>
    readonly deleted_at: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    otp: number
    expires_at: number
    created_at: number
    user_id: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    otp: string
    expires_at: Date | null
    created_at: Date | null
    user_id: string
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "otp" | "expires_at" | "created_at" | "user_id", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      otp: string
      expires_at: Date | null
      created_at: Date | null
      user_id: string
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly expires_at: FieldRef<"Otp", 'DateTime'>
    readonly created_at: FieldRef<"Otp", 'DateTime'>
    readonly user_id: FieldRef<"Otp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    service_request_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    service_request_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    service_request_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    service_request_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    service_request_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    service_request_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    service_request_id: string
    created_at: Date
    updated_at: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_request_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    service_request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>



  export type ConversationSelectScalar = {
    id?: boolean
    service_request_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_request_id" | "created_at" | "updated_at", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_request?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      service_request: Prisma.$ServiceRequestPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_request_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service_request<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly service_request_id: FieldRef<"Conversation", 'String'>
    readonly created_at: FieldRef<"Conversation", 'DateTime'>
    readonly updated_at: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversation_id: string | null
    sender_id: string | null
    text: string | null
    created_at: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversation_id: string | null
    sender_id: string | null
    text: string | null
    created_at: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversation_id: number
    sender_id: number
    text: number
    created_at: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    text?: true
    created_at?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    text?: true
    created_at?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversation_id?: true
    sender_id?: true
    text?: true
    created_at?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversation_id: string
    sender_id: string
    text: string
    created_at: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    text?: boolean
    created_at?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    conversation_id?: boolean
    sender_id?: boolean
    text?: boolean
    created_at?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversation_id" | "sender_id" | "text" | "created_at", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversation_id: string
      sender_id: string
      text: string
      created_at: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversation_id: FieldRef<"Message", 'String'>
    readonly sender_id: FieldRef<"Message", 'String'>
    readonly text: FieldRef<"Message", 'String'>
    readonly created_at: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Password_token
   */

  export type AggregatePassword_token = {
    _count: Password_tokenCountAggregateOutputType | null
    _min: Password_tokenMinAggregateOutputType | null
    _max: Password_tokenMaxAggregateOutputType | null
  }

  export type Password_tokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    expires_at: Date | null
    user_id: string | null
  }

  export type Password_tokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    expires_at: Date | null
    user_id: string | null
  }

  export type Password_tokenCountAggregateOutputType = {
    id: number
    token: number
    created_at: number
    expires_at: number
    user_id: number
    _all: number
  }


  export type Password_tokenMinAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
  }

  export type Password_tokenMaxAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
  }

  export type Password_tokenCountAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
    _all?: true
  }

  export type Password_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Password_token to aggregate.
     */
    where?: Password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_tokens to fetch.
     */
    orderBy?: Password_tokenOrderByWithRelationInput | Password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Password_tokens
    **/
    _count?: true | Password_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_tokenMaxAggregateInputType
  }

  export type GetPassword_tokenAggregateType<T extends Password_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_token[P]>
      : GetScalarType<T[P], AggregatePassword_token[P]>
  }




  export type Password_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Password_tokenWhereInput
    orderBy?: Password_tokenOrderByWithAggregationInput | Password_tokenOrderByWithAggregationInput[]
    by: Password_tokenScalarFieldEnum[] | Password_tokenScalarFieldEnum
    having?: Password_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_tokenCountAggregateInputType | true
    _min?: Password_tokenMinAggregateInputType
    _max?: Password_tokenMaxAggregateInputType
  }

  export type Password_tokenGroupByOutputType = {
    id: string
    token: string
    created_at: Date | null
    expires_at: Date | null
    user_id: string
    _count: Password_tokenCountAggregateOutputType | null
    _min: Password_tokenMinAggregateOutputType | null
    _max: Password_tokenMaxAggregateOutputType | null
  }

  type GetPassword_tokenGroupByPayload<T extends Password_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Password_tokenGroupByOutputType[P]>
        }
      >
    >


  export type Password_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    created_at?: boolean
    expires_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_token"]>



  export type Password_tokenSelectScalar = {
    id?: boolean
    token?: boolean
    created_at?: boolean
    expires_at?: boolean
    user_id?: boolean
  }

  export type Password_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "created_at" | "expires_at" | "user_id", ExtArgs["result"]["password_token"]>
  export type Password_tokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $Password_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Password_token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      created_at: Date | null
      expires_at: Date | null
      user_id: string
    }, ExtArgs["result"]["password_token"]>
    composites: {}
  }

  type Password_tokenGetPayload<S extends boolean | null | undefined | Password_tokenDefaultArgs> = $Result.GetResult<Prisma.$Password_tokenPayload, S>

  type Password_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Password_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_tokenCountAggregateInputType | true
    }

  export interface Password_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Password_token'], meta: { name: 'Password_token' } }
    /**
     * Find zero or one Password_token that matches the filter.
     * @param {Password_tokenFindUniqueArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Password_tokenFindUniqueArgs>(args: SelectSubset<T, Password_tokenFindUniqueArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Password_tokenFindUniqueOrThrowArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Password_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, Password_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenFindFirstArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Password_tokenFindFirstArgs>(args?: SelectSubset<T, Password_tokenFindFirstArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenFindFirstOrThrowArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Password_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, Password_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_tokens
     * const password_tokens = await prisma.password_token.findMany()
     * 
     * // Get first 10 Password_tokens
     * const password_tokens = await prisma.password_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_tokenWithIdOnly = await prisma.password_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Password_tokenFindManyArgs>(args?: SelectSubset<T, Password_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_token.
     * @param {Password_tokenCreateArgs} args - Arguments to create a Password_token.
     * @example
     * // Create one Password_token
     * const Password_token = await prisma.password_token.create({
     *   data: {
     *     // ... data to create a Password_token
     *   }
     * })
     * 
     */
    create<T extends Password_tokenCreateArgs>(args: SelectSubset<T, Password_tokenCreateArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_tokens.
     * @param {Password_tokenCreateManyArgs} args - Arguments to create many Password_tokens.
     * @example
     * // Create many Password_tokens
     * const password_token = await prisma.password_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Password_tokenCreateManyArgs>(args?: SelectSubset<T, Password_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Password_token.
     * @param {Password_tokenDeleteArgs} args - Arguments to delete one Password_token.
     * @example
     * // Delete one Password_token
     * const Password_token = await prisma.password_token.delete({
     *   where: {
     *     // ... filter to delete one Password_token
     *   }
     * })
     * 
     */
    delete<T extends Password_tokenDeleteArgs>(args: SelectSubset<T, Password_tokenDeleteArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_token.
     * @param {Password_tokenUpdateArgs} args - Arguments to update one Password_token.
     * @example
     * // Update one Password_token
     * const password_token = await prisma.password_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Password_tokenUpdateArgs>(args: SelectSubset<T, Password_tokenUpdateArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_tokens.
     * @param {Password_tokenDeleteManyArgs} args - Arguments to filter Password_tokens to delete.
     * @example
     * // Delete a few Password_tokens
     * const { count } = await prisma.password_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Password_tokenDeleteManyArgs>(args?: SelectSubset<T, Password_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_tokens
     * const password_token = await prisma.password_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Password_tokenUpdateManyArgs>(args: SelectSubset<T, Password_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_token.
     * @param {Password_tokenUpsertArgs} args - Arguments to update or create a Password_token.
     * @example
     * // Update or create a Password_token
     * const password_token = await prisma.password_token.upsert({
     *   create: {
     *     // ... data to create a Password_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_token we want to update
     *   }
     * })
     */
    upsert<T extends Password_tokenUpsertArgs>(args: SelectSubset<T, Password_tokenUpsertArgs<ExtArgs>>): Prisma__Password_tokenClient<$Result.GetResult<Prisma.$Password_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenCountArgs} args - Arguments to filter Password_tokens to count.
     * @example
     * // Count the number of Password_tokens
     * const count = await prisma.password_token.count({
     *   where: {
     *     // ... the filter for the Password_tokens we want to count
     *   }
     * })
    **/
    count<T extends Password_tokenCountArgs>(
      args?: Subset<T, Password_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_tokenAggregateArgs>(args: Subset<T, Password_tokenAggregateArgs>): Prisma.PrismaPromise<GetPassword_tokenAggregateType<T>>

    /**
     * Group by Password_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Password_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Password_tokenGroupByArgs['orderBy'] }
        : { orderBy?: Password_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Password_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Password_token model
   */
  readonly fields: Password_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Password_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Password_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Password_token model
   */
  interface Password_tokenFieldRefs {
    readonly id: FieldRef<"Password_token", 'String'>
    readonly token: FieldRef<"Password_token", 'String'>
    readonly created_at: FieldRef<"Password_token", 'DateTime'>
    readonly expires_at: FieldRef<"Password_token", 'DateTime'>
    readonly user_id: FieldRef<"Password_token", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Password_token findUnique
   */
  export type Password_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which Password_token to fetch.
     */
    where: Password_tokenWhereUniqueInput
  }

  /**
   * Password_token findUniqueOrThrow
   */
  export type Password_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which Password_token to fetch.
     */
    where: Password_tokenWhereUniqueInput
  }

  /**
   * Password_token findFirst
   */
  export type Password_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which Password_token to fetch.
     */
    where?: Password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_tokens to fetch.
     */
    orderBy?: Password_tokenOrderByWithRelationInput | Password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Password_tokens.
     */
    cursor?: Password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Password_tokens.
     */
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * Password_token findFirstOrThrow
   */
  export type Password_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which Password_token to fetch.
     */
    where?: Password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_tokens to fetch.
     */
    orderBy?: Password_tokenOrderByWithRelationInput | Password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Password_tokens.
     */
    cursor?: Password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Password_tokens.
     */
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * Password_token findMany
   */
  export type Password_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which Password_tokens to fetch.
     */
    where?: Password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Password_tokens to fetch.
     */
    orderBy?: Password_tokenOrderByWithRelationInput | Password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Password_tokens.
     */
    cursor?: Password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Password_tokens.
     */
    skip?: number
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * Password_token create
   */
  export type Password_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Password_token.
     */
    data: XOR<Password_tokenCreateInput, Password_tokenUncheckedCreateInput>
  }

  /**
   * Password_token createMany
   */
  export type Password_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Password_tokens.
     */
    data: Password_tokenCreateManyInput | Password_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Password_token update
   */
  export type Password_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Password_token.
     */
    data: XOR<Password_tokenUpdateInput, Password_tokenUncheckedUpdateInput>
    /**
     * Choose, which Password_token to update.
     */
    where: Password_tokenWhereUniqueInput
  }

  /**
   * Password_token updateMany
   */
  export type Password_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Password_tokens.
     */
    data: XOR<Password_tokenUpdateManyMutationInput, Password_tokenUncheckedUpdateManyInput>
    /**
     * Filter which Password_tokens to update
     */
    where?: Password_tokenWhereInput
    /**
     * Limit how many Password_tokens to update.
     */
    limit?: number
  }

  /**
   * Password_token upsert
   */
  export type Password_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Password_token to update in case it exists.
     */
    where: Password_tokenWhereUniqueInput
    /**
     * In case the Password_token found by the `where` argument doesn't exist, create a new Password_token with this data.
     */
    create: XOR<Password_tokenCreateInput, Password_tokenUncheckedCreateInput>
    /**
     * In case the Password_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Password_tokenUpdateInput, Password_tokenUncheckedUpdateInput>
  }

  /**
   * Password_token delete
   */
  export type Password_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
    /**
     * Filter which Password_token to delete.
     */
    where: Password_tokenWhereUniqueInput
  }

  /**
   * Password_token deleteMany
   */
  export type Password_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Password_tokens to delete
     */
    where?: Password_tokenWhereInput
    /**
     * Limit how many Password_tokens to delete.
     */
    limit?: number
  }

  /**
   * Password_token without action
   */
  export type Password_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Password_token
     */
    select?: Password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Password_token
     */
    omit?: Password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Password_tokenInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    activity: string | null
    completed_at: Date | null
    user_id: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    activity: string | null
    completed_at: Date | null
    user_id: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    activity: number
    completed_at: number
    user_id: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    activity: string
    completed_at: Date | null
    user_id: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity?: boolean
    completed_at?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    activity?: boolean
    completed_at?: boolean
    user_id?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activity" | "completed_at" | "user_id", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activity: string
      completed_at: Date | null
      user_id: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly activity: FieldRef<"Notification", 'String'>
    readonly completed_at: FieldRef<"Notification", 'DateTime'>
    readonly user_id: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Privacy_settings
   */

  export type AggregatePrivacy_settings = {
    _count: Privacy_settingsCountAggregateOutputType | null
    _min: Privacy_settingsMinAggregateOutputType | null
    _max: Privacy_settingsMaxAggregateOutputType | null
  }

  export type Privacy_settingsMinAggregateOutputType = {
    id: string | null
    ads: boolean | null
    data_sharing: boolean | null
    marketing_status: boolean | null
    activity_status: boolean | null
    user_id: string | null
  }

  export type Privacy_settingsMaxAggregateOutputType = {
    id: string | null
    ads: boolean | null
    data_sharing: boolean | null
    marketing_status: boolean | null
    activity_status: boolean | null
    user_id: string | null
  }

  export type Privacy_settingsCountAggregateOutputType = {
    id: number
    ads: number
    data_sharing: number
    marketing_status: number
    activity_status: number
    user_id: number
    _all: number
  }


  export type Privacy_settingsMinAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
  }

  export type Privacy_settingsMaxAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
  }

  export type Privacy_settingsCountAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
    _all?: true
  }

  export type Privacy_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privacy_settings to aggregate.
     */
    where?: Privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privacy_settings to fetch.
     */
    orderBy?: Privacy_settingsOrderByWithRelationInput | Privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Privacy_settings
    **/
    _count?: true | Privacy_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Privacy_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Privacy_settingsMaxAggregateInputType
  }

  export type GetPrivacy_settingsAggregateType<T extends Privacy_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacy_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacy_settings[P]>
      : GetScalarType<T[P], AggregatePrivacy_settings[P]>
  }




  export type Privacy_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Privacy_settingsWhereInput
    orderBy?: Privacy_settingsOrderByWithAggregationInput | Privacy_settingsOrderByWithAggregationInput[]
    by: Privacy_settingsScalarFieldEnum[] | Privacy_settingsScalarFieldEnum
    having?: Privacy_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Privacy_settingsCountAggregateInputType | true
    _min?: Privacy_settingsMinAggregateInputType
    _max?: Privacy_settingsMaxAggregateInputType
  }

  export type Privacy_settingsGroupByOutputType = {
    id: string
    ads: boolean
    data_sharing: boolean
    marketing_status: boolean
    activity_status: boolean
    user_id: string
    _count: Privacy_settingsCountAggregateOutputType | null
    _min: Privacy_settingsMinAggregateOutputType | null
    _max: Privacy_settingsMaxAggregateOutputType | null
  }

  type GetPrivacy_settingsGroupByPayload<T extends Privacy_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Privacy_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Privacy_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Privacy_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Privacy_settingsGroupByOutputType[P]>
        }
      >
    >


  export type Privacy_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privacy_settings"]>



  export type Privacy_settingsSelectScalar = {
    id?: boolean
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id?: boolean
  }

  export type Privacy_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ads" | "data_sharing" | "marketing_status" | "activity_status" | "user_id", ExtArgs["result"]["privacy_settings"]>
  export type Privacy_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $Privacy_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Privacy_settings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ads: boolean
      data_sharing: boolean
      marketing_status: boolean
      activity_status: boolean
      user_id: string
    }, ExtArgs["result"]["privacy_settings"]>
    composites: {}
  }

  type Privacy_settingsGetPayload<S extends boolean | null | undefined | Privacy_settingsDefaultArgs> = $Result.GetResult<Prisma.$Privacy_settingsPayload, S>

  type Privacy_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Privacy_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Privacy_settingsCountAggregateInputType | true
    }

  export interface Privacy_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Privacy_settings'], meta: { name: 'Privacy_settings' } }
    /**
     * Find zero or one Privacy_settings that matches the filter.
     * @param {Privacy_settingsFindUniqueArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Privacy_settingsFindUniqueArgs>(args: SelectSubset<T, Privacy_settingsFindUniqueArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Privacy_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Privacy_settingsFindUniqueOrThrowArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Privacy_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, Privacy_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privacy_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsFindFirstArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Privacy_settingsFindFirstArgs>(args?: SelectSubset<T, Privacy_settingsFindFirstArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privacy_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsFindFirstOrThrowArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Privacy_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, Privacy_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Privacy_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findMany()
     * 
     * // Get first 10 Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacy_settingsWithIdOnly = await prisma.privacy_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Privacy_settingsFindManyArgs>(args?: SelectSubset<T, Privacy_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Privacy_settings.
     * @param {Privacy_settingsCreateArgs} args - Arguments to create a Privacy_settings.
     * @example
     * // Create one Privacy_settings
     * const Privacy_settings = await prisma.privacy_settings.create({
     *   data: {
     *     // ... data to create a Privacy_settings
     *   }
     * })
     * 
     */
    create<T extends Privacy_settingsCreateArgs>(args: SelectSubset<T, Privacy_settingsCreateArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Privacy_settings.
     * @param {Privacy_settingsCreateManyArgs} args - Arguments to create many Privacy_settings.
     * @example
     * // Create many Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Privacy_settingsCreateManyArgs>(args?: SelectSubset<T, Privacy_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Privacy_settings.
     * @param {Privacy_settingsDeleteArgs} args - Arguments to delete one Privacy_settings.
     * @example
     * // Delete one Privacy_settings
     * const Privacy_settings = await prisma.privacy_settings.delete({
     *   where: {
     *     // ... filter to delete one Privacy_settings
     *   }
     * })
     * 
     */
    delete<T extends Privacy_settingsDeleteArgs>(args: SelectSubset<T, Privacy_settingsDeleteArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Privacy_settings.
     * @param {Privacy_settingsUpdateArgs} args - Arguments to update one Privacy_settings.
     * @example
     * // Update one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Privacy_settingsUpdateArgs>(args: SelectSubset<T, Privacy_settingsUpdateArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Privacy_settings.
     * @param {Privacy_settingsDeleteManyArgs} args - Arguments to filter Privacy_settings to delete.
     * @example
     * // Delete a few Privacy_settings
     * const { count } = await prisma.privacy_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Privacy_settingsDeleteManyArgs>(args?: SelectSubset<T, Privacy_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Privacy_settingsUpdateManyArgs>(args: SelectSubset<T, Privacy_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Privacy_settings.
     * @param {Privacy_settingsUpsertArgs} args - Arguments to update or create a Privacy_settings.
     * @example
     * // Update or create a Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.upsert({
     *   create: {
     *     // ... data to create a Privacy_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privacy_settings we want to update
     *   }
     * })
     */
    upsert<T extends Privacy_settingsUpsertArgs>(args: SelectSubset<T, Privacy_settingsUpsertArgs<ExtArgs>>): Prisma__Privacy_settingsClient<$Result.GetResult<Prisma.$Privacy_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsCountArgs} args - Arguments to filter Privacy_settings to count.
     * @example
     * // Count the number of Privacy_settings
     * const count = await prisma.privacy_settings.count({
     *   where: {
     *     // ... the filter for the Privacy_settings we want to count
     *   }
     * })
    **/
    count<T extends Privacy_settingsCountArgs>(
      args?: Subset<T, Privacy_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Privacy_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Privacy_settingsAggregateArgs>(args: Subset<T, Privacy_settingsAggregateArgs>): Prisma.PrismaPromise<GetPrivacy_settingsAggregateType<T>>

    /**
     * Group by Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Privacy_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Privacy_settingsGroupByArgs['orderBy'] }
        : { orderBy?: Privacy_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Privacy_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacy_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Privacy_settings model
   */
  readonly fields: Privacy_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Privacy_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Privacy_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Privacy_settings model
   */
  interface Privacy_settingsFieldRefs {
    readonly id: FieldRef<"Privacy_settings", 'String'>
    readonly ads: FieldRef<"Privacy_settings", 'Boolean'>
    readonly data_sharing: FieldRef<"Privacy_settings", 'Boolean'>
    readonly marketing_status: FieldRef<"Privacy_settings", 'Boolean'>
    readonly activity_status: FieldRef<"Privacy_settings", 'Boolean'>
    readonly user_id: FieldRef<"Privacy_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Privacy_settings findUnique
   */
  export type Privacy_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Privacy_settings to fetch.
     */
    where: Privacy_settingsWhereUniqueInput
  }

  /**
   * Privacy_settings findUniqueOrThrow
   */
  export type Privacy_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Privacy_settings to fetch.
     */
    where: Privacy_settingsWhereUniqueInput
  }

  /**
   * Privacy_settings findFirst
   */
  export type Privacy_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Privacy_settings to fetch.
     */
    where?: Privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privacy_settings to fetch.
     */
    orderBy?: Privacy_settingsOrderByWithRelationInput | Privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privacy_settings.
     */
    cursor?: Privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privacy_settings.
     */
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * Privacy_settings findFirstOrThrow
   */
  export type Privacy_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Privacy_settings to fetch.
     */
    where?: Privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privacy_settings to fetch.
     */
    orderBy?: Privacy_settingsOrderByWithRelationInput | Privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privacy_settings.
     */
    cursor?: Privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privacy_settings.
     */
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * Privacy_settings findMany
   */
  export type Privacy_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Privacy_settings to fetch.
     */
    where?: Privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privacy_settings to fetch.
     */
    orderBy?: Privacy_settingsOrderByWithRelationInput | Privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Privacy_settings.
     */
    cursor?: Privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privacy_settings.
     */
    skip?: number
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * Privacy_settings create
   */
  export type Privacy_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Privacy_settings.
     */
    data: XOR<Privacy_settingsCreateInput, Privacy_settingsUncheckedCreateInput>
  }

  /**
   * Privacy_settings createMany
   */
  export type Privacy_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Privacy_settings.
     */
    data: Privacy_settingsCreateManyInput | Privacy_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Privacy_settings update
   */
  export type Privacy_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Privacy_settings.
     */
    data: XOR<Privacy_settingsUpdateInput, Privacy_settingsUncheckedUpdateInput>
    /**
     * Choose, which Privacy_settings to update.
     */
    where: Privacy_settingsWhereUniqueInput
  }

  /**
   * Privacy_settings updateMany
   */
  export type Privacy_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Privacy_settings.
     */
    data: XOR<Privacy_settingsUpdateManyMutationInput, Privacy_settingsUncheckedUpdateManyInput>
    /**
     * Filter which Privacy_settings to update
     */
    where?: Privacy_settingsWhereInput
    /**
     * Limit how many Privacy_settings to update.
     */
    limit?: number
  }

  /**
   * Privacy_settings upsert
   */
  export type Privacy_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Privacy_settings to update in case it exists.
     */
    where: Privacy_settingsWhereUniqueInput
    /**
     * In case the Privacy_settings found by the `where` argument doesn't exist, create a new Privacy_settings with this data.
     */
    create: XOR<Privacy_settingsCreateInput, Privacy_settingsUncheckedCreateInput>
    /**
     * In case the Privacy_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Privacy_settingsUpdateInput, Privacy_settingsUncheckedUpdateInput>
  }

  /**
   * Privacy_settings delete
   */
  export type Privacy_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter which Privacy_settings to delete.
     */
    where: Privacy_settingsWhereUniqueInput
  }

  /**
   * Privacy_settings deleteMany
   */
  export type Privacy_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privacy_settings to delete
     */
    where?: Privacy_settingsWhereInput
    /**
     * Limit how many Privacy_settings to delete.
     */
    limit?: number
  }

  /**
   * Privacy_settings without action
   */
  export type Privacy_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privacy_settings
     */
    select?: Privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privacy_settings
     */
    omit?: Privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Privacy_settingsInclude<ExtArgs> | null
  }


  /**
   * Model Notification_settings
   */

  export type AggregateNotification_settings = {
    _count: Notification_settingsCountAggregateOutputType | null
    _min: Notification_settingsMinAggregateOutputType | null
    _max: Notification_settingsMaxAggregateOutputType | null
  }

  export type Notification_settingsMinAggregateOutputType = {
    id: string | null
    alerts: boolean | null
    messages: boolean | null
    updates: boolean | null
    billing_alerts: boolean | null
    email: boolean | null
    in_app: boolean | null
    user_id: string | null
  }

  export type Notification_settingsMaxAggregateOutputType = {
    id: string | null
    alerts: boolean | null
    messages: boolean | null
    updates: boolean | null
    billing_alerts: boolean | null
    email: boolean | null
    in_app: boolean | null
    user_id: string | null
  }

  export type Notification_settingsCountAggregateOutputType = {
    id: number
    alerts: number
    messages: number
    updates: number
    billing_alerts: number
    email: number
    in_app: number
    user_id: number
    _all: number
  }


  export type Notification_settingsMinAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
  }

  export type Notification_settingsMaxAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
  }

  export type Notification_settingsCountAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
    _all?: true
  }

  export type Notification_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification_settings to aggregate.
     */
    where?: Notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notification_settings to fetch.
     */
    orderBy?: Notification_settingsOrderByWithRelationInput | Notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notification_settings
    **/
    _count?: true | Notification_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_settingsMaxAggregateInputType
  }

  export type GetNotification_settingsAggregateType<T extends Notification_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_settings[P]>
      : GetScalarType<T[P], AggregateNotification_settings[P]>
  }




  export type Notification_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Notification_settingsWhereInput
    orderBy?: Notification_settingsOrderByWithAggregationInput | Notification_settingsOrderByWithAggregationInput[]
    by: Notification_settingsScalarFieldEnum[] | Notification_settingsScalarFieldEnum
    having?: Notification_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_settingsCountAggregateInputType | true
    _min?: Notification_settingsMinAggregateInputType
    _max?: Notification_settingsMaxAggregateInputType
  }

  export type Notification_settingsGroupByOutputType = {
    id: string
    alerts: boolean
    messages: boolean
    updates: boolean
    billing_alerts: boolean
    email: boolean
    in_app: boolean
    user_id: string
    _count: Notification_settingsCountAggregateOutputType | null
    _min: Notification_settingsMinAggregateOutputType | null
    _max: Notification_settingsMaxAggregateOutputType | null
  }

  type GetNotification_settingsGroupByPayload<T extends Notification_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_settingsGroupByOutputType[P]>
        }
      >
    >


  export type Notification_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_settings"]>



  export type Notification_settingsSelectScalar = {
    id?: boolean
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id?: boolean
  }

  export type Notification_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alerts" | "messages" | "updates" | "billing_alerts" | "email" | "in_app" | "user_id", ExtArgs["result"]["notification_settings"]>
  export type Notification_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $Notification_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification_settings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alerts: boolean
      messages: boolean
      updates: boolean
      billing_alerts: boolean
      email: boolean
      in_app: boolean
      user_id: string
    }, ExtArgs["result"]["notification_settings"]>
    composites: {}
  }

  type Notification_settingsGetPayload<S extends boolean | null | undefined | Notification_settingsDefaultArgs> = $Result.GetResult<Prisma.$Notification_settingsPayload, S>

  type Notification_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Notification_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_settingsCountAggregateInputType | true
    }

  export interface Notification_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification_settings'], meta: { name: 'Notification_settings' } }
    /**
     * Find zero or one Notification_settings that matches the filter.
     * @param {Notification_settingsFindUniqueArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Notification_settingsFindUniqueArgs>(args: SelectSubset<T, Notification_settingsFindUniqueArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Notification_settingsFindUniqueOrThrowArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Notification_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, Notification_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsFindFirstArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Notification_settingsFindFirstArgs>(args?: SelectSubset<T, Notification_settingsFindFirstArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsFindFirstOrThrowArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Notification_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, Notification_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_settings
     * const notification_settings = await prisma.notification_settings.findMany()
     * 
     * // Get first 10 Notification_settings
     * const notification_settings = await prisma.notification_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_settingsWithIdOnly = await prisma.notification_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Notification_settingsFindManyArgs>(args?: SelectSubset<T, Notification_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_settings.
     * @param {Notification_settingsCreateArgs} args - Arguments to create a Notification_settings.
     * @example
     * // Create one Notification_settings
     * const Notification_settings = await prisma.notification_settings.create({
     *   data: {
     *     // ... data to create a Notification_settings
     *   }
     * })
     * 
     */
    create<T extends Notification_settingsCreateArgs>(args: SelectSubset<T, Notification_settingsCreateArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_settings.
     * @param {Notification_settingsCreateManyArgs} args - Arguments to create many Notification_settings.
     * @example
     * // Create many Notification_settings
     * const notification_settings = await prisma.notification_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Notification_settingsCreateManyArgs>(args?: SelectSubset<T, Notification_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification_settings.
     * @param {Notification_settingsDeleteArgs} args - Arguments to delete one Notification_settings.
     * @example
     * // Delete one Notification_settings
     * const Notification_settings = await prisma.notification_settings.delete({
     *   where: {
     *     // ... filter to delete one Notification_settings
     *   }
     * })
     * 
     */
    delete<T extends Notification_settingsDeleteArgs>(args: SelectSubset<T, Notification_settingsDeleteArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_settings.
     * @param {Notification_settingsUpdateArgs} args - Arguments to update one Notification_settings.
     * @example
     * // Update one Notification_settings
     * const notification_settings = await prisma.notification_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Notification_settingsUpdateArgs>(args: SelectSubset<T, Notification_settingsUpdateArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_settings.
     * @param {Notification_settingsDeleteManyArgs} args - Arguments to filter Notification_settings to delete.
     * @example
     * // Delete a few Notification_settings
     * const { count } = await prisma.notification_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Notification_settingsDeleteManyArgs>(args?: SelectSubset<T, Notification_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_settings
     * const notification_settings = await prisma.notification_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Notification_settingsUpdateManyArgs>(args: SelectSubset<T, Notification_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification_settings.
     * @param {Notification_settingsUpsertArgs} args - Arguments to update or create a Notification_settings.
     * @example
     * // Update or create a Notification_settings
     * const notification_settings = await prisma.notification_settings.upsert({
     *   create: {
     *     // ... data to create a Notification_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_settings we want to update
     *   }
     * })
     */
    upsert<T extends Notification_settingsUpsertArgs>(args: SelectSubset<T, Notification_settingsUpsertArgs<ExtArgs>>): Prisma__Notification_settingsClient<$Result.GetResult<Prisma.$Notification_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsCountArgs} args - Arguments to filter Notification_settings to count.
     * @example
     * // Count the number of Notification_settings
     * const count = await prisma.notification_settings.count({
     *   where: {
     *     // ... the filter for the Notification_settings we want to count
     *   }
     * })
    **/
    count<T extends Notification_settingsCountArgs>(
      args?: Subset<T, Notification_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_settingsAggregateArgs>(args: Subset<T, Notification_settingsAggregateArgs>): Prisma.PrismaPromise<GetNotification_settingsAggregateType<T>>

    /**
     * Group by Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Notification_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Notification_settingsGroupByArgs['orderBy'] }
        : { orderBy?: Notification_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Notification_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification_settings model
   */
  readonly fields: Notification_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Notification_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification_settings model
   */
  interface Notification_settingsFieldRefs {
    readonly id: FieldRef<"Notification_settings", 'String'>
    readonly alerts: FieldRef<"Notification_settings", 'Boolean'>
    readonly messages: FieldRef<"Notification_settings", 'Boolean'>
    readonly updates: FieldRef<"Notification_settings", 'Boolean'>
    readonly billing_alerts: FieldRef<"Notification_settings", 'Boolean'>
    readonly email: FieldRef<"Notification_settings", 'Boolean'>
    readonly in_app: FieldRef<"Notification_settings", 'Boolean'>
    readonly user_id: FieldRef<"Notification_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification_settings findUnique
   */
  export type Notification_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Notification_settings to fetch.
     */
    where: Notification_settingsWhereUniqueInput
  }

  /**
   * Notification_settings findUniqueOrThrow
   */
  export type Notification_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Notification_settings to fetch.
     */
    where: Notification_settingsWhereUniqueInput
  }

  /**
   * Notification_settings findFirst
   */
  export type Notification_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Notification_settings to fetch.
     */
    where?: Notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notification_settings to fetch.
     */
    orderBy?: Notification_settingsOrderByWithRelationInput | Notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notification_settings.
     */
    cursor?: Notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notification_settings.
     */
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * Notification_settings findFirstOrThrow
   */
  export type Notification_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Notification_settings to fetch.
     */
    where?: Notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notification_settings to fetch.
     */
    orderBy?: Notification_settingsOrderByWithRelationInput | Notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notification_settings.
     */
    cursor?: Notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notification_settings.
     */
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * Notification_settings findMany
   */
  export type Notification_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which Notification_settings to fetch.
     */
    where?: Notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notification_settings to fetch.
     */
    orderBy?: Notification_settingsOrderByWithRelationInput | Notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notification_settings.
     */
    cursor?: Notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notification_settings.
     */
    skip?: number
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * Notification_settings create
   */
  export type Notification_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification_settings.
     */
    data: XOR<Notification_settingsCreateInput, Notification_settingsUncheckedCreateInput>
  }

  /**
   * Notification_settings createMany
   */
  export type Notification_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notification_settings.
     */
    data: Notification_settingsCreateManyInput | Notification_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification_settings update
   */
  export type Notification_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification_settings.
     */
    data: XOR<Notification_settingsUpdateInput, Notification_settingsUncheckedUpdateInput>
    /**
     * Choose, which Notification_settings to update.
     */
    where: Notification_settingsWhereUniqueInput
  }

  /**
   * Notification_settings updateMany
   */
  export type Notification_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notification_settings.
     */
    data: XOR<Notification_settingsUpdateManyMutationInput, Notification_settingsUncheckedUpdateManyInput>
    /**
     * Filter which Notification_settings to update
     */
    where?: Notification_settingsWhereInput
    /**
     * Limit how many Notification_settings to update.
     */
    limit?: number
  }

  /**
   * Notification_settings upsert
   */
  export type Notification_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification_settings to update in case it exists.
     */
    where: Notification_settingsWhereUniqueInput
    /**
     * In case the Notification_settings found by the `where` argument doesn't exist, create a new Notification_settings with this data.
     */
    create: XOR<Notification_settingsCreateInput, Notification_settingsUncheckedCreateInput>
    /**
     * In case the Notification_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Notification_settingsUpdateInput, Notification_settingsUncheckedUpdateInput>
  }

  /**
   * Notification_settings delete
   */
  export type Notification_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
    /**
     * Filter which Notification_settings to delete.
     */
    where: Notification_settingsWhereUniqueInput
  }

  /**
   * Notification_settings deleteMany
   */
  export type Notification_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification_settings to delete
     */
    where?: Notification_settingsWhereInput
    /**
     * Limit how many Notification_settings to delete.
     */
    limit?: number
  }

  /**
   * Notification_settings without action
   */
  export type Notification_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification_settings
     */
    select?: Notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification_settings
     */
    omit?: Notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Notification_settingsInclude<ExtArgs> | null
  }


  /**
   * Model Plan_type
   */

  export type AggregatePlan_type = {
    _count: Plan_typeCountAggregateOutputType | null
    _min: Plan_typeMinAggregateOutputType | null
    _max: Plan_typeMaxAggregateOutputType | null
  }

  export type Plan_typeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type Plan_typeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type Plan_typeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    created_by: number
    deleted_at: number
    _all: number
  }


  export type Plan_typeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type Plan_typeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type Plan_typeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Plan_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan_type to aggregate.
     */
    where?: Plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plan_types to fetch.
     */
    orderBy?: Plan_typeOrderByWithRelationInput | Plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plan_types
    **/
    _count?: true | Plan_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_typeMaxAggregateInputType
  }

  export type GetPlan_typeAggregateType<T extends Plan_typeAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_type[P]>
      : GetScalarType<T[P], AggregatePlan_type[P]>
  }




  export type Plan_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Plan_typeWhereInput
    orderBy?: Plan_typeOrderByWithAggregationInput | Plan_typeOrderByWithAggregationInput[]
    by: Plan_typeScalarFieldEnum[] | Plan_typeScalarFieldEnum
    having?: Plan_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_typeCountAggregateInputType | true
    _min?: Plan_typeMinAggregateInputType
    _max?: Plan_typeMaxAggregateInputType
  }

  export type Plan_typeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    created_by: string
    deleted_at: Date | null
    _count: Plan_typeCountAggregateOutputType | null
    _min: Plan_typeMinAggregateOutputType | null
    _max: Plan_typeMaxAggregateOutputType | null
  }

  type GetPlan_typeGroupByPayload<T extends Plan_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_typeGroupByOutputType[P]>
        }
      >
    >


  export type Plan_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plans?: boolean | Plan_type$plansArgs<ExtArgs>
    _count?: boolean | Plan_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_type"]>



  export type Plan_typeSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
  }

  export type Plan_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "created_by" | "deleted_at", ExtArgs["result"]["plan_type"]>
  export type Plan_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plans?: boolean | Plan_type$plansArgs<ExtArgs>
    _count?: boolean | Plan_typeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Plan_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan_type"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plans: Prisma.$PlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      created_by: string
      deleted_at: Date | null
    }, ExtArgs["result"]["plan_type"]>
    composites: {}
  }

  type Plan_typeGetPayload<S extends boolean | null | undefined | Plan_typeDefaultArgs> = $Result.GetResult<Prisma.$Plan_typePayload, S>

  type Plan_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Plan_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_typeCountAggregateInputType | true
    }

  export interface Plan_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan_type'], meta: { name: 'Plan_type' } }
    /**
     * Find zero or one Plan_type that matches the filter.
     * @param {Plan_typeFindUniqueArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Plan_typeFindUniqueArgs>(args: SelectSubset<T, Plan_typeFindUniqueArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Plan_typeFindUniqueOrThrowArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Plan_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, Plan_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeFindFirstArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Plan_typeFindFirstArgs>(args?: SelectSubset<T, Plan_typeFindFirstArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeFindFirstOrThrowArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Plan_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, Plan_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_types
     * const plan_types = await prisma.plan_type.findMany()
     * 
     * // Get first 10 Plan_types
     * const plan_types = await prisma.plan_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_typeWithIdOnly = await prisma.plan_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Plan_typeFindManyArgs>(args?: SelectSubset<T, Plan_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_type.
     * @param {Plan_typeCreateArgs} args - Arguments to create a Plan_type.
     * @example
     * // Create one Plan_type
     * const Plan_type = await prisma.plan_type.create({
     *   data: {
     *     // ... data to create a Plan_type
     *   }
     * })
     * 
     */
    create<T extends Plan_typeCreateArgs>(args: SelectSubset<T, Plan_typeCreateArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_types.
     * @param {Plan_typeCreateManyArgs} args - Arguments to create many Plan_types.
     * @example
     * // Create many Plan_types
     * const plan_type = await prisma.plan_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Plan_typeCreateManyArgs>(args?: SelectSubset<T, Plan_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_type.
     * @param {Plan_typeDeleteArgs} args - Arguments to delete one Plan_type.
     * @example
     * // Delete one Plan_type
     * const Plan_type = await prisma.plan_type.delete({
     *   where: {
     *     // ... filter to delete one Plan_type
     *   }
     * })
     * 
     */
    delete<T extends Plan_typeDeleteArgs>(args: SelectSubset<T, Plan_typeDeleteArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_type.
     * @param {Plan_typeUpdateArgs} args - Arguments to update one Plan_type.
     * @example
     * // Update one Plan_type
     * const plan_type = await prisma.plan_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Plan_typeUpdateArgs>(args: SelectSubset<T, Plan_typeUpdateArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_types.
     * @param {Plan_typeDeleteManyArgs} args - Arguments to filter Plan_types to delete.
     * @example
     * // Delete a few Plan_types
     * const { count } = await prisma.plan_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Plan_typeDeleteManyArgs>(args?: SelectSubset<T, Plan_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_types
     * const plan_type = await prisma.plan_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Plan_typeUpdateManyArgs>(args: SelectSubset<T, Plan_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_type.
     * @param {Plan_typeUpsertArgs} args - Arguments to update or create a Plan_type.
     * @example
     * // Update or create a Plan_type
     * const plan_type = await prisma.plan_type.upsert({
     *   create: {
     *     // ... data to create a Plan_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_type we want to update
     *   }
     * })
     */
    upsert<T extends Plan_typeUpsertArgs>(args: SelectSubset<T, Plan_typeUpsertArgs<ExtArgs>>): Prisma__Plan_typeClient<$Result.GetResult<Prisma.$Plan_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeCountArgs} args - Arguments to filter Plan_types to count.
     * @example
     * // Count the number of Plan_types
     * const count = await prisma.plan_type.count({
     *   where: {
     *     // ... the filter for the Plan_types we want to count
     *   }
     * })
    **/
    count<T extends Plan_typeCountArgs>(
      args?: Subset<T, Plan_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_typeAggregateArgs>(args: Subset<T, Plan_typeAggregateArgs>): Prisma.PrismaPromise<GetPlan_typeAggregateType<T>>

    /**
     * Group by Plan_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plan_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plan_typeGroupByArgs['orderBy'] }
        : { orderBy?: Plan_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plan_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan_type model
   */
  readonly fields: Plan_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Plan_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plans<T extends Plan_type$plansArgs<ExtArgs> = {}>(args?: Subset<T, Plan_type$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan_type model
   */
  interface Plan_typeFieldRefs {
    readonly id: FieldRef<"Plan_type", 'String'>
    readonly name: FieldRef<"Plan_type", 'String'>
    readonly created_at: FieldRef<"Plan_type", 'DateTime'>
    readonly created_by: FieldRef<"Plan_type", 'String'>
    readonly deleted_at: FieldRef<"Plan_type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan_type findUnique
   */
  export type Plan_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which Plan_type to fetch.
     */
    where: Plan_typeWhereUniqueInput
  }

  /**
   * Plan_type findUniqueOrThrow
   */
  export type Plan_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which Plan_type to fetch.
     */
    where: Plan_typeWhereUniqueInput
  }

  /**
   * Plan_type findFirst
   */
  export type Plan_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which Plan_type to fetch.
     */
    where?: Plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plan_types to fetch.
     */
    orderBy?: Plan_typeOrderByWithRelationInput | Plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plan_types.
     */
    cursor?: Plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plan_types.
     */
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * Plan_type findFirstOrThrow
   */
  export type Plan_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which Plan_type to fetch.
     */
    where?: Plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plan_types to fetch.
     */
    orderBy?: Plan_typeOrderByWithRelationInput | Plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plan_types.
     */
    cursor?: Plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plan_types.
     */
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * Plan_type findMany
   */
  export type Plan_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which Plan_types to fetch.
     */
    where?: Plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plan_types to fetch.
     */
    orderBy?: Plan_typeOrderByWithRelationInput | Plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plan_types.
     */
    cursor?: Plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plan_types.
     */
    skip?: number
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * Plan_type create
   */
  export type Plan_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan_type.
     */
    data: XOR<Plan_typeCreateInput, Plan_typeUncheckedCreateInput>
  }

  /**
   * Plan_type createMany
   */
  export type Plan_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plan_types.
     */
    data: Plan_typeCreateManyInput | Plan_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan_type update
   */
  export type Plan_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan_type.
     */
    data: XOR<Plan_typeUpdateInput, Plan_typeUncheckedUpdateInput>
    /**
     * Choose, which Plan_type to update.
     */
    where: Plan_typeWhereUniqueInput
  }

  /**
   * Plan_type updateMany
   */
  export type Plan_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plan_types.
     */
    data: XOR<Plan_typeUpdateManyMutationInput, Plan_typeUncheckedUpdateManyInput>
    /**
     * Filter which Plan_types to update
     */
    where?: Plan_typeWhereInput
    /**
     * Limit how many Plan_types to update.
     */
    limit?: number
  }

  /**
   * Plan_type upsert
   */
  export type Plan_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan_type to update in case it exists.
     */
    where: Plan_typeWhereUniqueInput
    /**
     * In case the Plan_type found by the `where` argument doesn't exist, create a new Plan_type with this data.
     */
    create: XOR<Plan_typeCreateInput, Plan_typeUncheckedCreateInput>
    /**
     * In case the Plan_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Plan_typeUpdateInput, Plan_typeUncheckedUpdateInput>
  }

  /**
   * Plan_type delete
   */
  export type Plan_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
    /**
     * Filter which Plan_type to delete.
     */
    where: Plan_typeWhereUniqueInput
  }

  /**
   * Plan_type deleteMany
   */
  export type Plan_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan_types to delete
     */
    where?: Plan_typeWhereInput
    /**
     * Limit how many Plan_types to delete.
     */
    limit?: number
  }

  /**
   * Plan_type.plans
   */
  export type Plan_type$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan_type without action
   */
  export type Plan_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_type
     */
    select?: Plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan_type
     */
    omit?: Plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Plan_typeInclude<ExtArgs> | null
  }


  /**
   * Model Billing_cycle
   */

  export type AggregateBilling_cycle = {
    _count: Billing_cycleCountAggregateOutputType | null
    _avg: Billing_cycleAvgAggregateOutputType | null
    _sum: Billing_cycleSumAggregateOutputType | null
    _min: Billing_cycleMinAggregateOutputType | null
    _max: Billing_cycleMaxAggregateOutputType | null
  }

  export type Billing_cycleAvgAggregateOutputType = {
    duration_in_days: number | null
  }

  export type Billing_cycleSumAggregateOutputType = {
    duration_in_days: number | null
  }

  export type Billing_cycleMinAggregateOutputType = {
    id: string | null
    name: string | null
    duration_in_days: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type Billing_cycleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    duration_in_days: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type Billing_cycleCountAggregateOutputType = {
    id: number
    name: number
    duration_in_days: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type Billing_cycleAvgAggregateInputType = {
    duration_in_days?: true
  }

  export type Billing_cycleSumAggregateInputType = {
    duration_in_days?: true
  }

  export type Billing_cycleMinAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
  }

  export type Billing_cycleMaxAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
  }

  export type Billing_cycleCountAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Billing_cycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billing_cycle to aggregate.
     */
    where?: Billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billing_cycles to fetch.
     */
    orderBy?: Billing_cycleOrderByWithRelationInput | Billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billing_cycles
    **/
    _count?: true | Billing_cycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Billing_cycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Billing_cycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Billing_cycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Billing_cycleMaxAggregateInputType
  }

  export type GetBilling_cycleAggregateType<T extends Billing_cycleAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling_cycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling_cycle[P]>
      : GetScalarType<T[P], AggregateBilling_cycle[P]>
  }




  export type Billing_cycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Billing_cycleWhereInput
    orderBy?: Billing_cycleOrderByWithAggregationInput | Billing_cycleOrderByWithAggregationInput[]
    by: Billing_cycleScalarFieldEnum[] | Billing_cycleScalarFieldEnum
    having?: Billing_cycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Billing_cycleCountAggregateInputType | true
    _avg?: Billing_cycleAvgAggregateInputType
    _sum?: Billing_cycleSumAggregateInputType
    _min?: Billing_cycleMinAggregateInputType
    _max?: Billing_cycleMaxAggregateInputType
  }

  export type Billing_cycleGroupByOutputType = {
    id: string
    name: string
    duration_in_days: number
    created_at: Date
    deleted_at: Date | null
    _count: Billing_cycleCountAggregateOutputType | null
    _avg: Billing_cycleAvgAggregateOutputType | null
    _sum: Billing_cycleSumAggregateOutputType | null
    _min: Billing_cycleMinAggregateOutputType | null
    _max: Billing_cycleMaxAggregateOutputType | null
  }

  type GetBilling_cycleGroupByPayload<T extends Billing_cycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Billing_cycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Billing_cycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Billing_cycleGroupByOutputType[P]>
            : GetScalarType<T[P], Billing_cycleGroupByOutputType[P]>
        }
      >
    >


  export type Billing_cycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    duration_in_days?: boolean
    created_at?: boolean
    deleted_at?: boolean
    plans?: boolean | Billing_cycle$plansArgs<ExtArgs>
    _count?: boolean | Billing_cycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billing_cycle"]>



  export type Billing_cycleSelectScalar = {
    id?: boolean
    name?: boolean
    duration_in_days?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type Billing_cycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "duration_in_days" | "created_at" | "deleted_at", ExtArgs["result"]["billing_cycle"]>
  export type Billing_cycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plans?: boolean | Billing_cycle$plansArgs<ExtArgs>
    _count?: boolean | Billing_cycleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Billing_cyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Billing_cycle"
    objects: {
      plans: Prisma.$PlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      duration_in_days: number
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["billing_cycle"]>
    composites: {}
  }

  type Billing_cycleGetPayload<S extends boolean | null | undefined | Billing_cycleDefaultArgs> = $Result.GetResult<Prisma.$Billing_cyclePayload, S>

  type Billing_cycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Billing_cycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Billing_cycleCountAggregateInputType | true
    }

  export interface Billing_cycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Billing_cycle'], meta: { name: 'Billing_cycle' } }
    /**
     * Find zero or one Billing_cycle that matches the filter.
     * @param {Billing_cycleFindUniqueArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Billing_cycleFindUniqueArgs>(args: SelectSubset<T, Billing_cycleFindUniqueArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Billing_cycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Billing_cycleFindUniqueOrThrowArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Billing_cycleFindUniqueOrThrowArgs>(args: SelectSubset<T, Billing_cycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing_cycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleFindFirstArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Billing_cycleFindFirstArgs>(args?: SelectSubset<T, Billing_cycleFindFirstArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing_cycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleFindFirstOrThrowArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Billing_cycleFindFirstOrThrowArgs>(args?: SelectSubset<T, Billing_cycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Billing_cycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billing_cycles
     * const billing_cycles = await prisma.billing_cycle.findMany()
     * 
     * // Get first 10 Billing_cycles
     * const billing_cycles = await prisma.billing_cycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billing_cycleWithIdOnly = await prisma.billing_cycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Billing_cycleFindManyArgs>(args?: SelectSubset<T, Billing_cycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Billing_cycle.
     * @param {Billing_cycleCreateArgs} args - Arguments to create a Billing_cycle.
     * @example
     * // Create one Billing_cycle
     * const Billing_cycle = await prisma.billing_cycle.create({
     *   data: {
     *     // ... data to create a Billing_cycle
     *   }
     * })
     * 
     */
    create<T extends Billing_cycleCreateArgs>(args: SelectSubset<T, Billing_cycleCreateArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Billing_cycles.
     * @param {Billing_cycleCreateManyArgs} args - Arguments to create many Billing_cycles.
     * @example
     * // Create many Billing_cycles
     * const billing_cycle = await prisma.billing_cycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Billing_cycleCreateManyArgs>(args?: SelectSubset<T, Billing_cycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billing_cycle.
     * @param {Billing_cycleDeleteArgs} args - Arguments to delete one Billing_cycle.
     * @example
     * // Delete one Billing_cycle
     * const Billing_cycle = await prisma.billing_cycle.delete({
     *   where: {
     *     // ... filter to delete one Billing_cycle
     *   }
     * })
     * 
     */
    delete<T extends Billing_cycleDeleteArgs>(args: SelectSubset<T, Billing_cycleDeleteArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Billing_cycle.
     * @param {Billing_cycleUpdateArgs} args - Arguments to update one Billing_cycle.
     * @example
     * // Update one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Billing_cycleUpdateArgs>(args: SelectSubset<T, Billing_cycleUpdateArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Billing_cycles.
     * @param {Billing_cycleDeleteManyArgs} args - Arguments to filter Billing_cycles to delete.
     * @example
     * // Delete a few Billing_cycles
     * const { count } = await prisma.billing_cycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Billing_cycleDeleteManyArgs>(args?: SelectSubset<T, Billing_cycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billing_cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billing_cycles
     * const billing_cycle = await prisma.billing_cycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Billing_cycleUpdateManyArgs>(args: SelectSubset<T, Billing_cycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing_cycle.
     * @param {Billing_cycleUpsertArgs} args - Arguments to update or create a Billing_cycle.
     * @example
     * // Update or create a Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.upsert({
     *   create: {
     *     // ... data to create a Billing_cycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing_cycle we want to update
     *   }
     * })
     */
    upsert<T extends Billing_cycleUpsertArgs>(args: SelectSubset<T, Billing_cycleUpsertArgs<ExtArgs>>): Prisma__Billing_cycleClient<$Result.GetResult<Prisma.$Billing_cyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Billing_cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleCountArgs} args - Arguments to filter Billing_cycles to count.
     * @example
     * // Count the number of Billing_cycles
     * const count = await prisma.billing_cycle.count({
     *   where: {
     *     // ... the filter for the Billing_cycles we want to count
     *   }
     * })
    **/
    count<T extends Billing_cycleCountArgs>(
      args?: Subset<T, Billing_cycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Billing_cycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing_cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Billing_cycleAggregateArgs>(args: Subset<T, Billing_cycleAggregateArgs>): Prisma.PrismaPromise<GetBilling_cycleAggregateType<T>>

    /**
     * Group by Billing_cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Billing_cycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Billing_cycleGroupByArgs['orderBy'] }
        : { orderBy?: Billing_cycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Billing_cycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilling_cycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Billing_cycle model
   */
  readonly fields: Billing_cycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Billing_cycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Billing_cycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plans<T extends Billing_cycle$plansArgs<ExtArgs> = {}>(args?: Subset<T, Billing_cycle$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Billing_cycle model
   */
  interface Billing_cycleFieldRefs {
    readonly id: FieldRef<"Billing_cycle", 'String'>
    readonly name: FieldRef<"Billing_cycle", 'String'>
    readonly duration_in_days: FieldRef<"Billing_cycle", 'Int'>
    readonly created_at: FieldRef<"Billing_cycle", 'DateTime'>
    readonly deleted_at: FieldRef<"Billing_cycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Billing_cycle findUnique
   */
  export type Billing_cycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which Billing_cycle to fetch.
     */
    where: Billing_cycleWhereUniqueInput
  }

  /**
   * Billing_cycle findUniqueOrThrow
   */
  export type Billing_cycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which Billing_cycle to fetch.
     */
    where: Billing_cycleWhereUniqueInput
  }

  /**
   * Billing_cycle findFirst
   */
  export type Billing_cycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which Billing_cycle to fetch.
     */
    where?: Billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billing_cycles to fetch.
     */
    orderBy?: Billing_cycleOrderByWithRelationInput | Billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billing_cycles.
     */
    cursor?: Billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billing_cycles.
     */
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * Billing_cycle findFirstOrThrow
   */
  export type Billing_cycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which Billing_cycle to fetch.
     */
    where?: Billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billing_cycles to fetch.
     */
    orderBy?: Billing_cycleOrderByWithRelationInput | Billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billing_cycles.
     */
    cursor?: Billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billing_cycles.
     */
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * Billing_cycle findMany
   */
  export type Billing_cycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which Billing_cycles to fetch.
     */
    where?: Billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billing_cycles to fetch.
     */
    orderBy?: Billing_cycleOrderByWithRelationInput | Billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billing_cycles.
     */
    cursor?: Billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billing_cycles.
     */
    skip?: number
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * Billing_cycle create
   */
  export type Billing_cycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * The data needed to create a Billing_cycle.
     */
    data: XOR<Billing_cycleCreateInput, Billing_cycleUncheckedCreateInput>
  }

  /**
   * Billing_cycle createMany
   */
  export type Billing_cycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Billing_cycles.
     */
    data: Billing_cycleCreateManyInput | Billing_cycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Billing_cycle update
   */
  export type Billing_cycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * The data needed to update a Billing_cycle.
     */
    data: XOR<Billing_cycleUpdateInput, Billing_cycleUncheckedUpdateInput>
    /**
     * Choose, which Billing_cycle to update.
     */
    where: Billing_cycleWhereUniqueInput
  }

  /**
   * Billing_cycle updateMany
   */
  export type Billing_cycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Billing_cycles.
     */
    data: XOR<Billing_cycleUpdateManyMutationInput, Billing_cycleUncheckedUpdateManyInput>
    /**
     * Filter which Billing_cycles to update
     */
    where?: Billing_cycleWhereInput
    /**
     * Limit how many Billing_cycles to update.
     */
    limit?: number
  }

  /**
   * Billing_cycle upsert
   */
  export type Billing_cycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * The filter to search for the Billing_cycle to update in case it exists.
     */
    where: Billing_cycleWhereUniqueInput
    /**
     * In case the Billing_cycle found by the `where` argument doesn't exist, create a new Billing_cycle with this data.
     */
    create: XOR<Billing_cycleCreateInput, Billing_cycleUncheckedCreateInput>
    /**
     * In case the Billing_cycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Billing_cycleUpdateInput, Billing_cycleUncheckedUpdateInput>
  }

  /**
   * Billing_cycle delete
   */
  export type Billing_cycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
    /**
     * Filter which Billing_cycle to delete.
     */
    where: Billing_cycleWhereUniqueInput
  }

  /**
   * Billing_cycle deleteMany
   */
  export type Billing_cycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billing_cycles to delete
     */
    where?: Billing_cycleWhereInput
    /**
     * Limit how many Billing_cycles to delete.
     */
    limit?: number
  }

  /**
   * Billing_cycle.plans
   */
  export type Billing_cycle$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Billing_cycle without action
   */
  export type Billing_cycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycle
     */
    select?: Billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Billing_cycle
     */
    omit?: Billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Billing_cycleInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    user_id: string | null
    plan_id: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    user_id: string | null
    plan_id: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    start_date: number
    end_date: number
    status: number
    user_id: number
    plan_id: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    start_date: Date | null
    end_date: Date | null
    status: string
    user_id: string
    plan_id: string
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>



  export type SubscriptionSelectScalar = {
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start_date" | "end_date" | "status" | "user_id" | "plan_id", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      start_date: Date | null
      end_date: Date | null
      status: string
      user_id: string
      plan_id: string
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly start_date: FieldRef<"Subscription", 'DateTime'>
    readonly end_date: FieldRef<"Subscription", 'DateTime'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly user_id: FieldRef<"Subscription", 'String'>
    readonly plan_id: FieldRef<"Subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    created_at: number
    created_by: number
    deleted_at: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    created_at: Date
    created_by: string | null
    deleted_at: Date | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
    creator?: boolean | Role$creatorArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "created_at" | "created_by" | "deleted_at", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Role$creatorArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      created_at: Date
      created_by: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Role$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Role$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly title: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly created_at: FieldRef<"Role", 'DateTime'>
    readonly created_by: FieldRef<"Role", 'String'>
    readonly deleted_at: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.creator
   */
  export type Role$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    tel: 'tel',
    country: 'country',
    city: 'city',
    address: 'address',
    category: 'category',
    pfp_url: 'pfp_url',
    id_url: 'id_url',
    business_status: 'business_status',
    registered_with_a_business: 'registered_with_a_business',
    password: 'password',
    status: 'status',
    role_id: 'role_id',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganisationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    country: 'country',
    industry: 'industry',
    logo_url: 'logo_url',
    rc_number: 'rc_number',
    staff_size: 'staff_size',
    type: 'type',
    cert_of_inc_url: 'cert_of_inc_url',
    mem_of_assoc_url: 'mem_of_assoc_url',
    proof_of_address_url: 'proof_of_address_url',
    company_status_report_url: 'company_status_report_url',
    created_at: 'created_at',
    user_id: 'user_id',
    deleted_at: 'deleted_at'
  };

  export type OrganisationScalarFieldEnum = (typeof OrganisationScalarFieldEnum)[keyof typeof OrganisationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isPublic: 'isPublic',
    heroHeadline: 'heroHeadline',
    heroParagraph: 'heroParagraph',
    heroImageUrl: 'heroImageUrl',
    blueprintHeadline: 'blueprintHeadline',
    blueprintParagraph: 'blueprintParagraph',
    blueprintImageUrl: 'blueprintImageUrl',
    bannerText: 'bannerText',
    admin_id: 'admin_id',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceFormScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    formFields: 'formFields',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServiceFormScalarFieldEnum = (typeof ServiceFormScalarFieldEnum)[keyof typeof ServiceFormScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    priceUnit: 'priceUnit',
    audience: 'audience',
    features: 'features',
    service_id: 'service_id',
    position: 'position',
    plan_typeId: 'plan_typeId',
    billing_cycleId: 'billing_cycleId'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    service_request_id: 'service_request_id',
    amount: 'amount',
    status: 'status',
    due_date: 'due_date',
    paid_at: 'paid_at',
    payment_method: 'payment_method',
    payment_reference: 'payment_reference',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const CaseStudyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    bannerImageUrl: 'bannerImageUrl',
    challenge: 'challenge',
    challengeImageUrl: 'challengeImageUrl',
    solution: 'solution',
    solutionImageUrl: 'solutionImageUrl',
    result: 'result',
    resultImageUrl: 'resultImageUrl',
    service_id: 'service_id',
    organisationId: 'organisationId'
  };

  export type CaseStudyScalarFieldEnum = (typeof CaseStudyScalarFieldEnum)[keyof typeof CaseStudyScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    quote: 'quote',
    authorName: 'authorName',
    authorTitle: 'authorTitle',
    stars: 'stars',
    authorImageUrl: 'authorImageUrl',
    service_id: 'service_id',
    user_id: 'user_id'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    service_id: 'service_id'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const ServiceRequestScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    service_id: 'service_id',
    plan_name: 'plan_name',
    status: 'status',
    start_date: 'start_date',
    end_date: 'end_date',
    formData: 'formData',
    created_at: 'created_at',
    updated_at: 'updated_at',
    planId: 'planId'
  };

  export type ServiceRequestScalarFieldEnum = (typeof ServiceRequestScalarFieldEnum)[keyof typeof ServiceRequestScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    service_request_id: 'service_request_id',
    title: 'title',
    deadline: 'deadline',
    deliverable_file_url: 'deliverable_file_url',
    deliverable_file_name: 'deliverable_file_name',
    deliverable_link_url: 'deliverable_link_url',
    status: 'status',
    rejection_reason: 'rejection_reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pfp_url: 'pfp_url',
    organisation_id: 'organisation_id',
    id_url: 'id_url',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    otp: 'otp',
    expires_at: 'expires_at',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    service_request_id: 'service_request_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    sender_id: 'sender_id',
    text: 'text',
    created_at: 'created_at'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const Password_tokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    created_at: 'created_at',
    expires_at: 'expires_at',
    user_id: 'user_id'
  };

  export type Password_tokenScalarFieldEnum = (typeof Password_tokenScalarFieldEnum)[keyof typeof Password_tokenScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    activity: 'activity',
    completed_at: 'completed_at',
    user_id: 'user_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const Privacy_settingsScalarFieldEnum: {
    id: 'id',
    ads: 'ads',
    data_sharing: 'data_sharing',
    marketing_status: 'marketing_status',
    activity_status: 'activity_status',
    user_id: 'user_id'
  };

  export type Privacy_settingsScalarFieldEnum = (typeof Privacy_settingsScalarFieldEnum)[keyof typeof Privacy_settingsScalarFieldEnum]


  export const Notification_settingsScalarFieldEnum: {
    id: 'id',
    alerts: 'alerts',
    messages: 'messages',
    updates: 'updates',
    billing_alerts: 'billing_alerts',
    email: 'email',
    in_app: 'in_app',
    user_id: 'user_id'
  };

  export type Notification_settingsScalarFieldEnum = (typeof Notification_settingsScalarFieldEnum)[keyof typeof Notification_settingsScalarFieldEnum]


  export const Plan_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    created_by: 'created_by',
    deleted_at: 'deleted_at'
  };

  export type Plan_typeScalarFieldEnum = (typeof Plan_typeScalarFieldEnum)[keyof typeof Plan_typeScalarFieldEnum]


  export const Billing_cycleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    duration_in_days: 'duration_in_days',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type Billing_cycleScalarFieldEnum = (typeof Billing_cycleScalarFieldEnum)[keyof typeof Billing_cycleScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    user_id: 'user_id',
    plan_id: 'plan_id'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    created_at: 'created_at',
    created_by: 'created_by',
    deleted_at: 'deleted_at'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    tel: 'tel',
    country: 'country',
    city: 'city',
    address: 'address',
    category: 'category',
    pfp_url: 'pfp_url',
    password: 'password',
    status: 'status',
    role_id: 'role_id'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const OrganisationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    country: 'country',
    industry: 'industry',
    logo_url: 'logo_url',
    rc_number: 'rc_number',
    staff_size: 'staff_size',
    type: 'type',
    cert_of_inc_url: 'cert_of_inc_url',
    mem_of_assoc_url: 'mem_of_assoc_url',
    proof_of_address_url: 'proof_of_address_url',
    company_status_report_url: 'company_status_report_url',
    user_id: 'user_id'
  };

  export type OrganisationOrderByRelevanceFieldEnum = (typeof OrganisationOrderByRelevanceFieldEnum)[keyof typeof OrganisationOrderByRelevanceFieldEnum]


  export const ServiceOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    heroHeadline: 'heroHeadline',
    heroParagraph: 'heroParagraph',
    heroImageUrl: 'heroImageUrl',
    blueprintHeadline: 'blueprintHeadline',
    blueprintParagraph: 'blueprintParagraph',
    blueprintImageUrl: 'blueprintImageUrl',
    bannerText: 'bannerText',
    admin_id: 'admin_id'
  };

  export type ServiceOrderByRelevanceFieldEnum = (typeof ServiceOrderByRelevanceFieldEnum)[keyof typeof ServiceOrderByRelevanceFieldEnum]


  export const ServiceFormOrderByRelevanceFieldEnum: {
    id: 'id',
    service_id: 'service_id'
  };

  export type ServiceFormOrderByRelevanceFieldEnum = (typeof ServiceFormOrderByRelevanceFieldEnum)[keyof typeof ServiceFormOrderByRelevanceFieldEnum]


  export const PlanOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    priceUnit: 'priceUnit',
    audience: 'audience',
    service_id: 'service_id',
    plan_typeId: 'plan_typeId',
    billing_cycleId: 'billing_cycleId'
  };

  export type PlanOrderByRelevanceFieldEnum = (typeof PlanOrderByRelevanceFieldEnum)[keyof typeof PlanOrderByRelevanceFieldEnum]


  export const InvoiceOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    service_request_id: 'service_request_id',
    status: 'status',
    payment_method: 'payment_method',
    payment_reference: 'payment_reference'
  };

  export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


  export const CaseStudyOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    bannerImageUrl: 'bannerImageUrl',
    challenge: 'challenge',
    challengeImageUrl: 'challengeImageUrl',
    solution: 'solution',
    solutionImageUrl: 'solutionImageUrl',
    result: 'result',
    resultImageUrl: 'resultImageUrl',
    service_id: 'service_id',
    organisationId: 'organisationId'
  };

  export type CaseStudyOrderByRelevanceFieldEnum = (typeof CaseStudyOrderByRelevanceFieldEnum)[keyof typeof CaseStudyOrderByRelevanceFieldEnum]


  export const TestimonialOrderByRelevanceFieldEnum: {
    id: 'id',
    quote: 'quote',
    authorName: 'authorName',
    authorTitle: 'authorTitle',
    authorImageUrl: 'authorImageUrl',
    service_id: 'service_id',
    user_id: 'user_id'
  };

  export type TestimonialOrderByRelevanceFieldEnum = (typeof TestimonialOrderByRelevanceFieldEnum)[keyof typeof TestimonialOrderByRelevanceFieldEnum]


  export const FaqOrderByRelevanceFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    service_id: 'service_id'
  };

  export type FaqOrderByRelevanceFieldEnum = (typeof FaqOrderByRelevanceFieldEnum)[keyof typeof FaqOrderByRelevanceFieldEnum]


  export const ServiceRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    service_id: 'service_id',
    plan_name: 'plan_name',
    planId: 'planId'
  };

  export type ServiceRequestOrderByRelevanceFieldEnum = (typeof ServiceRequestOrderByRelevanceFieldEnum)[keyof typeof ServiceRequestOrderByRelevanceFieldEnum]


  export const MilestoneOrderByRelevanceFieldEnum: {
    id: 'id',
    service_request_id: 'service_request_id',
    title: 'title',
    deliverable_file_url: 'deliverable_file_url',
    deliverable_file_name: 'deliverable_file_name',
    deliverable_link_url: 'deliverable_link_url',
    rejection_reason: 'rejection_reason'
  };

  export type MilestoneOrderByRelevanceFieldEnum = (typeof MilestoneOrderByRelevanceFieldEnum)[keyof typeof MilestoneOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    pfp_url: 'pfp_url',
    organisation_id: 'organisation_id'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const OtpOrderByRelevanceFieldEnum: {
    id: 'id',
    otp: 'otp',
    user_id: 'user_id'
  };

  export type OtpOrderByRelevanceFieldEnum = (typeof OtpOrderByRelevanceFieldEnum)[keyof typeof OtpOrderByRelevanceFieldEnum]


  export const ConversationOrderByRelevanceFieldEnum: {
    id: 'id',
    service_request_id: 'service_request_id'
  };

  export type ConversationOrderByRelevanceFieldEnum = (typeof ConversationOrderByRelevanceFieldEnum)[keyof typeof ConversationOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    id: 'id',
    conversation_id: 'conversation_id',
    sender_id: 'sender_id',
    text: 'text'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const Password_tokenOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    user_id: 'user_id'
  };

  export type Password_tokenOrderByRelevanceFieldEnum = (typeof Password_tokenOrderByRelevanceFieldEnum)[keyof typeof Password_tokenOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    activity: 'activity',
    user_id: 'user_id'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const Privacy_settingsOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type Privacy_settingsOrderByRelevanceFieldEnum = (typeof Privacy_settingsOrderByRelevanceFieldEnum)[keyof typeof Privacy_settingsOrderByRelevanceFieldEnum]


  export const Notification_settingsOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type Notification_settingsOrderByRelevanceFieldEnum = (typeof Notification_settingsOrderByRelevanceFieldEnum)[keyof typeof Notification_settingsOrderByRelevanceFieldEnum]


  export const Plan_typeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    created_by: 'created_by'
  };

  export type Plan_typeOrderByRelevanceFieldEnum = (typeof Plan_typeOrderByRelevanceFieldEnum)[keyof typeof Plan_typeOrderByRelevanceFieldEnum]


  export const Billing_cycleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Billing_cycleOrderByRelevanceFieldEnum = (typeof Billing_cycleOrderByRelevanceFieldEnum)[keyof typeof Billing_cycleOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    status: 'status',
    user_id: 'user_id',
    plan_id: 'plan_id'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    created_by: 'created_by'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'ServiceRequestStatus'
   */
  export type EnumServiceRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceRequestStatus'>
    


  /**
   * Reference to a field of type 'MilestoneStatus'
   */
  export type EnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    tel?: StringFilter<"User"> | string
    country?: StringFilter<"User"> | string
    city?: StringNullableFilter<"User"> | string | null
    address?: StringFilter<"User"> | string
    category?: StringFilter<"User"> | string
    pfp_url?: StringNullableFilter<"User"> | string | null
    id_url?: JsonNullableFilter<"User">
    business_status?: BoolNullableFilter<"User"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"User"> | boolean | null
    password?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    role_id?: StringFilter<"User"> | string
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    notification_settings?: Notification_settingsListRelationFilter
    organisation?: XOR<OrganisationNullableScalarRelationFilter, OrganisationWhereInput> | null
    otps?: OtpListRelationFilter
    password_tokens?: Password_tokenListRelationFilter
    privacy_settings?: Privacy_settingsListRelationFilter
    created_roles?: RoleListRelationFilter
    services?: ServiceListRelationFilter
    service_requests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    testimonials?: TestimonialListRelationFilter
    plan_types?: Plan_typeListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    Invoice?: InvoiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    city?: SortOrderInput | SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrderInput | SortOrder
    id_url?: SortOrderInput | SortOrder
    business_status?: SortOrderInput | SortOrder
    registered_with_a_business?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    messages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notification_settings?: Notification_settingsOrderByRelationAggregateInput
    organisation?: OrganisationOrderByWithRelationInput
    otps?: OtpOrderByRelationAggregateInput
    password_tokens?: Password_tokenOrderByRelationAggregateInput
    privacy_settings?: Privacy_settingsOrderByRelationAggregateInput
    created_roles?: RoleOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    service_requests?: ServiceRequestOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    testimonials?: TestimonialOrderByRelationAggregateInput
    plan_types?: Plan_typeOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
    Invoice?: InvoiceOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    tel?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    country?: StringFilter<"User"> | string
    city?: StringNullableFilter<"User"> | string | null
    address?: StringFilter<"User"> | string
    category?: StringFilter<"User"> | string
    pfp_url?: StringNullableFilter<"User"> | string | null
    id_url?: JsonNullableFilter<"User">
    business_status?: BoolNullableFilter<"User"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"User"> | boolean | null
    password?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    role_id?: StringFilter<"User"> | string
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    notification_settings?: Notification_settingsListRelationFilter
    organisation?: XOR<OrganisationNullableScalarRelationFilter, OrganisationWhereInput> | null
    otps?: OtpListRelationFilter
    password_tokens?: Password_tokenListRelationFilter
    privacy_settings?: Privacy_settingsListRelationFilter
    created_roles?: RoleListRelationFilter
    services?: ServiceListRelationFilter
    service_requests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    testimonials?: TestimonialListRelationFilter
    plan_types?: Plan_typeListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    Invoice?: InvoiceListRelationFilter
  }, "id" | "email" | "tel">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    city?: SortOrderInput | SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrderInput | SortOrder
    id_url?: SortOrderInput | SortOrder
    business_status?: SortOrderInput | SortOrder
    registered_with_a_business?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    tel?: StringWithAggregatesFilter<"User"> | string
    country?: StringWithAggregatesFilter<"User"> | string
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringWithAggregatesFilter<"User"> | string
    category?: StringWithAggregatesFilter<"User"> | string
    pfp_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    id_url?: JsonNullableWithAggregatesFilter<"User">
    business_status?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    registered_with_a_business?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    password?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    role_id?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type OrganisationWhereInput = {
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    id?: StringFilter<"Organisation"> | string
    name?: StringFilter<"Organisation"> | string
    email?: StringFilter<"Organisation"> | string
    address?: StringFilter<"Organisation"> | string
    country?: StringFilter<"Organisation"> | string
    industry?: StringFilter<"Organisation"> | string
    logo_url?: StringFilter<"Organisation"> | string
    rc_number?: StringFilter<"Organisation"> | string
    staff_size?: StringFilter<"Organisation"> | string
    type?: StringFilter<"Organisation"> | string
    cert_of_inc_url?: StringFilter<"Organisation"> | string
    mem_of_assoc_url?: StringFilter<"Organisation"> | string
    proof_of_address_url?: StringFilter<"Organisation"> | string
    company_status_report_url?: StringFilter<"Organisation"> | string
    created_at?: DateTimeFilter<"Organisation"> | Date | string
    user_id?: StringFilter<"Organisation"> | string
    deleted_at?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    caseStudies?: CaseStudyListRelationFilter
    contacts?: ContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganisationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    cert_of_inc_url?: SortOrder
    mem_of_assoc_url?: SortOrder
    proof_of_address_url?: SortOrder
    company_status_report_url?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    caseStudies?: CaseStudyOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    _relevance?: OrganisationOrderByRelevanceInput
  }

  export type OrganisationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    rc_number?: string
    user_id?: string
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    name?: StringFilter<"Organisation"> | string
    address?: StringFilter<"Organisation"> | string
    country?: StringFilter<"Organisation"> | string
    industry?: StringFilter<"Organisation"> | string
    logo_url?: StringFilter<"Organisation"> | string
    staff_size?: StringFilter<"Organisation"> | string
    type?: StringFilter<"Organisation"> | string
    cert_of_inc_url?: StringFilter<"Organisation"> | string
    mem_of_assoc_url?: StringFilter<"Organisation"> | string
    proof_of_address_url?: StringFilter<"Organisation"> | string
    company_status_report_url?: StringFilter<"Organisation"> | string
    created_at?: DateTimeFilter<"Organisation"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    caseStudies?: CaseStudyListRelationFilter
    contacts?: ContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "email" | "rc_number" | "user_id">

  export type OrganisationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    cert_of_inc_url?: SortOrder
    mem_of_assoc_url?: SortOrder
    proof_of_address_url?: SortOrder
    company_status_report_url?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: OrganisationCountOrderByAggregateInput
    _max?: OrganisationMaxOrderByAggregateInput
    _min?: OrganisationMinOrderByAggregateInput
  }

  export type OrganisationScalarWhereWithAggregatesInput = {
    AND?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    OR?: OrganisationScalarWhereWithAggregatesInput[]
    NOT?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organisation"> | string
    name?: StringWithAggregatesFilter<"Organisation"> | string
    email?: StringWithAggregatesFilter<"Organisation"> | string
    address?: StringWithAggregatesFilter<"Organisation"> | string
    country?: StringWithAggregatesFilter<"Organisation"> | string
    industry?: StringWithAggregatesFilter<"Organisation"> | string
    logo_url?: StringWithAggregatesFilter<"Organisation"> | string
    rc_number?: StringWithAggregatesFilter<"Organisation"> | string
    staff_size?: StringWithAggregatesFilter<"Organisation"> | string
    type?: StringWithAggregatesFilter<"Organisation"> | string
    cert_of_inc_url?: StringWithAggregatesFilter<"Organisation"> | string
    mem_of_assoc_url?: StringWithAggregatesFilter<"Organisation"> | string
    proof_of_address_url?: StringWithAggregatesFilter<"Organisation"> | string
    company_status_report_url?: StringWithAggregatesFilter<"Organisation"> | string
    created_at?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
    user_id?: StringWithAggregatesFilter<"Organisation"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Organisation"> | Date | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    isPublic?: BoolFilter<"Service"> | boolean
    heroHeadline?: StringNullableFilter<"Service"> | string | null
    heroParagraph?: StringNullableFilter<"Service"> | string | null
    heroImageUrl?: StringNullableFilter<"Service"> | string | null
    blueprintHeadline?: StringNullableFilter<"Service"> | string | null
    blueprintParagraph?: StringNullableFilter<"Service"> | string | null
    blueprintImageUrl?: StringNullableFilter<"Service"> | string | null
    bannerText?: StringNullableFilter<"Service"> | string | null
    admin_id?: StringFilter<"Service"> | string
    created_at?: DateTimeNullableFilter<"Service"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Service"> | Date | string | null
    plans?: PlanListRelationFilter
    caseStudies?: CaseStudyListRelationFilter
    testimonials?: TestimonialListRelationFilter
    faqs?: FaqListRelationFilter
    service_requests?: ServiceRequestListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    form?: XOR<ServiceFormNullableScalarRelationFilter, ServiceFormWhereInput> | null
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isPublic?: SortOrder
    heroHeadline?: SortOrderInput | SortOrder
    heroParagraph?: SortOrderInput | SortOrder
    heroImageUrl?: SortOrderInput | SortOrder
    blueprintHeadline?: SortOrderInput | SortOrder
    blueprintParagraph?: SortOrderInput | SortOrder
    blueprintImageUrl?: SortOrderInput | SortOrder
    bannerText?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    plans?: PlanOrderByRelationAggregateInput
    caseStudies?: CaseStudyOrderByRelationAggregateInput
    testimonials?: TestimonialOrderByRelationAggregateInput
    faqs?: FaqOrderByRelationAggregateInput
    service_requests?: ServiceRequestOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    form?: ServiceFormOrderByWithRelationInput
    _relevance?: ServiceOrderByRelevanceInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    title?: StringFilter<"Service"> | string
    isPublic?: BoolFilter<"Service"> | boolean
    heroHeadline?: StringNullableFilter<"Service"> | string | null
    heroParagraph?: StringNullableFilter<"Service"> | string | null
    heroImageUrl?: StringNullableFilter<"Service"> | string | null
    blueprintHeadline?: StringNullableFilter<"Service"> | string | null
    blueprintParagraph?: StringNullableFilter<"Service"> | string | null
    blueprintImageUrl?: StringNullableFilter<"Service"> | string | null
    bannerText?: StringNullableFilter<"Service"> | string | null
    admin_id?: StringFilter<"Service"> | string
    created_at?: DateTimeNullableFilter<"Service"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Service"> | Date | string | null
    plans?: PlanListRelationFilter
    caseStudies?: CaseStudyListRelationFilter
    testimonials?: TestimonialListRelationFilter
    faqs?: FaqListRelationFilter
    service_requests?: ServiceRequestListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    form?: XOR<ServiceFormNullableScalarRelationFilter, ServiceFormWhereInput> | null
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isPublic?: SortOrder
    heroHeadline?: SortOrderInput | SortOrder
    heroParagraph?: SortOrderInput | SortOrder
    heroImageUrl?: SortOrderInput | SortOrder
    blueprintHeadline?: SortOrderInput | SortOrder
    blueprintParagraph?: SortOrderInput | SortOrder
    blueprintImageUrl?: SortOrderInput | SortOrder
    bannerText?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    title?: StringWithAggregatesFilter<"Service"> | string
    isPublic?: BoolWithAggregatesFilter<"Service"> | boolean
    heroHeadline?: StringNullableWithAggregatesFilter<"Service"> | string | null
    heroParagraph?: StringNullableWithAggregatesFilter<"Service"> | string | null
    heroImageUrl?: StringNullableWithAggregatesFilter<"Service"> | string | null
    blueprintHeadline?: StringNullableWithAggregatesFilter<"Service"> | string | null
    blueprintParagraph?: StringNullableWithAggregatesFilter<"Service"> | string | null
    blueprintImageUrl?: StringNullableWithAggregatesFilter<"Service"> | string | null
    bannerText?: StringNullableWithAggregatesFilter<"Service"> | string | null
    admin_id?: StringWithAggregatesFilter<"Service"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
  }

  export type ServiceFormWhereInput = {
    AND?: ServiceFormWhereInput | ServiceFormWhereInput[]
    OR?: ServiceFormWhereInput[]
    NOT?: ServiceFormWhereInput | ServiceFormWhereInput[]
    id?: StringFilter<"ServiceForm"> | string
    service_id?: StringFilter<"ServiceForm"> | string
    formFields?: JsonFilter<"ServiceForm">
    created_at?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServiceFormOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    formFields?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    service?: ServiceOrderByWithRelationInput
    _relevance?: ServiceFormOrderByRelevanceInput
  }

  export type ServiceFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_id?: string
    AND?: ServiceFormWhereInput | ServiceFormWhereInput[]
    OR?: ServiceFormWhereInput[]
    NOT?: ServiceFormWhereInput | ServiceFormWhereInput[]
    formFields?: JsonFilter<"ServiceForm">
    created_at?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "service_id">

  export type ServiceFormOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    formFields?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: ServiceFormCountOrderByAggregateInput
    _max?: ServiceFormMaxOrderByAggregateInput
    _min?: ServiceFormMinOrderByAggregateInput
  }

  export type ServiceFormScalarWhereWithAggregatesInput = {
    AND?: ServiceFormScalarWhereWithAggregatesInput | ServiceFormScalarWhereWithAggregatesInput[]
    OR?: ServiceFormScalarWhereWithAggregatesInput[]
    NOT?: ServiceFormScalarWhereWithAggregatesInput | ServiceFormScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceForm"> | string
    service_id?: StringWithAggregatesFilter<"ServiceForm"> | string
    formFields?: JsonWithAggregatesFilter<"ServiceForm">
    created_at?: DateTimeNullableWithAggregatesFilter<"ServiceForm"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"ServiceForm"> | Date | string | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: StringFilter<"Plan"> | string
    priceUnit?: StringFilter<"Plan"> | string
    audience?: StringFilter<"Plan"> | string
    features?: JsonFilter<"Plan">
    service_id?: StringFilter<"Plan"> | string
    position?: IntFilter<"Plan"> | number
    plan_typeId?: StringNullableFilter<"Plan"> | string | null
    billing_cycleId?: StringNullableFilter<"Plan"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    service_requests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    Plan_type?: XOR<Plan_typeNullableScalarRelationFilter, Plan_typeWhereInput> | null
    Billing_cycle?: XOR<Billing_cycleNullableScalarRelationFilter, Billing_cycleWhereInput> | null
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceUnit?: SortOrder
    audience?: SortOrder
    features?: SortOrder
    service_id?: SortOrder
    position?: SortOrder
    plan_typeId?: SortOrderInput | SortOrder
    billing_cycleId?: SortOrderInput | SortOrder
    service?: ServiceOrderByWithRelationInput
    service_requests?: ServiceRequestOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    Plan_type?: Plan_typeOrderByWithRelationInput
    Billing_cycle?: Billing_cycleOrderByWithRelationInput
    _relevance?: PlanOrderByRelevanceInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    price?: StringFilter<"Plan"> | string
    priceUnit?: StringFilter<"Plan"> | string
    audience?: StringFilter<"Plan"> | string
    features?: JsonFilter<"Plan">
    service_id?: StringFilter<"Plan"> | string
    position?: IntFilter<"Plan"> | number
    plan_typeId?: StringNullableFilter<"Plan"> | string | null
    billing_cycleId?: StringNullableFilter<"Plan"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    service_requests?: ServiceRequestListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    Plan_type?: XOR<Plan_typeNullableScalarRelationFilter, Plan_typeWhereInput> | null
    Billing_cycle?: XOR<Billing_cycleNullableScalarRelationFilter, Billing_cycleWhereInput> | null
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceUnit?: SortOrder
    audience?: SortOrder
    features?: SortOrder
    service_id?: SortOrder
    position?: SortOrder
    plan_typeId?: SortOrderInput | SortOrder
    billing_cycleId?: SortOrderInput | SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    price?: StringWithAggregatesFilter<"Plan"> | string
    priceUnit?: StringWithAggregatesFilter<"Plan"> | string
    audience?: StringWithAggregatesFilter<"Plan"> | string
    features?: JsonWithAggregatesFilter<"Plan">
    service_id?: StringWithAggregatesFilter<"Plan"> | string
    position?: IntWithAggregatesFilter<"Plan"> | number
    plan_typeId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    billing_cycleId?: StringNullableWithAggregatesFilter<"Plan"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    user_id?: StringFilter<"Invoice"> | string
    service_request_id?: StringNullableFilter<"Invoice"> | string | null
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    payment_method?: StringNullableFilter<"Invoice"> | string | null
    payment_reference?: StringNullableFilter<"Invoice"> | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service_request?: XOR<ServiceRequestNullableScalarRelationFilter, ServiceRequestWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_request_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_reference?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    service_request?: ServiceRequestOrderByWithRelationInput
    _relevance?: InvoiceOrderByRelevanceInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_request_id?: string
    payment_reference?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    user_id?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    payment_method?: StringNullableFilter<"Invoice"> | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service_request?: XOR<ServiceRequestNullableScalarRelationFilter, ServiceRequestWhereInput> | null
  }, "id" | "service_request_id" | "payment_reference">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_request_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_reference?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    user_id?: StringWithAggregatesFilter<"Invoice"> | string
    service_request_id?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    due_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    payment_method?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    payment_reference?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type CaseStudyWhereInput = {
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    id?: StringFilter<"CaseStudy"> | string
    title?: StringFilter<"CaseStudy"> | string
    subtitle?: StringFilter<"CaseStudy"> | string
    bannerImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    challenge?: StringNullableFilter<"CaseStudy"> | string | null
    challengeImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    solution?: StringNullableFilter<"CaseStudy"> | string | null
    solutionImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    result?: StringNullableFilter<"CaseStudy"> | string | null
    resultImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    service_id?: StringFilter<"CaseStudy"> | string
    organisationId?: StringNullableFilter<"CaseStudy"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    Organisation?: XOR<OrganisationNullableScalarRelationFilter, OrganisationWhereInput> | null
  }

  export type CaseStudyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    challenge?: SortOrderInput | SortOrder
    challengeImageUrl?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    solutionImageUrl?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    resultImageUrl?: SortOrderInput | SortOrder
    service_id?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    service?: ServiceOrderByWithRelationInput
    Organisation?: OrganisationOrderByWithRelationInput
    _relevance?: CaseStudyOrderByRelevanceInput
  }

  export type CaseStudyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    title?: StringFilter<"CaseStudy"> | string
    subtitle?: StringFilter<"CaseStudy"> | string
    bannerImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    challenge?: StringNullableFilter<"CaseStudy"> | string | null
    challengeImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    solution?: StringNullableFilter<"CaseStudy"> | string | null
    solutionImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    result?: StringNullableFilter<"CaseStudy"> | string | null
    resultImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    service_id?: StringFilter<"CaseStudy"> | string
    organisationId?: StringNullableFilter<"CaseStudy"> | string | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    Organisation?: XOR<OrganisationNullableScalarRelationFilter, OrganisationWhereInput> | null
  }, "id">

  export type CaseStudyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    challenge?: SortOrderInput | SortOrder
    challengeImageUrl?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    solutionImageUrl?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    resultImageUrl?: SortOrderInput | SortOrder
    service_id?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    _count?: CaseStudyCountOrderByAggregateInput
    _max?: CaseStudyMaxOrderByAggregateInput
    _min?: CaseStudyMinOrderByAggregateInput
  }

  export type CaseStudyScalarWhereWithAggregatesInput = {
    AND?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    OR?: CaseStudyScalarWhereWithAggregatesInput[]
    NOT?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseStudy"> | string
    title?: StringWithAggregatesFilter<"CaseStudy"> | string
    subtitle?: StringWithAggregatesFilter<"CaseStudy"> | string
    bannerImageUrl?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    challenge?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    challengeImageUrl?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    solution?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    solutionImageUrl?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    result?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    resultImageUrl?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    service_id?: StringWithAggregatesFilter<"CaseStudy"> | string
    organisationId?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    quote?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorTitle?: StringFilter<"Testimonial"> | string
    stars?: IntFilter<"Testimonial"> | number
    authorImageUrl?: StringNullableFilter<"Testimonial"> | string | null
    service_id?: StringFilter<"Testimonial"> | string
    user_id?: StringFilter<"Testimonial"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    quote?: SortOrder
    authorName?: SortOrder
    authorTitle?: SortOrder
    stars?: SortOrder
    authorImageUrl?: SortOrderInput | SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    service?: ServiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: TestimonialOrderByRelevanceInput
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    quote?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorTitle?: StringFilter<"Testimonial"> | string
    stars?: IntFilter<"Testimonial"> | number
    authorImageUrl?: StringNullableFilter<"Testimonial"> | string | null
    service_id?: StringFilter<"Testimonial"> | string
    user_id?: StringFilter<"Testimonial"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    quote?: SortOrder
    authorName?: SortOrder
    authorTitle?: SortOrder
    stars?: SortOrder
    authorImageUrl?: SortOrderInput | SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    quote?: StringWithAggregatesFilter<"Testimonial"> | string
    authorName?: StringWithAggregatesFilter<"Testimonial"> | string
    authorTitle?: StringWithAggregatesFilter<"Testimonial"> | string
    stars?: IntWithAggregatesFilter<"Testimonial"> | number
    authorImageUrl?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    service_id?: StringWithAggregatesFilter<"Testimonial"> | string
    user_id?: StringWithAggregatesFilter<"Testimonial"> | string
  }

  export type FaqWhereInput = {
    AND?: FaqWhereInput | FaqWhereInput[]
    OR?: FaqWhereInput[]
    NOT?: FaqWhereInput | FaqWhereInput[]
    id?: StringFilter<"Faq"> | string
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    service_id?: StringFilter<"Faq"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type FaqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    service_id?: SortOrder
    service?: ServiceOrderByWithRelationInput
    _relevance?: FaqOrderByRelevanceInput
  }

  export type FaqWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FaqWhereInput | FaqWhereInput[]
    OR?: FaqWhereInput[]
    NOT?: FaqWhereInput | FaqWhereInput[]
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    service_id?: StringFilter<"Faq"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type FaqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    service_id?: SortOrder
    _count?: FaqCountOrderByAggregateInput
    _max?: FaqMaxOrderByAggregateInput
    _min?: FaqMinOrderByAggregateInput
  }

  export type FaqScalarWhereWithAggregatesInput = {
    AND?: FaqScalarWhereWithAggregatesInput | FaqScalarWhereWithAggregatesInput[]
    OR?: FaqScalarWhereWithAggregatesInput[]
    NOT?: FaqScalarWhereWithAggregatesInput | FaqScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faq"> | string
    question?: StringWithAggregatesFilter<"Faq"> | string
    answer?: StringWithAggregatesFilter<"Faq"> | string
    service_id?: StringWithAggregatesFilter<"Faq"> | string
  }

  export type ServiceRequestWhereInput = {
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    user_id?: StringFilter<"ServiceRequest"> | string
    service_id?: StringFilter<"ServiceRequest"> | string
    plan_name?: StringFilter<"ServiceRequest"> | string
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    start_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    end_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    formData?: JsonFilter<"ServiceRequest">
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    planId?: StringNullableFilter<"ServiceRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    milestones?: MilestoneListRelationFilter
    Plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
  }

  export type ServiceRequestOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    formData?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    planId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    milestones?: MilestoneOrderByRelationAggregateInput
    Plan?: PlanOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
    _relevance?: ServiceRequestOrderByRelevanceInput
  }

  export type ServiceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    user_id?: StringFilter<"ServiceRequest"> | string
    service_id?: StringFilter<"ServiceRequest"> | string
    plan_name?: StringFilter<"ServiceRequest"> | string
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    start_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    end_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    formData?: JsonFilter<"ServiceRequest">
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    planId?: StringNullableFilter<"ServiceRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    milestones?: MilestoneListRelationFilter
    Plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    conversation?: XOR<ConversationNullableScalarRelationFilter, ConversationWhereInput> | null
  }, "id">

  export type ServiceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    formData?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    planId?: SortOrderInput | SortOrder
    _count?: ServiceRequestCountOrderByAggregateInput
    _max?: ServiceRequestMaxOrderByAggregateInput
    _min?: ServiceRequestMinOrderByAggregateInput
  }

  export type ServiceRequestScalarWhereWithAggregatesInput = {
    AND?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    OR?: ServiceRequestScalarWhereWithAggregatesInput[]
    NOT?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceRequest"> | string
    user_id?: StringWithAggregatesFilter<"ServiceRequest"> | string
    service_id?: StringWithAggregatesFilter<"ServiceRequest"> | string
    plan_name?: StringWithAggregatesFilter<"ServiceRequest"> | string
    status?: EnumServiceRequestStatusWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    start_date?: DateTimeNullableWithAggregatesFilter<"ServiceRequest"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"ServiceRequest"> | Date | string | null
    formData?: JsonWithAggregatesFilter<"ServiceRequest">
    created_at?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    planId?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    service_request_id?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    deadline?: DateTimeFilter<"Milestone"> | Date | string
    deliverable_file_url?: StringNullableFilter<"Milestone"> | string | null
    deliverable_file_name?: StringNullableFilter<"Milestone"> | string | null
    deliverable_link_url?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    rejection_reason?: StringNullableFilter<"Milestone"> | string | null
    created_at?: DateTimeFilter<"Milestone"> | Date | string
    updated_at?: DateTimeFilter<"Milestone"> | Date | string
    service_request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    title?: SortOrder
    deadline?: SortOrder
    deliverable_file_url?: SortOrderInput | SortOrder
    deliverable_file_name?: SortOrderInput | SortOrder
    deliverable_link_url?: SortOrderInput | SortOrder
    status?: SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service_request?: ServiceRequestOrderByWithRelationInput
    _relevance?: MilestoneOrderByRelevanceInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    service_request_id?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    deadline?: DateTimeFilter<"Milestone"> | Date | string
    deliverable_file_url?: StringNullableFilter<"Milestone"> | string | null
    deliverable_file_name?: StringNullableFilter<"Milestone"> | string | null
    deliverable_link_url?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    rejection_reason?: StringNullableFilter<"Milestone"> | string | null
    created_at?: DateTimeFilter<"Milestone"> | Date | string
    updated_at?: DateTimeFilter<"Milestone"> | Date | string
    service_request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    title?: SortOrder
    deadline?: SortOrder
    deliverable_file_url?: SortOrderInput | SortOrder
    deliverable_file_name?: SortOrderInput | SortOrder
    deliverable_link_url?: SortOrderInput | SortOrder
    status?: SortOrder
    rejection_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    service_request_id?: StringWithAggregatesFilter<"Milestone"> | string
    title?: StringWithAggregatesFilter<"Milestone"> | string
    deadline?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    deliverable_file_url?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    deliverable_file_name?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    deliverable_link_url?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusWithAggregatesFilter<"Milestone"> | $Enums.MilestoneStatus
    rejection_reason?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    pfp_url?: StringFilter<"Contact"> | string
    organisation_id?: StringFilter<"Contact"> | string
    id_url?: JsonFilter<"Contact">
    created_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    pfp_url?: StringFilter<"Contact"> | string
    organisation_id?: StringFilter<"Contact"> | string
    id_url?: JsonFilter<"Contact">
    created_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    pfp_url?: StringWithAggregatesFilter<"Contact"> | string
    organisation_id?: StringWithAggregatesFilter<"Contact"> | string
    id_url?: JsonWithAggregatesFilter<"Contact">
    created_at?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expires_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    user_id?: StringFilter<"Otp"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: OtpOrderByRelevanceInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    otp?: StringFilter<"Otp"> | string
    expires_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    user_id?: StringFilter<"Otp"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"Otp"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"Otp"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"Otp"> | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    service_request_id?: StringFilter<"Conversation"> | string
    created_at?: DateTimeFilter<"Conversation"> | Date | string
    updated_at?: DateTimeFilter<"Conversation"> | Date | string
    service_request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    service_request?: ServiceRequestOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    _relevance?: ConversationOrderByRelevanceInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_request_id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    created_at?: DateTimeFilter<"Conversation"> | Date | string
    updated_at?: DateTimeFilter<"Conversation"> | Date | string
    service_request?: XOR<ServiceRequestScalarRelationFilter, ServiceRequestWhereInput>
    messages?: MessageListRelationFilter
  }, "id" | "service_request_id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    service_request_id?: StringWithAggregatesFilter<"Conversation"> | string
    created_at?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    created_at?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    created_at?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversation_id?: StringWithAggregatesFilter<"Message"> | string
    sender_id?: StringWithAggregatesFilter<"Message"> | string
    text?: StringWithAggregatesFilter<"Message"> | string
    created_at?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type Password_tokenWhereInput = {
    AND?: Password_tokenWhereInput | Password_tokenWhereInput[]
    OR?: Password_tokenWhereInput[]
    NOT?: Password_tokenWhereInput | Password_tokenWhereInput[]
    id?: StringFilter<"Password_token"> | string
    token?: StringFilter<"Password_token"> | string
    created_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    user_id?: StringFilter<"Password_token"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type Password_tokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: Password_tokenOrderByRelevanceInput
  }

  export type Password_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Password_tokenWhereInput | Password_tokenWhereInput[]
    OR?: Password_tokenWhereInput[]
    NOT?: Password_tokenWhereInput | Password_tokenWhereInput[]
    token?: StringFilter<"Password_token"> | string
    created_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    user_id?: StringFilter<"Password_token"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type Password_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: Password_tokenCountOrderByAggregateInput
    _max?: Password_tokenMaxOrderByAggregateInput
    _min?: Password_tokenMinOrderByAggregateInput
  }

  export type Password_tokenScalarWhereWithAggregatesInput = {
    AND?: Password_tokenScalarWhereWithAggregatesInput | Password_tokenScalarWhereWithAggregatesInput[]
    OR?: Password_tokenScalarWhereWithAggregatesInput[]
    NOT?: Password_tokenScalarWhereWithAggregatesInput | Password_tokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Password_token"> | string
    token?: StringWithAggregatesFilter<"Password_token"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"Password_token"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"Password_token"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"Password_token"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    activity?: StringFilter<"Notification"> | string
    completed_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user_id?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    activity?: StringFilter<"Notification"> | string
    completed_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user_id?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    activity?: StringWithAggregatesFilter<"Notification"> | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type Privacy_settingsWhereInput = {
    AND?: Privacy_settingsWhereInput | Privacy_settingsWhereInput[]
    OR?: Privacy_settingsWhereInput[]
    NOT?: Privacy_settingsWhereInput | Privacy_settingsWhereInput[]
    id?: StringFilter<"Privacy_settings"> | string
    ads?: BoolFilter<"Privacy_settings"> | boolean
    data_sharing?: BoolFilter<"Privacy_settings"> | boolean
    marketing_status?: BoolFilter<"Privacy_settings"> | boolean
    activity_status?: BoolFilter<"Privacy_settings"> | boolean
    user_id?: StringFilter<"Privacy_settings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type Privacy_settingsOrderByWithRelationInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: Privacy_settingsOrderByRelevanceInput
  }

  export type Privacy_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Privacy_settingsWhereInput | Privacy_settingsWhereInput[]
    OR?: Privacy_settingsWhereInput[]
    NOT?: Privacy_settingsWhereInput | Privacy_settingsWhereInput[]
    ads?: BoolFilter<"Privacy_settings"> | boolean
    data_sharing?: BoolFilter<"Privacy_settings"> | boolean
    marketing_status?: BoolFilter<"Privacy_settings"> | boolean
    activity_status?: BoolFilter<"Privacy_settings"> | boolean
    user_id?: StringFilter<"Privacy_settings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type Privacy_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
    _count?: Privacy_settingsCountOrderByAggregateInput
    _max?: Privacy_settingsMaxOrderByAggregateInput
    _min?: Privacy_settingsMinOrderByAggregateInput
  }

  export type Privacy_settingsScalarWhereWithAggregatesInput = {
    AND?: Privacy_settingsScalarWhereWithAggregatesInput | Privacy_settingsScalarWhereWithAggregatesInput[]
    OR?: Privacy_settingsScalarWhereWithAggregatesInput[]
    NOT?: Privacy_settingsScalarWhereWithAggregatesInput | Privacy_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Privacy_settings"> | string
    ads?: BoolWithAggregatesFilter<"Privacy_settings"> | boolean
    data_sharing?: BoolWithAggregatesFilter<"Privacy_settings"> | boolean
    marketing_status?: BoolWithAggregatesFilter<"Privacy_settings"> | boolean
    activity_status?: BoolWithAggregatesFilter<"Privacy_settings"> | boolean
    user_id?: StringWithAggregatesFilter<"Privacy_settings"> | string
  }

  export type Notification_settingsWhereInput = {
    AND?: Notification_settingsWhereInput | Notification_settingsWhereInput[]
    OR?: Notification_settingsWhereInput[]
    NOT?: Notification_settingsWhereInput | Notification_settingsWhereInput[]
    id?: StringFilter<"Notification_settings"> | string
    alerts?: BoolFilter<"Notification_settings"> | boolean
    messages?: BoolFilter<"Notification_settings"> | boolean
    updates?: BoolFilter<"Notification_settings"> | boolean
    billing_alerts?: BoolFilter<"Notification_settings"> | boolean
    email?: BoolFilter<"Notification_settings"> | boolean
    in_app?: BoolFilter<"Notification_settings"> | boolean
    user_id?: StringFilter<"Notification_settings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type Notification_settingsOrderByWithRelationInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: Notification_settingsOrderByRelevanceInput
  }

  export type Notification_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Notification_settingsWhereInput | Notification_settingsWhereInput[]
    OR?: Notification_settingsWhereInput[]
    NOT?: Notification_settingsWhereInput | Notification_settingsWhereInput[]
    alerts?: BoolFilter<"Notification_settings"> | boolean
    messages?: BoolFilter<"Notification_settings"> | boolean
    updates?: BoolFilter<"Notification_settings"> | boolean
    billing_alerts?: BoolFilter<"Notification_settings"> | boolean
    email?: BoolFilter<"Notification_settings"> | boolean
    in_app?: BoolFilter<"Notification_settings"> | boolean
    user_id?: StringFilter<"Notification_settings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type Notification_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
    _count?: Notification_settingsCountOrderByAggregateInput
    _max?: Notification_settingsMaxOrderByAggregateInput
    _min?: Notification_settingsMinOrderByAggregateInput
  }

  export type Notification_settingsScalarWhereWithAggregatesInput = {
    AND?: Notification_settingsScalarWhereWithAggregatesInput | Notification_settingsScalarWhereWithAggregatesInput[]
    OR?: Notification_settingsScalarWhereWithAggregatesInput[]
    NOT?: Notification_settingsScalarWhereWithAggregatesInput | Notification_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification_settings"> | string
    alerts?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    messages?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    updates?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    billing_alerts?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    email?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    in_app?: BoolWithAggregatesFilter<"Notification_settings"> | boolean
    user_id?: StringWithAggregatesFilter<"Notification_settings"> | string
  }

  export type Plan_typeWhereInput = {
    AND?: Plan_typeWhereInput | Plan_typeWhereInput[]
    OR?: Plan_typeWhereInput[]
    NOT?: Plan_typeWhereInput | Plan_typeWhereInput[]
    id?: StringFilter<"Plan_type"> | string
    name?: StringFilter<"Plan_type"> | string
    created_at?: DateTimeFilter<"Plan_type"> | Date | string
    created_by?: StringFilter<"Plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"Plan_type"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plans?: PlanListRelationFilter
  }

  export type Plan_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    plans?: PlanOrderByRelationAggregateInput
    _relevance?: Plan_typeOrderByRelevanceInput
  }

  export type Plan_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Plan_typeWhereInput | Plan_typeWhereInput[]
    OR?: Plan_typeWhereInput[]
    NOT?: Plan_typeWhereInput | Plan_typeWhereInput[]
    name?: StringFilter<"Plan_type"> | string
    created_at?: DateTimeFilter<"Plan_type"> | Date | string
    created_by?: StringFilter<"Plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"Plan_type"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plans?: PlanListRelationFilter
  }, "id">

  export type Plan_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: Plan_typeCountOrderByAggregateInput
    _max?: Plan_typeMaxOrderByAggregateInput
    _min?: Plan_typeMinOrderByAggregateInput
  }

  export type Plan_typeScalarWhereWithAggregatesInput = {
    AND?: Plan_typeScalarWhereWithAggregatesInput | Plan_typeScalarWhereWithAggregatesInput[]
    OR?: Plan_typeScalarWhereWithAggregatesInput[]
    NOT?: Plan_typeScalarWhereWithAggregatesInput | Plan_typeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan_type"> | string
    name?: StringWithAggregatesFilter<"Plan_type"> | string
    created_at?: DateTimeWithAggregatesFilter<"Plan_type"> | Date | string
    created_by?: StringWithAggregatesFilter<"Plan_type"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Plan_type"> | Date | string | null
  }

  export type Billing_cycleWhereInput = {
    AND?: Billing_cycleWhereInput | Billing_cycleWhereInput[]
    OR?: Billing_cycleWhereInput[]
    NOT?: Billing_cycleWhereInput | Billing_cycleWhereInput[]
    id?: StringFilter<"Billing_cycle"> | string
    name?: StringFilter<"Billing_cycle"> | string
    duration_in_days?: IntFilter<"Billing_cycle"> | number
    created_at?: DateTimeFilter<"Billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Billing_cycle"> | Date | string | null
    plans?: PlanListRelationFilter
  }

  export type Billing_cycleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    plans?: PlanOrderByRelationAggregateInput
    _relevance?: Billing_cycleOrderByRelevanceInput
  }

  export type Billing_cycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Billing_cycleWhereInput | Billing_cycleWhereInput[]
    OR?: Billing_cycleWhereInput[]
    NOT?: Billing_cycleWhereInput | Billing_cycleWhereInput[]
    name?: StringFilter<"Billing_cycle"> | string
    duration_in_days?: IntFilter<"Billing_cycle"> | number
    created_at?: DateTimeFilter<"Billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Billing_cycle"> | Date | string | null
    plans?: PlanListRelationFilter
  }, "id">

  export type Billing_cycleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: Billing_cycleCountOrderByAggregateInput
    _avg?: Billing_cycleAvgOrderByAggregateInput
    _max?: Billing_cycleMaxOrderByAggregateInput
    _min?: Billing_cycleMinOrderByAggregateInput
    _sum?: Billing_cycleSumOrderByAggregateInput
  }

  export type Billing_cycleScalarWhereWithAggregatesInput = {
    AND?: Billing_cycleScalarWhereWithAggregatesInput | Billing_cycleScalarWhereWithAggregatesInput[]
    OR?: Billing_cycleScalarWhereWithAggregatesInput[]
    NOT?: Billing_cycleScalarWhereWithAggregatesInput | Billing_cycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Billing_cycle"> | string
    name?: StringWithAggregatesFilter<"Billing_cycle"> | string
    duration_in_days?: IntWithAggregatesFilter<"Billing_cycle"> | number
    created_at?: DateTimeWithAggregatesFilter<"Billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Billing_cycle"> | Date | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringFilter<"Subscription"> | string
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    plan?: PlanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringFilter<"Subscription"> | string
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    start_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    user_id?: StringWithAggregatesFilter<"Subscription"> | string
    plan_id?: StringWithAggregatesFilter<"Subscription"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    title?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    created_at?: DateTimeFilter<"Role"> | Date | string
    created_by?: StringNullableFilter<"Role"> | string | null
    deleted_at?: DateTimeNullableFilter<"Role"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    created_at?: DateTimeFilter<"Role"> | Date | string
    created_by?: StringNullableFilter<"Role"> | string | null
    deleted_at?: DateTimeNullableFilter<"Role"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
  }, "id" | "title">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    title?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"Role"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganisationCreateInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyCreateNestedManyWithoutOrganisationInput
    contacts?: ContactCreateNestedManyWithoutOrganisationInput
    user: UserCreateNestedOneWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOrganisationInput
    contacts?: ContactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUpdateManyWithoutOrganisationNestedInput
    contacts?: ContactUpdateManyWithoutOrganisationNestedInput
    user?: UserUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOrganisationNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateManyInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
  }

  export type OrganisationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganisationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceFormCreateInput = {
    id?: string
    formFields: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    service: ServiceCreateNestedOneWithoutFormInput
  }

  export type ServiceFormUncheckedCreateInput = {
    id?: string
    service_id: string
    formFields: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ServiceFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneRequiredWithoutFormNestedInput
  }

  export type ServiceFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceFormCreateManyInput = {
    id?: string
    service_id: string
    formFields: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ServiceFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service: ServiceCreateNestedOneWithoutPlansInput
    service_requests?: ServiceRequestCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    Plan_type?: Plan_typeCreateNestedOneWithoutPlansInput
    Billing_cycle?: Billing_cycleCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutPlansNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    Plan_type?: Plan_typeUpdateOneWithoutPlansNestedInput
    Billing_cycle?: Billing_cycleUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutInvoiceInput
    service_request?: ServiceRequestCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    user_id: string
    service_request_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    service_request?: ServiceRequestUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    user_id: string
    service_request_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service: ServiceCreateNestedOneWithoutCaseStudiesInput
    Organisation?: OrganisationCreateNestedOneWithoutCaseStudiesInput
  }

  export type CaseStudyUncheckedCreateInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service_id: string
    organisationId?: string | null
  }

  export type CaseStudyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutCaseStudiesNestedInput
    Organisation?: OrganisationUpdateOneWithoutCaseStudiesNestedInput
  }

  export type CaseStudyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyCreateManyInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service_id: string
    organisationId?: string | null
  }

  export type CaseStudyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestimonialCreateInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service: ServiceCreateNestedOneWithoutTestimonialsInput
    user: UserCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service_id: string
    user_id: string
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutTestimonialsNestedInput
    user?: UserUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service_id: string
    user_id: string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateInput = {
    id?: string
    question: string
    answer: string
    service: ServiceCreateNestedOneWithoutFaqsInput
  }

  export type FaqUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    service_id: string
  }

  export type FaqUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutFaqsNestedInput
  }

  export type FaqUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateManyInput = {
    id?: string
    question: string
    answer: string
    service_id: string
  }

  export type FaqUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRequestCreateInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    service: ServiceCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestCreateManyInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
  }

  export type ServiceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneCreateInput = {
    id?: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    service_request: ServiceRequestCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    service_request_id: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service_request?: ServiceRequestUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    service_request_id: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    organisation: OrganisationCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpCreateInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user_id: string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type OtpCreateManyInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user_id: string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    service_request: ServiceRequestCreateNestedOneWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    service_request_id: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service_request?: ServiceRequestUpdateOneRequiredWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    service_request_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    text: string
    created_at?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversation_id: string
    sender_id: string
    text: string
    created_at?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversation_id: string
    sender_id: string
    text: string
    created_at?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Password_tokenCreateInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user: UserCreateNestedOneWithoutPassword_tokensInput
  }

  export type Password_tokenUncheckedCreateInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user_id: string
  }

  export type Password_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPassword_tokensNestedInput
  }

  export type Password_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Password_tokenCreateManyInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user_id: string
  }

  export type Password_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user_id: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user_id: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Privacy_settingsCreateInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user: UserCreateNestedOneWithoutPrivacy_settingsInput
  }

  export type Privacy_settingsUncheckedCreateInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id: string
  }

  export type Privacy_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPrivacy_settingsNestedInput
  }

  export type Privacy_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Privacy_settingsCreateManyInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id: string
  }

  export type Privacy_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Privacy_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Notification_settingsCreateInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user: UserCreateNestedOneWithoutNotification_settingsInput
  }

  export type Notification_settingsUncheckedCreateInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id: string
  }

  export type Notification_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotification_settingsNestedInput
  }

  export type Notification_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Notification_settingsCreateManyInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id: string
  }

  export type Notification_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Notification_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type Plan_typeCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutPlan_typesInput
    plans?: PlanCreateNestedManyWithoutPlan_typeInput
  }

  export type Plan_typeUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutPlan_typeInput
  }

  export type Plan_typeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPlan_typesNestedInput
    plans?: PlanUpdateManyWithoutPlan_typeNestedInput
  }

  export type Plan_typeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutPlan_typeNestedInput
  }

  export type Plan_typeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
  }

  export type Plan_typeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Plan_typeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Billing_cycleCreateInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutBilling_cycleInput
  }

  export type Billing_cycleUncheckedCreateInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutBilling_cycleInput
  }

  export type Billing_cycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutBilling_cycleNestedInput
  }

  export type Billing_cycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutBilling_cycleNestedInput
  }

  export type Billing_cycleCreateManyInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type Billing_cycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Billing_cycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
    plan_id: string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
    plan_id: string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    creator?: UserCreateNestedOneWithoutCreated_rolesInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutCreated_rolesNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type Notification_settingsListRelationFilter = {
    every?: Notification_settingsWhereInput
    some?: Notification_settingsWhereInput
    none?: Notification_settingsWhereInput
  }

  export type OrganisationNullableScalarRelationFilter = {
    is?: OrganisationWhereInput | null
    isNot?: OrganisationWhereInput | null
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type Password_tokenListRelationFilter = {
    every?: Password_tokenWhereInput
    some?: Password_tokenWhereInput
    none?: Password_tokenWhereInput
  }

  export type Privacy_settingsListRelationFilter = {
    every?: Privacy_settingsWhereInput
    some?: Privacy_settingsWhereInput
    none?: Privacy_settingsWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceRequestListRelationFilter = {
    every?: ServiceRequestWhereInput
    some?: ServiceRequestWhereInput
    none?: ServiceRequestWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: TestimonialWhereInput
    some?: TestimonialWhereInput
    none?: TestimonialWhereInput
  }

  export type Plan_typeListRelationFilter = {
    every?: Plan_typeWhereInput
    some?: Plan_typeWhereInput
    none?: Plan_typeWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Notification_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Password_tokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Privacy_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Plan_typeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    id_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    city?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CaseStudyListRelationFilter = {
    every?: CaseStudyWhereInput
    some?: CaseStudyWhereInput
    none?: CaseStudyWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CaseStudyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationOrderByRelevanceInput = {
    fields: OrganisationOrderByRelevanceFieldEnum | OrganisationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganisationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    cert_of_inc_url?: SortOrder
    mem_of_assoc_url?: SortOrder
    proof_of_address_url?: SortOrder
    company_status_report_url?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrganisationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    cert_of_inc_url?: SortOrder
    mem_of_assoc_url?: SortOrder
    proof_of_address_url?: SortOrder
    company_status_report_url?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type OrganisationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    cert_of_inc_url?: SortOrder
    mem_of_assoc_url?: SortOrder
    proof_of_address_url?: SortOrder
    company_status_report_url?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type FaqListRelationFilter = {
    every?: FaqWhereInput
    some?: FaqWhereInput
    none?: FaqWhereInput
  }

  export type ServiceFormNullableScalarRelationFilter = {
    is?: ServiceFormWhereInput | null
    isNot?: ServiceFormWhereInput | null
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FaqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelevanceInput = {
    fields: ServiceOrderByRelevanceFieldEnum | ServiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isPublic?: SortOrder
    heroHeadline?: SortOrder
    heroParagraph?: SortOrder
    heroImageUrl?: SortOrder
    blueprintHeadline?: SortOrder
    blueprintParagraph?: SortOrder
    blueprintImageUrl?: SortOrder
    bannerText?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isPublic?: SortOrder
    heroHeadline?: SortOrder
    heroParagraph?: SortOrder
    heroImageUrl?: SortOrder
    blueprintHeadline?: SortOrder
    blueprintParagraph?: SortOrder
    blueprintImageUrl?: SortOrder
    bannerText?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isPublic?: SortOrder
    heroHeadline?: SortOrder
    heroParagraph?: SortOrder
    heroImageUrl?: SortOrder
    blueprintHeadline?: SortOrder
    blueprintParagraph?: SortOrder
    blueprintImageUrl?: SortOrder
    bannerText?: SortOrder
    admin_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceFormOrderByRelevanceInput = {
    fields: ServiceFormOrderByRelevanceFieldEnum | ServiceFormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceFormCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    formFields?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceFormMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceFormMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Plan_typeNullableScalarRelationFilter = {
    is?: Plan_typeWhereInput | null
    isNot?: Plan_typeWhereInput | null
  }

  export type Billing_cycleNullableScalarRelationFilter = {
    is?: Billing_cycleWhereInput | null
    isNot?: Billing_cycleWhereInput | null
  }

  export type PlanOrderByRelevanceInput = {
    fields: PlanOrderByRelevanceFieldEnum | PlanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceUnit?: SortOrder
    audience?: SortOrder
    features?: SortOrder
    service_id?: SortOrder
    position?: SortOrder
    plan_typeId?: SortOrder
    billing_cycleId?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceUnit?: SortOrder
    audience?: SortOrder
    service_id?: SortOrder
    position?: SortOrder
    plan_typeId?: SortOrder
    billing_cycleId?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceUnit?: SortOrder
    audience?: SortOrder
    service_id?: SortOrder
    position?: SortOrder
    plan_typeId?: SortOrder
    billing_cycleId?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceRequestNullableScalarRelationFilter = {
    is?: ServiceRequestWhereInput | null
    isNot?: ServiceRequestWhereInput | null
  }

  export type InvoiceOrderByRelevanceInput = {
    fields: InvoiceOrderByRelevanceFieldEnum | InvoiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_request_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    payment_method?: SortOrder
    payment_reference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_request_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    payment_method?: SortOrder
    payment_reference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_request_id?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    payment_method?: SortOrder
    payment_reference?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CaseStudyOrderByRelevanceInput = {
    fields: CaseStudyOrderByRelevanceFieldEnum | CaseStudyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CaseStudyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    bannerImageUrl?: SortOrder
    challenge?: SortOrder
    challengeImageUrl?: SortOrder
    solution?: SortOrder
    solutionImageUrl?: SortOrder
    result?: SortOrder
    resultImageUrl?: SortOrder
    service_id?: SortOrder
    organisationId?: SortOrder
  }

  export type CaseStudyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    bannerImageUrl?: SortOrder
    challenge?: SortOrder
    challengeImageUrl?: SortOrder
    solution?: SortOrder
    solutionImageUrl?: SortOrder
    result?: SortOrder
    resultImageUrl?: SortOrder
    service_id?: SortOrder
    organisationId?: SortOrder
  }

  export type CaseStudyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    bannerImageUrl?: SortOrder
    challenge?: SortOrder
    challengeImageUrl?: SortOrder
    solution?: SortOrder
    solutionImageUrl?: SortOrder
    result?: SortOrder
    resultImageUrl?: SortOrder
    service_id?: SortOrder
    organisationId?: SortOrder
  }

  export type TestimonialOrderByRelevanceInput = {
    fields: TestimonialOrderByRelevanceFieldEnum | TestimonialOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    authorName?: SortOrder
    authorTitle?: SortOrder
    stars?: SortOrder
    authorImageUrl?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    authorName?: SortOrder
    authorTitle?: SortOrder
    stars?: SortOrder
    authorImageUrl?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    quote?: SortOrder
    authorName?: SortOrder
    authorTitle?: SortOrder
    stars?: SortOrder
    authorImageUrl?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type FaqOrderByRelevanceInput = {
    fields: FaqOrderByRelevanceFieldEnum | FaqOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FaqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    service_id?: SortOrder
  }

  export type FaqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    service_id?: SortOrder
  }

  export type FaqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    service_id?: SortOrder
  }

  export type EnumServiceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[]
    notIn?: $Enums.ServiceRequestStatus[]
    not?: NestedEnumServiceRequestStatusFilter<$PrismaModel> | $Enums.ServiceRequestStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type PlanNullableScalarRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type ConversationNullableScalarRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelevanceInput = {
    fields: ServiceRequestOrderByRelevanceFieldEnum | ServiceRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    formData?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    planId?: SortOrder
  }

  export type ServiceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    planId?: SortOrder
  }

  export type ServiceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    plan_name?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    planId?: SortOrder
  }

  export type EnumServiceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[]
    notIn?: $Enums.ServiceRequestStatus[]
    not?: NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
  }

  export type EnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[]
    notIn?: $Enums.MilestoneStatus[]
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type ServiceRequestScalarRelationFilter = {
    is?: ServiceRequestWhereInput
    isNot?: ServiceRequestWhereInput
  }

  export type MilestoneOrderByRelevanceInput = {
    fields: MilestoneOrderByRelevanceFieldEnum | MilestoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    title?: SortOrder
    deadline?: SortOrder
    deliverable_file_url?: SortOrder
    deliverable_file_name?: SortOrder
    deliverable_link_url?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    title?: SortOrder
    deadline?: SortOrder
    deliverable_file_url?: SortOrder
    deliverable_file_name?: SortOrder
    deliverable_link_url?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    title?: SortOrder
    deadline?: SortOrder
    deliverable_file_url?: SortOrder
    deliverable_file_name?: SortOrder
    deliverable_link_url?: SortOrder
    status?: SortOrder
    rejection_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[]
    notIn?: $Enums.MilestoneStatus[]
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type OrganisationScalarRelationFilter = {
    is?: OrganisationWhereInput
    isNot?: OrganisationWhereInput
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type OtpOrderByRelevanceInput = {
    fields: OtpOrderByRelevanceFieldEnum | OtpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type ConversationOrderByRelevanceInput = {
    fields: ConversationOrderByRelevanceFieldEnum | ConversationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    service_request_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversation_id?: SortOrder
    sender_id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
  }

  export type Password_tokenOrderByRelevanceInput = {
    fields: Password_tokenOrderByRelevanceFieldEnum | Password_tokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Password_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type Password_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type Password_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type Privacy_settingsOrderByRelevanceInput = {
    fields: Privacy_settingsOrderByRelevanceFieldEnum | Privacy_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Privacy_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type Privacy_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type Privacy_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type Notification_settingsOrderByRelevanceInput = {
    fields: Notification_settingsOrderByRelevanceFieldEnum | Notification_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Notification_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type Notification_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type Notification_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type Plan_typeOrderByRelevanceInput = {
    fields: Plan_typeOrderByRelevanceFieldEnum | Plan_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Plan_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type Plan_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type Plan_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type Billing_cycleOrderByRelevanceInput = {
    fields: Billing_cycleOrderByRelevanceFieldEnum | Billing_cycleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type Billing_cycleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Billing_cycleAvgOrderByAggregateInput = {
    duration_in_days?: SortOrder
  }

  export type Billing_cycleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Billing_cycleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type Billing_cycleSumOrderByAggregateInput = {
    duration_in_days?: SortOrder
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type Notification_settingsCreateNestedManyWithoutUserInput = {
    create?: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput> | Notification_settingsCreateWithoutUserInput[] | Notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Notification_settingsCreateOrConnectWithoutUserInput | Notification_settingsCreateOrConnectWithoutUserInput[]
    createMany?: Notification_settingsCreateManyUserInputEnvelope
    connect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
  }

  export type OrganisationCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutUserInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OtpCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type Password_tokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput> | Password_tokenCreateWithoutUserInput[] | Password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Password_tokenCreateOrConnectWithoutUserInput | Password_tokenCreateOrConnectWithoutUserInput[]
    createMany?: Password_tokenCreateManyUserInputEnvelope
    connect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
  }

  export type Privacy_settingsCreateNestedManyWithoutUserInput = {
    create?: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput> | Privacy_settingsCreateWithoutUserInput[] | Privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Privacy_settingsCreateOrConnectWithoutUserInput | Privacy_settingsCreateOrConnectWithoutUserInput[]
    createMany?: Privacy_settingsCreateManyUserInputEnvelope
    connect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput> | RoleCreateWithoutCreatorInput[] | RoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatorInput | RoleCreateOrConnectWithoutCreatorInput[]
    createMany?: RoleCreateManyCreatorInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TestimonialCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type Plan_typeCreateNestedManyWithoutUserInput = {
    create?: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput> | Plan_typeCreateWithoutUserInput[] | Plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Plan_typeCreateOrConnectWithoutUserInput | Plan_typeCreateOrConnectWithoutUserInput[]
    createMany?: Plan_typeCreateManyUserInputEnvelope
    connect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type Notification_settingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput> | Notification_settingsCreateWithoutUserInput[] | Notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Notification_settingsCreateOrConnectWithoutUserInput | Notification_settingsCreateOrConnectWithoutUserInput[]
    createMany?: Notification_settingsCreateManyUserInputEnvelope
    connect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
  }

  export type OrganisationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutUserInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OtpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type Password_tokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput> | Password_tokenCreateWithoutUserInput[] | Password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Password_tokenCreateOrConnectWithoutUserInput | Password_tokenCreateOrConnectWithoutUserInput[]
    createMany?: Password_tokenCreateManyUserInputEnvelope
    connect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
  }

  export type Privacy_settingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput> | Privacy_settingsCreateWithoutUserInput[] | Privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Privacy_settingsCreateOrConnectWithoutUserInput | Privacy_settingsCreateOrConnectWithoutUserInput[]
    createMany?: Privacy_settingsCreateManyUserInputEnvelope
    connect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput> | RoleCreateWithoutCreatorInput[] | RoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatorInput | RoleCreateOrConnectWithoutCreatorInput[]
    createMany?: RoleCreateManyCreatorInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type TestimonialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type Plan_typeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput> | Plan_typeCreateWithoutUserInput[] | Plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Plan_typeCreateOrConnectWithoutUserInput | Plan_typeCreateOrConnectWithoutUserInput[]
    createMany?: Plan_typeCreateManyUserInputEnvelope
    connect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type Notification_settingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput> | Notification_settingsCreateWithoutUserInput[] | Notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Notification_settingsCreateOrConnectWithoutUserInput | Notification_settingsCreateOrConnectWithoutUserInput[]
    upsert?: Notification_settingsUpsertWithWhereUniqueWithoutUserInput | Notification_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Notification_settingsCreateManyUserInputEnvelope
    set?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    disconnect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    delete?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    connect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    update?: Notification_settingsUpdateWithWhereUniqueWithoutUserInput | Notification_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Notification_settingsUpdateManyWithWhereWithoutUserInput | Notification_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Notification_settingsScalarWhereInput | Notification_settingsScalarWhereInput[]
  }

  export type OrganisationUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutUserInput
    upsert?: OrganisationUpsertWithoutUserInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutUserInput, OrganisationUpdateWithoutUserInput>, OrganisationUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type Password_tokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput> | Password_tokenCreateWithoutUserInput[] | Password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Password_tokenCreateOrConnectWithoutUserInput | Password_tokenCreateOrConnectWithoutUserInput[]
    upsert?: Password_tokenUpsertWithWhereUniqueWithoutUserInput | Password_tokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Password_tokenCreateManyUserInputEnvelope
    set?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    disconnect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    delete?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    connect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    update?: Password_tokenUpdateWithWhereUniqueWithoutUserInput | Password_tokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Password_tokenUpdateManyWithWhereWithoutUserInput | Password_tokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Password_tokenScalarWhereInput | Password_tokenScalarWhereInput[]
  }

  export type Privacy_settingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput> | Privacy_settingsCreateWithoutUserInput[] | Privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Privacy_settingsCreateOrConnectWithoutUserInput | Privacy_settingsCreateOrConnectWithoutUserInput[]
    upsert?: Privacy_settingsUpsertWithWhereUniqueWithoutUserInput | Privacy_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Privacy_settingsCreateManyUserInputEnvelope
    set?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    disconnect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    delete?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    connect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    update?: Privacy_settingsUpdateWithWhereUniqueWithoutUserInput | Privacy_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Privacy_settingsUpdateManyWithWhereWithoutUserInput | Privacy_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Privacy_settingsScalarWhereInput | Privacy_settingsScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput> | RoleCreateWithoutCreatorInput[] | RoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatorInput | RoleCreateOrConnectWithoutCreatorInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatorInput | RoleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RoleCreateManyCreatorInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatorInput | RoleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatorInput | RoleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TestimonialUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type Plan_typeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput> | Plan_typeCreateWithoutUserInput[] | Plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Plan_typeCreateOrConnectWithoutUserInput | Plan_typeCreateOrConnectWithoutUserInput[]
    upsert?: Plan_typeUpsertWithWhereUniqueWithoutUserInput | Plan_typeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Plan_typeCreateManyUserInputEnvelope
    set?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    disconnect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    delete?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    connect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    update?: Plan_typeUpdateWithWhereUniqueWithoutUserInput | Plan_typeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Plan_typeUpdateManyWithWhereWithoutUserInput | Plan_typeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Plan_typeScalarWhereInput | Plan_typeScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type Notification_settingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput> | Notification_settingsCreateWithoutUserInput[] | Notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Notification_settingsCreateOrConnectWithoutUserInput | Notification_settingsCreateOrConnectWithoutUserInput[]
    upsert?: Notification_settingsUpsertWithWhereUniqueWithoutUserInput | Notification_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Notification_settingsCreateManyUserInputEnvelope
    set?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    disconnect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    delete?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    connect?: Notification_settingsWhereUniqueInput | Notification_settingsWhereUniqueInput[]
    update?: Notification_settingsUpdateWithWhereUniqueWithoutUserInput | Notification_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Notification_settingsUpdateManyWithWhereWithoutUserInput | Notification_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Notification_settingsScalarWhereInput | Notification_settingsScalarWhereInput[]
  }

  export type OrganisationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutUserInput
    upsert?: OrganisationUpsertWithoutUserInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutUserInput, OrganisationUpdateWithoutUserInput>, OrganisationUncheckedUpdateWithoutUserInput>
  }

  export type OtpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type Password_tokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput> | Password_tokenCreateWithoutUserInput[] | Password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Password_tokenCreateOrConnectWithoutUserInput | Password_tokenCreateOrConnectWithoutUserInput[]
    upsert?: Password_tokenUpsertWithWhereUniqueWithoutUserInput | Password_tokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Password_tokenCreateManyUserInputEnvelope
    set?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    disconnect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    delete?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    connect?: Password_tokenWhereUniqueInput | Password_tokenWhereUniqueInput[]
    update?: Password_tokenUpdateWithWhereUniqueWithoutUserInput | Password_tokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Password_tokenUpdateManyWithWhereWithoutUserInput | Password_tokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Password_tokenScalarWhereInput | Password_tokenScalarWhereInput[]
  }

  export type Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput> | Privacy_settingsCreateWithoutUserInput[] | Privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Privacy_settingsCreateOrConnectWithoutUserInput | Privacy_settingsCreateOrConnectWithoutUserInput[]
    upsert?: Privacy_settingsUpsertWithWhereUniqueWithoutUserInput | Privacy_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Privacy_settingsCreateManyUserInputEnvelope
    set?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    disconnect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    delete?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    connect?: Privacy_settingsWhereUniqueInput | Privacy_settingsWhereUniqueInput[]
    update?: Privacy_settingsUpdateWithWhereUniqueWithoutUserInput | Privacy_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Privacy_settingsUpdateManyWithWhereWithoutUserInput | Privacy_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Privacy_settingsScalarWhereInput | Privacy_settingsScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput> | RoleCreateWithoutCreatorInput[] | RoleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutCreatorInput | RoleCreateOrConnectWithoutCreatorInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutCreatorInput | RoleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: RoleCreateManyCreatorInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutCreatorInput | RoleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutCreatorInput | RoleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput> | ServiceRequestCreateWithoutUserInput[] | ServiceRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutUserInput | ServiceRequestCreateOrConnectWithoutUserInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutUserInput | ServiceRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceRequestCreateManyUserInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutUserInput | ServiceRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutUserInput | ServiceRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type TestimonialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput> | TestimonialCreateWithoutUserInput[] | TestimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutUserInput | TestimonialCreateOrConnectWithoutUserInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutUserInput | TestimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestimonialCreateManyUserInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutUserInput | TestimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutUserInput | TestimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type Plan_typeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput> | Plan_typeCreateWithoutUserInput[] | Plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Plan_typeCreateOrConnectWithoutUserInput | Plan_typeCreateOrConnectWithoutUserInput[]
    upsert?: Plan_typeUpsertWithWhereUniqueWithoutUserInput | Plan_typeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Plan_typeCreateManyUserInputEnvelope
    set?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    disconnect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    delete?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    connect?: Plan_typeWhereUniqueInput | Plan_typeWhereUniqueInput[]
    update?: Plan_typeUpdateWithWhereUniqueWithoutUserInput | Plan_typeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Plan_typeUpdateManyWithWhereWithoutUserInput | Plan_typeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Plan_typeScalarWhereInput | Plan_typeScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CaseStudyCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput> | CaseStudyCreateWithoutOrganisationInput[] | CaseStudyUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOrganisationInput | CaseStudyCreateOrConnectWithoutOrganisationInput[]
    createMany?: CaseStudyCreateManyOrganisationInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput> | ContactCreateWithoutOrganisationInput[] | ContactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOrganisationInput | ContactCreateOrConnectWithoutOrganisationInput[]
    createMany?: ContactCreateManyOrganisationInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrganisationInput = {
    create?: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationInput
    connect?: UserWhereUniqueInput
  }

  export type CaseStudyUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput> | CaseStudyCreateWithoutOrganisationInput[] | CaseStudyUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOrganisationInput | CaseStudyCreateOrConnectWithoutOrganisationInput[]
    createMany?: CaseStudyCreateManyOrganisationInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput> | ContactCreateWithoutOrganisationInput[] | ContactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOrganisationInput | ContactCreateOrConnectWithoutOrganisationInput[]
    createMany?: ContactCreateManyOrganisationInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CaseStudyUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput> | CaseStudyCreateWithoutOrganisationInput[] | CaseStudyUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOrganisationInput | CaseStudyCreateOrConnectWithoutOrganisationInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutOrganisationInput | CaseStudyUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CaseStudyCreateManyOrganisationInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutOrganisationInput | CaseStudyUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutOrganisationInput | CaseStudyUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput> | ContactCreateWithoutOrganisationInput[] | ContactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOrganisationInput | ContactCreateOrConnectWithoutOrganisationInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutOrganisationInput | ContactUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ContactCreateManyOrganisationInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutOrganisationInput | ContactUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutOrganisationInput | ContactUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrganisationNestedInput = {
    create?: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationInput
    upsert?: UserUpsertWithoutOrganisationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganisationInput, UserUpdateWithoutOrganisationInput>, UserUncheckedUpdateWithoutOrganisationInput>
  }

  export type CaseStudyUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput> | CaseStudyCreateWithoutOrganisationInput[] | CaseStudyUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOrganisationInput | CaseStudyCreateOrConnectWithoutOrganisationInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutOrganisationInput | CaseStudyUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CaseStudyCreateManyOrganisationInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutOrganisationInput | CaseStudyUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutOrganisationInput | CaseStudyUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput> | ContactCreateWithoutOrganisationInput[] | ContactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutOrganisationInput | ContactCreateOrConnectWithoutOrganisationInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutOrganisationInput | ContactUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ContactCreateManyOrganisationInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutOrganisationInput | ContactUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutOrganisationInput | ContactUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type PlanCreateNestedManyWithoutServiceInput = {
    create?: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput> | PlanCreateWithoutServiceInput[] | PlanUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutServiceInput | PlanCreateOrConnectWithoutServiceInput[]
    createMany?: PlanCreateManyServiceInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type CaseStudyCreateNestedManyWithoutServiceInput = {
    create?: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput> | CaseStudyCreateWithoutServiceInput[] | CaseStudyUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutServiceInput | CaseStudyCreateOrConnectWithoutServiceInput[]
    createMany?: CaseStudyCreateManyServiceInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type TestimonialCreateNestedManyWithoutServiceInput = {
    create?: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput> | TestimonialCreateWithoutServiceInput[] | TestimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutServiceInput | TestimonialCreateOrConnectWithoutServiceInput[]
    createMany?: TestimonialCreateManyServiceInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type FaqCreateNestedManyWithoutServiceInput = {
    create?: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput> | FaqCreateWithoutServiceInput[] | FaqUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutServiceInput | FaqCreateOrConnectWithoutServiceInput[]
    createMany?: FaqCreateManyServiceInputEnvelope
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput> | ServiceRequestCreateWithoutServiceInput[] | ServiceRequestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutServiceInput | ServiceRequestCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRequestCreateManyServiceInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceFormCreateNestedOneWithoutServiceInput = {
    create?: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceInput
    connect?: ServiceFormWhereUniqueInput
  }

  export type PlanUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput> | PlanCreateWithoutServiceInput[] | PlanUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutServiceInput | PlanCreateOrConnectWithoutServiceInput[]
    createMany?: PlanCreateManyServiceInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type CaseStudyUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput> | CaseStudyCreateWithoutServiceInput[] | CaseStudyUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutServiceInput | CaseStudyCreateOrConnectWithoutServiceInput[]
    createMany?: CaseStudyCreateManyServiceInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type TestimonialUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput> | TestimonialCreateWithoutServiceInput[] | TestimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutServiceInput | TestimonialCreateOrConnectWithoutServiceInput[]
    createMany?: TestimonialCreateManyServiceInputEnvelope
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
  }

  export type FaqUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput> | FaqCreateWithoutServiceInput[] | FaqUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutServiceInput | FaqCreateOrConnectWithoutServiceInput[]
    createMany?: FaqCreateManyServiceInputEnvelope
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput> | ServiceRequestCreateWithoutServiceInput[] | ServiceRequestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutServiceInput | ServiceRequestCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRequestCreateManyServiceInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type ServiceFormUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceInput
    connect?: ServiceFormWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PlanUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput> | PlanCreateWithoutServiceInput[] | PlanUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutServiceInput | PlanCreateOrConnectWithoutServiceInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutServiceInput | PlanUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PlanCreateManyServiceInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutServiceInput | PlanUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutServiceInput | PlanUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type CaseStudyUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput> | CaseStudyCreateWithoutServiceInput[] | CaseStudyUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutServiceInput | CaseStudyCreateOrConnectWithoutServiceInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutServiceInput | CaseStudyUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CaseStudyCreateManyServiceInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutServiceInput | CaseStudyUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutServiceInput | CaseStudyUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type TestimonialUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput> | TestimonialCreateWithoutServiceInput[] | TestimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutServiceInput | TestimonialCreateOrConnectWithoutServiceInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutServiceInput | TestimonialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TestimonialCreateManyServiceInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutServiceInput | TestimonialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutServiceInput | TestimonialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type FaqUpdateManyWithoutServiceNestedInput = {
    create?: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput> | FaqCreateWithoutServiceInput[] | FaqUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutServiceInput | FaqCreateOrConnectWithoutServiceInput[]
    upsert?: FaqUpsertWithWhereUniqueWithoutServiceInput | FaqUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: FaqCreateManyServiceInputEnvelope
    set?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    disconnect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    delete?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    update?: FaqUpdateWithWhereUniqueWithoutServiceInput | FaqUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: FaqUpdateManyWithWhereWithoutServiceInput | FaqUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: FaqScalarWhereInput | FaqScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput> | ServiceRequestCreateWithoutServiceInput[] | ServiceRequestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutServiceInput | ServiceRequestCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutServiceInput | ServiceRequestUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRequestCreateManyServiceInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutServiceInput | ServiceRequestUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutServiceInput | ServiceRequestUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceFormUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceInput
    upsert?: ServiceFormUpsertWithoutServiceInput
    disconnect?: ServiceFormWhereInput | boolean
    delete?: ServiceFormWhereInput | boolean
    connect?: ServiceFormWhereUniqueInput
    update?: XOR<XOR<ServiceFormUpdateToOneWithWhereWithoutServiceInput, ServiceFormUpdateWithoutServiceInput>, ServiceFormUncheckedUpdateWithoutServiceInput>
  }

  export type PlanUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput> | PlanCreateWithoutServiceInput[] | PlanUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutServiceInput | PlanCreateOrConnectWithoutServiceInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutServiceInput | PlanUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PlanCreateManyServiceInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutServiceInput | PlanUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutServiceInput | PlanUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type CaseStudyUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput> | CaseStudyCreateWithoutServiceInput[] | CaseStudyUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutServiceInput | CaseStudyCreateOrConnectWithoutServiceInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutServiceInput | CaseStudyUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CaseStudyCreateManyServiceInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutServiceInput | CaseStudyUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutServiceInput | CaseStudyUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type TestimonialUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput> | TestimonialCreateWithoutServiceInput[] | TestimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TestimonialCreateOrConnectWithoutServiceInput | TestimonialCreateOrConnectWithoutServiceInput[]
    upsert?: TestimonialUpsertWithWhereUniqueWithoutServiceInput | TestimonialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TestimonialCreateManyServiceInputEnvelope
    set?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    disconnect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    delete?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    connect?: TestimonialWhereUniqueInput | TestimonialWhereUniqueInput[]
    update?: TestimonialUpdateWithWhereUniqueWithoutServiceInput | TestimonialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TestimonialUpdateManyWithWhereWithoutServiceInput | TestimonialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
  }

  export type FaqUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput> | FaqCreateWithoutServiceInput[] | FaqUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutServiceInput | FaqCreateOrConnectWithoutServiceInput[]
    upsert?: FaqUpsertWithWhereUniqueWithoutServiceInput | FaqUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: FaqCreateManyServiceInputEnvelope
    set?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    disconnect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    delete?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    update?: FaqUpdateWithWhereUniqueWithoutServiceInput | FaqUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: FaqUpdateManyWithWhereWithoutServiceInput | FaqUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: FaqScalarWhereInput | FaqScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput> | ServiceRequestCreateWithoutServiceInput[] | ServiceRequestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutServiceInput | ServiceRequestCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutServiceInput | ServiceRequestUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRequestCreateManyServiceInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutServiceInput | ServiceRequestUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutServiceInput | ServiceRequestUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type ServiceFormUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutServiceInput
    upsert?: ServiceFormUpsertWithoutServiceInput
    disconnect?: ServiceFormWhereInput | boolean
    delete?: ServiceFormWhereInput | boolean
    connect?: ServiceFormWhereUniqueInput
    update?: XOR<XOR<ServiceFormUpdateToOneWithWhereWithoutServiceInput, ServiceFormUpdateWithoutServiceInput>, ServiceFormUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceCreateNestedOneWithoutFormInput = {
    create?: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutFormNestedInput = {
    create?: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFormInput
    upsert?: ServiceUpsertWithoutFormInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutFormInput, ServiceUpdateWithoutFormInput>, ServiceUncheckedUpdateWithoutFormInput>
  }

  export type ServiceCreateNestedOneWithoutPlansInput = {
    create?: XOR<ServiceCreateWithoutPlansInput, ServiceUncheckedCreateWithoutPlansInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPlansInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceRequestCreateNestedManyWithoutPlanInput = {
    create?: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput> | ServiceRequestCreateWithoutPlanInput[] | ServiceRequestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPlanInput | ServiceRequestCreateOrConnectWithoutPlanInput[]
    createMany?: ServiceRequestCreateManyPlanInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type Plan_typeCreateNestedOneWithoutPlansInput = {
    create?: XOR<Plan_typeCreateWithoutPlansInput, Plan_typeUncheckedCreateWithoutPlansInput>
    connectOrCreate?: Plan_typeCreateOrConnectWithoutPlansInput
    connect?: Plan_typeWhereUniqueInput
  }

  export type Billing_cycleCreateNestedOneWithoutPlansInput = {
    create?: XOR<Billing_cycleCreateWithoutPlansInput, Billing_cycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: Billing_cycleCreateOrConnectWithoutPlansInput
    connect?: Billing_cycleWhereUniqueInput
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput> | ServiceRequestCreateWithoutPlanInput[] | ServiceRequestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPlanInput | ServiceRequestCreateOrConnectWithoutPlanInput[]
    createMany?: ServiceRequestCreateManyPlanInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<ServiceCreateWithoutPlansInput, ServiceUncheckedCreateWithoutPlansInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPlansInput
    upsert?: ServiceUpsertWithoutPlansInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPlansInput, ServiceUpdateWithoutPlansInput>, ServiceUncheckedUpdateWithoutPlansInput>
  }

  export type ServiceRequestUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput> | ServiceRequestCreateWithoutPlanInput[] | ServiceRequestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPlanInput | ServiceRequestCreateOrConnectWithoutPlanInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutPlanInput | ServiceRequestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ServiceRequestCreateManyPlanInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutPlanInput | ServiceRequestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutPlanInput | ServiceRequestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type Plan_typeUpdateOneWithoutPlansNestedInput = {
    create?: XOR<Plan_typeCreateWithoutPlansInput, Plan_typeUncheckedCreateWithoutPlansInput>
    connectOrCreate?: Plan_typeCreateOrConnectWithoutPlansInput
    upsert?: Plan_typeUpsertWithoutPlansInput
    disconnect?: Plan_typeWhereInput | boolean
    delete?: Plan_typeWhereInput | boolean
    connect?: Plan_typeWhereUniqueInput
    update?: XOR<XOR<Plan_typeUpdateToOneWithWhereWithoutPlansInput, Plan_typeUpdateWithoutPlansInput>, Plan_typeUncheckedUpdateWithoutPlansInput>
  }

  export type Billing_cycleUpdateOneWithoutPlansNestedInput = {
    create?: XOR<Billing_cycleCreateWithoutPlansInput, Billing_cycleUncheckedCreateWithoutPlansInput>
    connectOrCreate?: Billing_cycleCreateOrConnectWithoutPlansInput
    upsert?: Billing_cycleUpsertWithoutPlansInput
    disconnect?: Billing_cycleWhereInput | boolean
    delete?: Billing_cycleWhereInput | boolean
    connect?: Billing_cycleWhereUniqueInput
    update?: XOR<XOR<Billing_cycleUpdateToOneWithWhereWithoutPlansInput, Billing_cycleUpdateWithoutPlansInput>, Billing_cycleUncheckedUpdateWithoutPlansInput>
  }

  export type ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput> | ServiceRequestCreateWithoutPlanInput[] | ServiceRequestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPlanInput | ServiceRequestCreateOrConnectWithoutPlanInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutPlanInput | ServiceRequestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ServiceRequestCreateManyPlanInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutPlanInput | ServiceRequestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutPlanInput | ServiceRequestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceRequestCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ServiceRequestCreateWithoutInvoiceInput, ServiceRequestUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutInvoiceInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    upsert?: UserUpsertWithoutInvoiceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceInput, UserUpdateWithoutInvoiceInput>, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type ServiceRequestUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutInvoiceInput, ServiceRequestUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutInvoiceInput
    upsert?: ServiceRequestUpsertWithoutInvoiceInput
    disconnect?: ServiceRequestWhereInput | boolean
    delete?: ServiceRequestWhereInput | boolean
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutInvoiceInput, ServiceRequestUpdateWithoutInvoiceInput>, ServiceRequestUncheckedUpdateWithoutInvoiceInput>
  }

  export type ServiceCreateNestedOneWithoutCaseStudiesInput = {
    create?: XOR<ServiceCreateWithoutCaseStudiesInput, ServiceUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCaseStudiesInput
    connect?: ServiceWhereUniqueInput
  }

  export type OrganisationCreateNestedOneWithoutCaseStudiesInput = {
    create?: XOR<OrganisationCreateWithoutCaseStudiesInput, OrganisationUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCaseStudiesInput
    connect?: OrganisationWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutCaseStudiesNestedInput = {
    create?: XOR<ServiceCreateWithoutCaseStudiesInput, ServiceUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCaseStudiesInput
    upsert?: ServiceUpsertWithoutCaseStudiesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutCaseStudiesInput, ServiceUpdateWithoutCaseStudiesInput>, ServiceUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type OrganisationUpdateOneWithoutCaseStudiesNestedInput = {
    create?: XOR<OrganisationCreateWithoutCaseStudiesInput, OrganisationUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCaseStudiesInput
    upsert?: OrganisationUpsertWithoutCaseStudiesInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutCaseStudiesInput, OrganisationUpdateWithoutCaseStudiesInput>, OrganisationUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type ServiceCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<ServiceCreateWithoutTestimonialsInput, ServiceUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTestimonialsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestimonialsInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<ServiceCreateWithoutTestimonialsInput, ServiceUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTestimonialsInput
    upsert?: ServiceUpsertWithoutTestimonialsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutTestimonialsInput, ServiceUpdateWithoutTestimonialsInput>, ServiceUncheckedUpdateWithoutTestimonialsInput>
  }

  export type UserUpdateOneRequiredWithoutTestimonialsNestedInput = {
    create?: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestimonialsInput
    upsert?: UserUpsertWithoutTestimonialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestimonialsInput, UserUpdateWithoutTestimonialsInput>, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type ServiceCreateNestedOneWithoutFaqsInput = {
    create?: XOR<ServiceCreateWithoutFaqsInput, ServiceUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFaqsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutFaqsNestedInput = {
    create?: XOR<ServiceCreateWithoutFaqsInput, ServiceUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutFaqsInput
    upsert?: ServiceUpsertWithoutFaqsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutFaqsInput, ServiceUpdateWithoutFaqsInput>, ServiceUncheckedUpdateWithoutFaqsInput>
  }

  export type UserCreateNestedOneWithoutService_requestsInput = {
    create?: XOR<UserCreateWithoutService_requestsInput, UserUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutService_requestsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutService_requestsInput = {
    create?: XOR<ServiceCreateWithoutService_requestsInput, ServiceUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutService_requestsInput
    connect?: ServiceWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutService_requestInput = {
    create?: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutService_requestInput
    connect?: InvoiceWhereUniqueInput
  }

  export type MilestoneCreateNestedManyWithoutService_requestInput = {
    create?: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput> | MilestoneCreateWithoutService_requestInput[] | MilestoneUncheckedCreateWithoutService_requestInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutService_requestInput | MilestoneCreateOrConnectWithoutService_requestInput[]
    createMany?: MilestoneCreateManyService_requestInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type PlanCreateNestedOneWithoutService_requestsInput = {
    create?: XOR<PlanCreateWithoutService_requestsInput, PlanUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutService_requestsInput
    connect?: PlanWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutService_requestInput = {
    create?: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutService_requestInput
    connect?: ConversationWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedOneWithoutService_requestInput = {
    create?: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutService_requestInput
    connect?: InvoiceWhereUniqueInput
  }

  export type MilestoneUncheckedCreateNestedManyWithoutService_requestInput = {
    create?: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput> | MilestoneCreateWithoutService_requestInput[] | MilestoneUncheckedCreateWithoutService_requestInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutService_requestInput | MilestoneCreateOrConnectWithoutService_requestInput[]
    createMany?: MilestoneCreateManyService_requestInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedOneWithoutService_requestInput = {
    create?: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutService_requestInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumServiceRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceRequestStatus
  }

  export type UserUpdateOneRequiredWithoutService_requestsNestedInput = {
    create?: XOR<UserCreateWithoutService_requestsInput, UserUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutService_requestsInput
    upsert?: UserUpsertWithoutService_requestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutService_requestsInput, UserUpdateWithoutService_requestsInput>, UserUncheckedUpdateWithoutService_requestsInput>
  }

  export type ServiceUpdateOneRequiredWithoutService_requestsNestedInput = {
    create?: XOR<ServiceCreateWithoutService_requestsInput, ServiceUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutService_requestsInput
    upsert?: ServiceUpsertWithoutService_requestsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutService_requestsInput, ServiceUpdateWithoutService_requestsInput>, ServiceUncheckedUpdateWithoutService_requestsInput>
  }

  export type InvoiceUpdateOneWithoutService_requestNestedInput = {
    create?: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutService_requestInput
    upsert?: InvoiceUpsertWithoutService_requestInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutService_requestInput, InvoiceUpdateWithoutService_requestInput>, InvoiceUncheckedUpdateWithoutService_requestInput>
  }

  export type MilestoneUpdateManyWithoutService_requestNestedInput = {
    create?: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput> | MilestoneCreateWithoutService_requestInput[] | MilestoneUncheckedCreateWithoutService_requestInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutService_requestInput | MilestoneCreateOrConnectWithoutService_requestInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutService_requestInput | MilestoneUpsertWithWhereUniqueWithoutService_requestInput[]
    createMany?: MilestoneCreateManyService_requestInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutService_requestInput | MilestoneUpdateWithWhereUniqueWithoutService_requestInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutService_requestInput | MilestoneUpdateManyWithWhereWithoutService_requestInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type PlanUpdateOneWithoutService_requestsNestedInput = {
    create?: XOR<PlanCreateWithoutService_requestsInput, PlanUncheckedCreateWithoutService_requestsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutService_requestsInput
    upsert?: PlanUpsertWithoutService_requestsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutService_requestsInput, PlanUpdateWithoutService_requestsInput>, PlanUncheckedUpdateWithoutService_requestsInput>
  }

  export type ConversationUpdateOneWithoutService_requestNestedInput = {
    create?: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutService_requestInput
    upsert?: ConversationUpsertWithoutService_requestInput
    disconnect?: ConversationWhereInput | boolean
    delete?: ConversationWhereInput | boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutService_requestInput, ConversationUpdateWithoutService_requestInput>, ConversationUncheckedUpdateWithoutService_requestInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutService_requestNestedInput = {
    create?: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutService_requestInput
    upsert?: InvoiceUpsertWithoutService_requestInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutService_requestInput, InvoiceUpdateWithoutService_requestInput>, InvoiceUncheckedUpdateWithoutService_requestInput>
  }

  export type MilestoneUncheckedUpdateManyWithoutService_requestNestedInput = {
    create?: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput> | MilestoneCreateWithoutService_requestInput[] | MilestoneUncheckedCreateWithoutService_requestInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutService_requestInput | MilestoneCreateOrConnectWithoutService_requestInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutService_requestInput | MilestoneUpsertWithWhereUniqueWithoutService_requestInput[]
    createMany?: MilestoneCreateManyService_requestInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutService_requestInput | MilestoneUpdateWithWhereUniqueWithoutService_requestInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutService_requestInput | MilestoneUpdateManyWithWhereWithoutService_requestInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateOneWithoutService_requestNestedInput = {
    create?: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutService_requestInput
    upsert?: ConversationUpsertWithoutService_requestInput
    disconnect?: ConversationWhereInput | boolean
    delete?: ConversationWhereInput | boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutService_requestInput, ConversationUpdateWithoutService_requestInput>, ConversationUncheckedUpdateWithoutService_requestInput>
  }

  export type ServiceRequestCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ServiceRequestCreateWithoutMilestonesInput, ServiceRequestUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMilestonesInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type EnumMilestoneStatusFieldUpdateOperationsInput = {
    set?: $Enums.MilestoneStatus
  }

  export type ServiceRequestUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutMilestonesInput, ServiceRequestUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutMilestonesInput
    upsert?: ServiceRequestUpsertWithoutMilestonesInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutMilestonesInput, ServiceRequestUpdateWithoutMilestonesInput>, ServiceRequestUncheckedUpdateWithoutMilestonesInput>
  }

  export type OrganisationCreateNestedOneWithoutContactsInput = {
    create?: XOR<OrganisationCreateWithoutContactsInput, OrganisationUncheckedCreateWithoutContactsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutContactsInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<OrganisationCreateWithoutContactsInput, OrganisationUncheckedCreateWithoutContactsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutContactsInput
    upsert?: OrganisationUpsertWithoutContactsInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutContactsInput, OrganisationUpdateWithoutContactsInput>, OrganisationUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutConversationInput = {
    create?: XOR<ServiceRequestCreateWithoutConversationInput, ServiceRequestUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutConversationInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ServiceRequestUpdateOneRequiredWithoutConversationNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutConversationInput, ServiceRequestUncheckedCreateWithoutConversationInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutConversationInput
    upsert?: ServiceRequestUpsertWithoutConversationInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutConversationInput, ServiceRequestUpdateWithoutConversationInput>, ServiceRequestUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutPassword_tokensInput = {
    create?: XOR<UserCreateWithoutPassword_tokensInput, UserUncheckedCreateWithoutPassword_tokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassword_tokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPassword_tokensNestedInput = {
    create?: XOR<UserCreateWithoutPassword_tokensInput, UserUncheckedCreateWithoutPassword_tokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassword_tokensInput
    upsert?: UserUpsertWithoutPassword_tokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPassword_tokensInput, UserUpdateWithoutPassword_tokensInput>, UserUncheckedUpdateWithoutPassword_tokensInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPrivacy_settingsInput = {
    create?: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacy_settingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPrivacy_settingsNestedInput = {
    create?: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrivacy_settingsInput
    upsert?: UserUpsertWithoutPrivacy_settingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrivacy_settingsInput, UserUpdateWithoutPrivacy_settingsInput>, UserUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type UserCreateNestedOneWithoutNotification_settingsInput = {
    create?: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_settingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotification_settingsNestedInput = {
    create?: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_settingsInput
    upsert?: UserUpsertWithoutNotification_settingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotification_settingsInput, UserUpdateWithoutNotification_settingsInput>, UserUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type UserCreateNestedOneWithoutPlan_typesInput = {
    create?: XOR<UserCreateWithoutPlan_typesInput, UserUncheckedCreateWithoutPlan_typesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlan_typesInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedManyWithoutPlan_typeInput = {
    create?: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput> | PlanCreateWithoutPlan_typeInput[] | PlanUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutPlan_typeInput | PlanCreateOrConnectWithoutPlan_typeInput[]
    createMany?: PlanCreateManyPlan_typeInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutPlan_typeInput = {
    create?: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput> | PlanCreateWithoutPlan_typeInput[] | PlanUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutPlan_typeInput | PlanCreateOrConnectWithoutPlan_typeInput[]
    createMany?: PlanCreateManyPlan_typeInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPlan_typesNestedInput = {
    create?: XOR<UserCreateWithoutPlan_typesInput, UserUncheckedCreateWithoutPlan_typesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlan_typesInput
    upsert?: UserUpsertWithoutPlan_typesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlan_typesInput, UserUpdateWithoutPlan_typesInput>, UserUncheckedUpdateWithoutPlan_typesInput>
  }

  export type PlanUpdateManyWithoutPlan_typeNestedInput = {
    create?: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput> | PlanCreateWithoutPlan_typeInput[] | PlanUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutPlan_typeInput | PlanCreateOrConnectWithoutPlan_typeInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutPlan_typeInput | PlanUpsertWithWhereUniqueWithoutPlan_typeInput[]
    createMany?: PlanCreateManyPlan_typeInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutPlan_typeInput | PlanUpdateWithWhereUniqueWithoutPlan_typeInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutPlan_typeInput | PlanUpdateManyWithWhereWithoutPlan_typeInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutPlan_typeNestedInput = {
    create?: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput> | PlanCreateWithoutPlan_typeInput[] | PlanUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutPlan_typeInput | PlanCreateOrConnectWithoutPlan_typeInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutPlan_typeInput | PlanUpsertWithWhereUniqueWithoutPlan_typeInput[]
    createMany?: PlanCreateManyPlan_typeInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutPlan_typeInput | PlanUpdateWithWhereUniqueWithoutPlan_typeInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutPlan_typeInput | PlanUpdateManyWithWhereWithoutPlan_typeInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlanCreateNestedManyWithoutBilling_cycleInput = {
    create?: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput> | PlanCreateWithoutBilling_cycleInput[] | PlanUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBilling_cycleInput | PlanCreateOrConnectWithoutBilling_cycleInput[]
    createMany?: PlanCreateManyBilling_cycleInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutBilling_cycleInput = {
    create?: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput> | PlanCreateWithoutBilling_cycleInput[] | PlanUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBilling_cycleInput | PlanCreateOrConnectWithoutBilling_cycleInput[]
    createMany?: PlanCreateManyBilling_cycleInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type PlanUpdateManyWithoutBilling_cycleNestedInput = {
    create?: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput> | PlanCreateWithoutBilling_cycleInput[] | PlanUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBilling_cycleInput | PlanCreateOrConnectWithoutBilling_cycleInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutBilling_cycleInput | PlanUpsertWithWhereUniqueWithoutBilling_cycleInput[]
    createMany?: PlanCreateManyBilling_cycleInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutBilling_cycleInput | PlanUpdateWithWhereUniqueWithoutBilling_cycleInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutBilling_cycleInput | PlanUpdateManyWithWhereWithoutBilling_cycleInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutBilling_cycleNestedInput = {
    create?: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput> | PlanCreateWithoutBilling_cycleInput[] | PlanUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBilling_cycleInput | PlanCreateOrConnectWithoutBilling_cycleInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutBilling_cycleInput | PlanUpsertWithWhereUniqueWithoutBilling_cycleInput[]
    createMany?: PlanCreateManyBilling_cycleInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutBilling_cycleInput | PlanUpdateWithWhereUniqueWithoutBilling_cycleInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutBilling_cycleInput | PlanUpdateManyWithWhereWithoutBilling_cycleInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutCreated_rolesInput = {
    create?: XOR<UserCreateWithoutCreated_rolesInput, UserUncheckedCreateWithoutCreated_rolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_rolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreated_rolesNestedInput = {
    create?: XOR<UserCreateWithoutCreated_rolesInput, UserUncheckedCreateWithoutCreated_rolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreated_rolesInput
    upsert?: UserUpsertWithoutCreated_rolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreated_rolesInput, UserUpdateWithoutCreated_rolesInput>, UserUncheckedUpdateWithoutCreated_rolesInput>
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumServiceRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[]
    notIn?: $Enums.ServiceRequestStatus[]
    not?: NestedEnumServiceRequestStatusFilter<$PrismaModel> | $Enums.ServiceRequestStatus
  }

  export type NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceRequestStatus | EnumServiceRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceRequestStatus[]
    notIn?: $Enums.ServiceRequestStatus[]
    not?: NestedEnumServiceRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[]
    notIn?: $Enums.MilestoneStatus[]
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[]
    notIn?: $Enums.MilestoneStatus[]
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    text: string
    created_at?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversation_id: string
    text: string
    created_at?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Notification_settingsCreateWithoutUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type Notification_settingsUncheckedCreateWithoutUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type Notification_settingsCreateOrConnectWithoutUserInput = {
    where: Notification_settingsWhereUniqueInput
    create: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput>
  }

  export type Notification_settingsCreateManyUserInputEnvelope = {
    data: Notification_settingsCreateManyUserInput | Notification_settingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyCreateNestedManyWithoutOrganisationInput
    contacts?: ContactCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOrganisationInput
    contacts?: ContactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutUserInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
  }

  export type OtpCreateWithoutUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpCreateManyUserInputEnvelope = {
    data: OtpCreateManyUserInput | OtpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Password_tokenCreateWithoutUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type Password_tokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type Password_tokenCreateOrConnectWithoutUserInput = {
    where: Password_tokenWhereUniqueInput
    create: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput>
  }

  export type Password_tokenCreateManyUserInputEnvelope = {
    data: Password_tokenCreateManyUserInput | Password_tokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Privacy_settingsCreateWithoutUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type Privacy_settingsUncheckedCreateWithoutUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type Privacy_settingsCreateOrConnectWithoutUserInput = {
    where: Privacy_settingsWhereUniqueInput
    create: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput>
  }

  export type Privacy_settingsCreateManyUserInputEnvelope = {
    data: Privacy_settingsCreateManyUserInput | Privacy_settingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutCreatorInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
  }

  export type RoleCreateManyCreatorInputEnvelope = {
    data: RoleCreateManyCreatorInput | RoleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutUserInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceCreateManyUserInputEnvelope = {
    data: ServiceCreateManyUserInput | ServiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutUserInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    service: ServiceCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateWithoutUserInput = {
    id?: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestCreateManyUserInputEnvelope = {
    data: ServiceRequestCreateManyUserInput | ServiceRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan_id: string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TestimonialCreateWithoutUserInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service: ServiceCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateWithoutUserInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service_id: string
  }

  export type TestimonialCreateOrConnectWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialCreateManyUserInputEnvelope = {
    data: TestimonialCreateManyUserInput | TestimonialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type Plan_typeCreateWithoutUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutPlan_typeInput
  }

  export type Plan_typeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutPlan_typeInput
  }

  export type Plan_typeCreateOrConnectWithoutUserInput = {
    where: Plan_typeWhereUniqueInput
    create: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput>
  }

  export type Plan_typeCreateManyUserInputEnvelope = {
    data: Plan_typeCreateManyUserInput | Plan_typeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    creator?: UserCreateNestedOneWithoutCreated_rolesInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    service_request?: ServiceRequestCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    service_request_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversation_id?: StringFilter<"Message"> | string
    sender_id?: StringFilter<"Message"> | string
    text?: StringFilter<"Message"> | string
    created_at?: DateTimeFilter<"Message"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    activity?: StringFilter<"Notification"> | string
    completed_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user_id?: StringFilter<"Notification"> | string
  }

  export type Notification_settingsUpsertWithWhereUniqueWithoutUserInput = {
    where: Notification_settingsWhereUniqueInput
    update: XOR<Notification_settingsUpdateWithoutUserInput, Notification_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<Notification_settingsCreateWithoutUserInput, Notification_settingsUncheckedCreateWithoutUserInput>
  }

  export type Notification_settingsUpdateWithWhereUniqueWithoutUserInput = {
    where: Notification_settingsWhereUniqueInput
    data: XOR<Notification_settingsUpdateWithoutUserInput, Notification_settingsUncheckedUpdateWithoutUserInput>
  }

  export type Notification_settingsUpdateManyWithWhereWithoutUserInput = {
    where: Notification_settingsScalarWhereInput
    data: XOR<Notification_settingsUpdateManyMutationInput, Notification_settingsUncheckedUpdateManyWithoutUserInput>
  }

  export type Notification_settingsScalarWhereInput = {
    AND?: Notification_settingsScalarWhereInput | Notification_settingsScalarWhereInput[]
    OR?: Notification_settingsScalarWhereInput[]
    NOT?: Notification_settingsScalarWhereInput | Notification_settingsScalarWhereInput[]
    id?: StringFilter<"Notification_settings"> | string
    alerts?: BoolFilter<"Notification_settings"> | boolean
    messages?: BoolFilter<"Notification_settings"> | boolean
    updates?: BoolFilter<"Notification_settings"> | boolean
    billing_alerts?: BoolFilter<"Notification_settings"> | boolean
    email?: BoolFilter<"Notification_settings"> | boolean
    in_app?: BoolFilter<"Notification_settings"> | boolean
    user_id?: StringFilter<"Notification_settings"> | string
  }

  export type OrganisationUpsertWithoutUserInput = {
    update: XOR<OrganisationUpdateWithoutUserInput, OrganisationUncheckedUpdateWithoutUserInput>
    create: XOR<OrganisationCreateWithoutUserInput, OrganisationUncheckedCreateWithoutUserInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutUserInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutUserInput, OrganisationUncheckedUpdateWithoutUserInput>
  }

  export type OrganisationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUpdateManyWithoutOrganisationNestedInput
    contacts?: ContactUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOrganisationNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OtpUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateManyWithWhereWithoutUserInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpScalarWhereInput = {
    AND?: OtpScalarWhereInput | OtpScalarWhereInput[]
    OR?: OtpScalarWhereInput[]
    NOT?: OtpScalarWhereInput | OtpScalarWhereInput[]
    id?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expires_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"Otp"> | Date | string | null
    user_id?: StringFilter<"Otp"> | string
  }

  export type Password_tokenUpsertWithWhereUniqueWithoutUserInput = {
    where: Password_tokenWhereUniqueInput
    update: XOR<Password_tokenUpdateWithoutUserInput, Password_tokenUncheckedUpdateWithoutUserInput>
    create: XOR<Password_tokenCreateWithoutUserInput, Password_tokenUncheckedCreateWithoutUserInput>
  }

  export type Password_tokenUpdateWithWhereUniqueWithoutUserInput = {
    where: Password_tokenWhereUniqueInput
    data: XOR<Password_tokenUpdateWithoutUserInput, Password_tokenUncheckedUpdateWithoutUserInput>
  }

  export type Password_tokenUpdateManyWithWhereWithoutUserInput = {
    where: Password_tokenScalarWhereInput
    data: XOR<Password_tokenUpdateManyMutationInput, Password_tokenUncheckedUpdateManyWithoutUserInput>
  }

  export type Password_tokenScalarWhereInput = {
    AND?: Password_tokenScalarWhereInput | Password_tokenScalarWhereInput[]
    OR?: Password_tokenScalarWhereInput[]
    NOT?: Password_tokenScalarWhereInput | Password_tokenScalarWhereInput[]
    id?: StringFilter<"Password_token"> | string
    token?: StringFilter<"Password_token"> | string
    created_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"Password_token"> | Date | string | null
    user_id?: StringFilter<"Password_token"> | string
  }

  export type Privacy_settingsUpsertWithWhereUniqueWithoutUserInput = {
    where: Privacy_settingsWhereUniqueInput
    update: XOR<Privacy_settingsUpdateWithoutUserInput, Privacy_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<Privacy_settingsCreateWithoutUserInput, Privacy_settingsUncheckedCreateWithoutUserInput>
  }

  export type Privacy_settingsUpdateWithWhereUniqueWithoutUserInput = {
    where: Privacy_settingsWhereUniqueInput
    data: XOR<Privacy_settingsUpdateWithoutUserInput, Privacy_settingsUncheckedUpdateWithoutUserInput>
  }

  export type Privacy_settingsUpdateManyWithWhereWithoutUserInput = {
    where: Privacy_settingsScalarWhereInput
    data: XOR<Privacy_settingsUpdateManyMutationInput, Privacy_settingsUncheckedUpdateManyWithoutUserInput>
  }

  export type Privacy_settingsScalarWhereInput = {
    AND?: Privacy_settingsScalarWhereInput | Privacy_settingsScalarWhereInput[]
    OR?: Privacy_settingsScalarWhereInput[]
    NOT?: Privacy_settingsScalarWhereInput | Privacy_settingsScalarWhereInput[]
    id?: StringFilter<"Privacy_settings"> | string
    ads?: BoolFilter<"Privacy_settings"> | boolean
    data_sharing?: BoolFilter<"Privacy_settings"> | boolean
    marketing_status?: BoolFilter<"Privacy_settings"> | boolean
    activity_status?: BoolFilter<"Privacy_settings"> | boolean
    user_id?: StringFilter<"Privacy_settings"> | string
  }

  export type RoleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutCreatorInput, RoleUncheckedUpdateWithoutCreatorInput>
    create: XOR<RoleCreateWithoutCreatorInput, RoleUncheckedCreateWithoutCreatorInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutCreatorInput, RoleUncheckedUpdateWithoutCreatorInput>
  }

  export type RoleUpdateManyWithWhereWithoutCreatorInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    title?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    created_at?: DateTimeFilter<"Role"> | Date | string
    created_by?: StringNullableFilter<"Role"> | string | null
    deleted_at?: DateTimeNullableFilter<"Role"> | Date | string | null
  }

  export type ServiceUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUserInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    title?: StringFilter<"Service"> | string
    isPublic?: BoolFilter<"Service"> | boolean
    heroHeadline?: StringNullableFilter<"Service"> | string | null
    heroParagraph?: StringNullableFilter<"Service"> | string | null
    heroImageUrl?: StringNullableFilter<"Service"> | string | null
    blueprintHeadline?: StringNullableFilter<"Service"> | string | null
    blueprintParagraph?: StringNullableFilter<"Service"> | string | null
    blueprintImageUrl?: StringNullableFilter<"Service"> | string | null
    bannerText?: StringNullableFilter<"Service"> | string | null
    admin_id?: StringFilter<"Service"> | string
    created_at?: DateTimeNullableFilter<"Service"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Service"> | Date | string | null
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceRequestCreateWithoutUserInput, ServiceRequestUncheckedCreateWithoutUserInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutUserInput, ServiceRequestUncheckedUpdateWithoutUserInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutUserInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceRequestScalarWhereInput = {
    AND?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    OR?: ServiceRequestScalarWhereInput[]
    NOT?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    id?: StringFilter<"ServiceRequest"> | string
    user_id?: StringFilter<"ServiceRequest"> | string
    service_id?: StringFilter<"ServiceRequest"> | string
    plan_name?: StringFilter<"ServiceRequest"> | string
    status?: EnumServiceRequestStatusFilter<"ServiceRequest"> | $Enums.ServiceRequestStatus
    start_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    end_date?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    formData?: JsonFilter<"ServiceRequest">
    created_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    updated_at?: DateTimeFilter<"ServiceRequest"> | Date | string
    planId?: StringNullableFilter<"ServiceRequest"> | string | null
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    start_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    status?: StringFilter<"Subscription"> | string
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
  }

  export type TestimonialUpsertWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    update: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
    create: XOR<TestimonialCreateWithoutUserInput, TestimonialUncheckedCreateWithoutUserInput>
  }

  export type TestimonialUpdateWithWhereUniqueWithoutUserInput = {
    where: TestimonialWhereUniqueInput
    data: XOR<TestimonialUpdateWithoutUserInput, TestimonialUncheckedUpdateWithoutUserInput>
  }

  export type TestimonialUpdateManyWithWhereWithoutUserInput = {
    where: TestimonialScalarWhereInput
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyWithoutUserInput>
  }

  export type TestimonialScalarWhereInput = {
    AND?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    OR?: TestimonialScalarWhereInput[]
    NOT?: TestimonialScalarWhereInput | TestimonialScalarWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    quote?: StringFilter<"Testimonial"> | string
    authorName?: StringFilter<"Testimonial"> | string
    authorTitle?: StringFilter<"Testimonial"> | string
    stars?: IntFilter<"Testimonial"> | number
    authorImageUrl?: StringNullableFilter<"Testimonial"> | string | null
    service_id?: StringFilter<"Testimonial"> | string
    user_id?: StringFilter<"Testimonial"> | string
  }

  export type Plan_typeUpsertWithWhereUniqueWithoutUserInput = {
    where: Plan_typeWhereUniqueInput
    update: XOR<Plan_typeUpdateWithoutUserInput, Plan_typeUncheckedUpdateWithoutUserInput>
    create: XOR<Plan_typeCreateWithoutUserInput, Plan_typeUncheckedCreateWithoutUserInput>
  }

  export type Plan_typeUpdateWithWhereUniqueWithoutUserInput = {
    where: Plan_typeWhereUniqueInput
    data: XOR<Plan_typeUpdateWithoutUserInput, Plan_typeUncheckedUpdateWithoutUserInput>
  }

  export type Plan_typeUpdateManyWithWhereWithoutUserInput = {
    where: Plan_typeScalarWhereInput
    data: XOR<Plan_typeUpdateManyMutationInput, Plan_typeUncheckedUpdateManyWithoutUserInput>
  }

  export type Plan_typeScalarWhereInput = {
    AND?: Plan_typeScalarWhereInput | Plan_typeScalarWhereInput[]
    OR?: Plan_typeScalarWhereInput[]
    NOT?: Plan_typeScalarWhereInput | Plan_typeScalarWhereInput[]
    id?: StringFilter<"Plan_type"> | string
    name?: StringFilter<"Plan_type"> | string
    created_at?: DateTimeFilter<"Plan_type"> | Date | string
    created_by?: StringFilter<"Plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"Plan_type"> | Date | string | null
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutCreated_rolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    user_id?: StringFilter<"Invoice"> | string
    service_request_id?: StringNullableFilter<"Invoice"> | string | null
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Invoice"> | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    payment_method?: StringNullableFilter<"Invoice"> | string | null
    payment_reference?: StringNullableFilter<"Invoice"> | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type CaseStudyCreateWithoutOrganisationInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service: ServiceCreateNestedOneWithoutCaseStudiesInput
  }

  export type CaseStudyUncheckedCreateWithoutOrganisationInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service_id: string
  }

  export type CaseStudyCreateOrConnectWithoutOrganisationInput = {
    where: CaseStudyWhereUniqueInput
    create: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput>
  }

  export type CaseStudyCreateManyOrganisationInputEnvelope = {
    data: CaseStudyCreateManyOrganisationInput | CaseStudyCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ContactUncheckedCreateWithoutOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ContactCreateOrConnectWithoutOrganisationInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput>
  }

  export type ContactCreateManyOrganisationInputEnvelope = {
    data: ContactCreateManyOrganisationInput | ContactCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganisationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganisationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganisationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
  }

  export type CaseStudyUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: CaseStudyWhereUniqueInput
    update: XOR<CaseStudyUpdateWithoutOrganisationInput, CaseStudyUncheckedUpdateWithoutOrganisationInput>
    create: XOR<CaseStudyCreateWithoutOrganisationInput, CaseStudyUncheckedCreateWithoutOrganisationInput>
  }

  export type CaseStudyUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: CaseStudyWhereUniqueInput
    data: XOR<CaseStudyUpdateWithoutOrganisationInput, CaseStudyUncheckedUpdateWithoutOrganisationInput>
  }

  export type CaseStudyUpdateManyWithWhereWithoutOrganisationInput = {
    where: CaseStudyScalarWhereInput
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type CaseStudyScalarWhereInput = {
    AND?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
    OR?: CaseStudyScalarWhereInput[]
    NOT?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
    id?: StringFilter<"CaseStudy"> | string
    title?: StringFilter<"CaseStudy"> | string
    subtitle?: StringFilter<"CaseStudy"> | string
    bannerImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    challenge?: StringNullableFilter<"CaseStudy"> | string | null
    challengeImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    solution?: StringNullableFilter<"CaseStudy"> | string | null
    solutionImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    result?: StringNullableFilter<"CaseStudy"> | string | null
    resultImageUrl?: StringNullableFilter<"CaseStudy"> | string | null
    service_id?: StringFilter<"CaseStudy"> | string
    organisationId?: StringNullableFilter<"CaseStudy"> | string | null
  }

  export type ContactUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutOrganisationInput, ContactUncheckedUpdateWithoutOrganisationInput>
    create: XOR<ContactCreateWithoutOrganisationInput, ContactUncheckedCreateWithoutOrganisationInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutOrganisationInput, ContactUncheckedUpdateWithoutOrganisationInput>
  }

  export type ContactUpdateManyWithWhereWithoutOrganisationInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    pfp_url?: StringFilter<"Contact"> | string
    organisation_id?: StringFilter<"Contact"> | string
    id_url?: JsonFilter<"Contact">
    created_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"Contact"> | Date | string | null
  }

  export type UserUpsertWithoutOrganisationInput = {
    update: XOR<UserUpdateWithoutOrganisationInput, UserUncheckedUpdateWithoutOrganisationInput>
    create: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganisationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganisationInput, UserUncheckedUpdateWithoutOrganisationInput>
  }

  export type UserUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanCreateWithoutServiceInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service_requests?: ServiceRequestCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    Plan_type?: Plan_typeCreateNestedOneWithoutPlansInput
    Billing_cycle?: Billing_cycleCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutServiceInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput>
  }

  export type PlanCreateManyServiceInputEnvelope = {
    data: PlanCreateManyServiceInput | PlanCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CaseStudyCreateWithoutServiceInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    Organisation?: OrganisationCreateNestedOneWithoutCaseStudiesInput
  }

  export type CaseStudyUncheckedCreateWithoutServiceInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    organisationId?: string | null
  }

  export type CaseStudyCreateOrConnectWithoutServiceInput = {
    where: CaseStudyWhereUniqueInput
    create: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput>
  }

  export type CaseStudyCreateManyServiceInputEnvelope = {
    data: CaseStudyCreateManyServiceInput | CaseStudyCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type TestimonialCreateWithoutServiceInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    user: UserCreateNestedOneWithoutTestimonialsInput
  }

  export type TestimonialUncheckedCreateWithoutServiceInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    user_id: string
  }

  export type TestimonialCreateOrConnectWithoutServiceInput = {
    where: TestimonialWhereUniqueInput
    create: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput>
  }

  export type TestimonialCreateManyServiceInputEnvelope = {
    data: TestimonialCreateManyServiceInput | TestimonialCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type FaqCreateWithoutServiceInput = {
    id?: string
    question: string
    answer: string
  }

  export type FaqUncheckedCreateWithoutServiceInput = {
    id?: string
    question: string
    answer: string
  }

  export type FaqCreateOrConnectWithoutServiceInput = {
    where: FaqWhereUniqueInput
    create: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput>
  }

  export type FaqCreateManyServiceInputEnvelope = {
    data: FaqCreateManyServiceInput | FaqCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutServiceInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateWithoutServiceInput = {
    id?: string
    user_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutServiceInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRequestCreateManyServiceInputEnvelope = {
    data: ServiceRequestCreateManyServiceInput | ServiceRequestCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutServicesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type ServiceFormCreateWithoutServiceInput = {
    id?: string
    formFields: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ServiceFormUncheckedCreateWithoutServiceInput = {
    id?: string
    formFields: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type ServiceFormCreateOrConnectWithoutServiceInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
  }

  export type PlanUpsertWithWhereUniqueWithoutServiceInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutServiceInput, PlanUncheckedUpdateWithoutServiceInput>
    create: XOR<PlanCreateWithoutServiceInput, PlanUncheckedCreateWithoutServiceInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutServiceInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutServiceInput, PlanUncheckedUpdateWithoutServiceInput>
  }

  export type PlanUpdateManyWithWhereWithoutServiceInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutServiceInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: StringFilter<"Plan"> | string
    priceUnit?: StringFilter<"Plan"> | string
    audience?: StringFilter<"Plan"> | string
    features?: JsonFilter<"Plan">
    service_id?: StringFilter<"Plan"> | string
    position?: IntFilter<"Plan"> | number
    plan_typeId?: StringNullableFilter<"Plan"> | string | null
    billing_cycleId?: StringNullableFilter<"Plan"> | string | null
  }

  export type CaseStudyUpsertWithWhereUniqueWithoutServiceInput = {
    where: CaseStudyWhereUniqueInput
    update: XOR<CaseStudyUpdateWithoutServiceInput, CaseStudyUncheckedUpdateWithoutServiceInput>
    create: XOR<CaseStudyCreateWithoutServiceInput, CaseStudyUncheckedCreateWithoutServiceInput>
  }

  export type CaseStudyUpdateWithWhereUniqueWithoutServiceInput = {
    where: CaseStudyWhereUniqueInput
    data: XOR<CaseStudyUpdateWithoutServiceInput, CaseStudyUncheckedUpdateWithoutServiceInput>
  }

  export type CaseStudyUpdateManyWithWhereWithoutServiceInput = {
    where: CaseStudyScalarWhereInput
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyWithoutServiceInput>
  }

  export type TestimonialUpsertWithWhereUniqueWithoutServiceInput = {
    where: TestimonialWhereUniqueInput
    update: XOR<TestimonialUpdateWithoutServiceInput, TestimonialUncheckedUpdateWithoutServiceInput>
    create: XOR<TestimonialCreateWithoutServiceInput, TestimonialUncheckedCreateWithoutServiceInput>
  }

  export type TestimonialUpdateWithWhereUniqueWithoutServiceInput = {
    where: TestimonialWhereUniqueInput
    data: XOR<TestimonialUpdateWithoutServiceInput, TestimonialUncheckedUpdateWithoutServiceInput>
  }

  export type TestimonialUpdateManyWithWhereWithoutServiceInput = {
    where: TestimonialScalarWhereInput
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyWithoutServiceInput>
  }

  export type FaqUpsertWithWhereUniqueWithoutServiceInput = {
    where: FaqWhereUniqueInput
    update: XOR<FaqUpdateWithoutServiceInput, FaqUncheckedUpdateWithoutServiceInput>
    create: XOR<FaqCreateWithoutServiceInput, FaqUncheckedCreateWithoutServiceInput>
  }

  export type FaqUpdateWithWhereUniqueWithoutServiceInput = {
    where: FaqWhereUniqueInput
    data: XOR<FaqUpdateWithoutServiceInput, FaqUncheckedUpdateWithoutServiceInput>
  }

  export type FaqUpdateManyWithWhereWithoutServiceInput = {
    where: FaqScalarWhereInput
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyWithoutServiceInput>
  }

  export type FaqScalarWhereInput = {
    AND?: FaqScalarWhereInput | FaqScalarWhereInput[]
    OR?: FaqScalarWhereInput[]
    NOT?: FaqScalarWhereInput | FaqScalarWhereInput[]
    id?: StringFilter<"Faq"> | string
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    service_id?: StringFilter<"Faq"> | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutServiceInput, ServiceRequestUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceRequestCreateWithoutServiceInput, ServiceRequestUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutServiceInput, ServiceRequestUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceFormUpsertWithoutServiceInput = {
    update: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceFormCreateWithoutServiceInput, ServiceFormUncheckedCreateWithoutServiceInput>
    where?: ServiceFormWhereInput
  }

  export type ServiceFormUpdateToOneWithWhereWithoutServiceInput = {
    where?: ServiceFormWhereInput
    data: XOR<ServiceFormUpdateWithoutServiceInput, ServiceFormUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceFormUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceFormUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    formFields?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateWithoutFormInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutFormInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutFormInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
  }

  export type ServiceUpsertWithoutFormInput = {
    update: XOR<ServiceUpdateWithoutFormInput, ServiceUncheckedUpdateWithoutFormInput>
    create: XOR<ServiceCreateWithoutFormInput, ServiceUncheckedCreateWithoutFormInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutFormInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutFormInput, ServiceUncheckedUpdateWithoutFormInput>
  }

  export type ServiceUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutPlansInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPlansInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPlansInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPlansInput, ServiceUncheckedCreateWithoutPlansInput>
  }

  export type ServiceRequestCreateWithoutPlanInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    service: ServiceCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateWithoutPlanInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutPlanInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput>
  }

  export type ServiceRequestCreateManyPlanInputEnvelope = {
    data: ServiceRequestCreateManyPlanInput | ServiceRequestCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type Plan_typeCreateWithoutPlansInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    user: UserCreateNestedOneWithoutPlan_typesInput
  }

  export type Plan_typeUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
  }

  export type Plan_typeCreateOrConnectWithoutPlansInput = {
    where: Plan_typeWhereUniqueInput
    create: XOR<Plan_typeCreateWithoutPlansInput, Plan_typeUncheckedCreateWithoutPlansInput>
  }

  export type Billing_cycleCreateWithoutPlansInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type Billing_cycleUncheckedCreateWithoutPlansInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type Billing_cycleCreateOrConnectWithoutPlansInput = {
    where: Billing_cycleWhereUniqueInput
    create: XOR<Billing_cycleCreateWithoutPlansInput, Billing_cycleUncheckedCreateWithoutPlansInput>
  }

  export type ServiceUpsertWithoutPlansInput = {
    update: XOR<ServiceUpdateWithoutPlansInput, ServiceUncheckedUpdateWithoutPlansInput>
    create: XOR<ServiceCreateWithoutPlansInput, ServiceUncheckedCreateWithoutPlansInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPlansInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPlansInput, ServiceUncheckedUpdateWithoutPlansInput>
  }

  export type ServiceUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutPlanInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutPlanInput, ServiceRequestUncheckedUpdateWithoutPlanInput>
    create: XOR<ServiceRequestCreateWithoutPlanInput, ServiceRequestUncheckedCreateWithoutPlanInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutPlanInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutPlanInput, ServiceRequestUncheckedUpdateWithoutPlanInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutPlanInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutPlanInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type Plan_typeUpsertWithoutPlansInput = {
    update: XOR<Plan_typeUpdateWithoutPlansInput, Plan_typeUncheckedUpdateWithoutPlansInput>
    create: XOR<Plan_typeCreateWithoutPlansInput, Plan_typeUncheckedCreateWithoutPlansInput>
    where?: Plan_typeWhereInput
  }

  export type Plan_typeUpdateToOneWithWhereWithoutPlansInput = {
    where?: Plan_typeWhereInput
    data: XOR<Plan_typeUpdateWithoutPlansInput, Plan_typeUncheckedUpdateWithoutPlansInput>
  }

  export type Plan_typeUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPlan_typesNestedInput
  }

  export type Plan_typeUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Billing_cycleUpsertWithoutPlansInput = {
    update: XOR<Billing_cycleUpdateWithoutPlansInput, Billing_cycleUncheckedUpdateWithoutPlansInput>
    create: XOR<Billing_cycleCreateWithoutPlansInput, Billing_cycleUncheckedCreateWithoutPlansInput>
    where?: Billing_cycleWhereInput
  }

  export type Billing_cycleUpdateToOneWithWhereWithoutPlansInput = {
    where?: Billing_cycleWhereInput
    data: XOR<Billing_cycleUpdateWithoutPlansInput, Billing_cycleUncheckedUpdateWithoutPlansInput>
  }

  export type Billing_cycleUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Billing_cycleUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutInvoiceInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutInvoiceInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type ServiceRequestCreateWithoutInvoiceInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    service: ServiceCreateNestedOneWithoutService_requestsInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateWithoutInvoiceInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutInvoiceInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutInvoiceInput, ServiceRequestUncheckedCreateWithoutInvoiceInput>
  }

  export type UserUpsertWithoutInvoiceInput = {
    update: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceRequestUpsertWithoutInvoiceInput = {
    update: XOR<ServiceRequestUpdateWithoutInvoiceInput, ServiceRequestUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ServiceRequestCreateWithoutInvoiceInput, ServiceRequestUncheckedCreateWithoutInvoiceInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutInvoiceInput, ServiceRequestUncheckedUpdateWithoutInvoiceInput>
  }

  export type ServiceRequestUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceCreateWithoutCaseStudiesInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCaseStudiesInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCaseStudiesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCaseStudiesInput, ServiceUncheckedCreateWithoutCaseStudiesInput>
  }

  export type OrganisationCreateWithoutCaseStudiesInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    contacts?: ContactCreateNestedManyWithoutOrganisationInput
    user: UserCreateNestedOneWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutCaseStudiesInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    contacts?: ContactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutCaseStudiesInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutCaseStudiesInput, OrganisationUncheckedCreateWithoutCaseStudiesInput>
  }

  export type ServiceUpsertWithoutCaseStudiesInput = {
    update: XOR<ServiceUpdateWithoutCaseStudiesInput, ServiceUncheckedUpdateWithoutCaseStudiesInput>
    create: XOR<ServiceCreateWithoutCaseStudiesInput, ServiceUncheckedCreateWithoutCaseStudiesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutCaseStudiesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutCaseStudiesInput, ServiceUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type ServiceUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type OrganisationUpsertWithoutCaseStudiesInput = {
    update: XOR<OrganisationUpdateWithoutCaseStudiesInput, OrganisationUncheckedUpdateWithoutCaseStudiesInput>
    create: XOR<OrganisationCreateWithoutCaseStudiesInput, OrganisationUncheckedCreateWithoutCaseStudiesInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutCaseStudiesInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutCaseStudiesInput, OrganisationUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type OrganisationUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: ContactUpdateManyWithoutOrganisationNestedInput
    user?: UserUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contacts?: ContactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type ServiceCreateWithoutTestimonialsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutTestimonialsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTestimonialsInput, ServiceUncheckedCreateWithoutTestimonialsInput>
  }

  export type UserCreateWithoutTestimonialsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTestimonialsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTestimonialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
  }

  export type ServiceUpsertWithoutTestimonialsInput = {
    update: XOR<ServiceUpdateWithoutTestimonialsInput, ServiceUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<ServiceCreateWithoutTestimonialsInput, ServiceUncheckedCreateWithoutTestimonialsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutTestimonialsInput, ServiceUncheckedUpdateWithoutTestimonialsInput>
  }

  export type ServiceUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type UserUpsertWithoutTestimonialsInput = {
    update: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
    create: XOR<UserCreateWithoutTestimonialsInput, UserUncheckedCreateWithoutTestimonialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestimonialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestimonialsInput, UserUncheckedUpdateWithoutTestimonialsInput>
  }

  export type UserUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTestimonialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceCreateWithoutFaqsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutFaqsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutFaqsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutFaqsInput, ServiceUncheckedCreateWithoutFaqsInput>
  }

  export type ServiceUpsertWithoutFaqsInput = {
    update: XOR<ServiceUpdateWithoutFaqsInput, ServiceUncheckedUpdateWithoutFaqsInput>
    create: XOR<ServiceCreateWithoutFaqsInput, ServiceUncheckedCreateWithoutFaqsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutFaqsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutFaqsInput, ServiceUncheckedUpdateWithoutFaqsInput>
  }

  export type ServiceUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type UserCreateWithoutService_requestsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutService_requestsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutService_requestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutService_requestsInput, UserUncheckedCreateWithoutService_requestsInput>
  }

  export type ServiceCreateWithoutService_requestsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialCreateNestedManyWithoutServiceInput
    faqs?: FaqCreateNestedManyWithoutServiceInput
    user: UserCreateNestedOneWithoutServicesInput
    form?: ServiceFormCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutService_requestsInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    admin_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    plans?: PlanUncheckedCreateNestedManyWithoutServiceInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutServiceInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutServiceInput
    faqs?: FaqUncheckedCreateNestedManyWithoutServiceInput
    form?: ServiceFormUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutService_requestsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutService_requestsInput, ServiceUncheckedCreateWithoutService_requestsInput>
  }

  export type InvoiceCreateWithoutService_requestInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutService_requestInput = {
    id?: string
    user_id: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutService_requestInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
  }

  export type MilestoneCreateWithoutService_requestInput = {
    id?: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MilestoneUncheckedCreateWithoutService_requestInput = {
    id?: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutService_requestInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput>
  }

  export type MilestoneCreateManyService_requestInputEnvelope = {
    data: MilestoneCreateManyService_requestInput | MilestoneCreateManyService_requestInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutService_requestsInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service: ServiceCreateNestedOneWithoutPlansInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    Plan_type?: Plan_typeCreateNestedOneWithoutPlansInput
    Billing_cycle?: Billing_cycleCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutService_requestsInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutService_requestsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutService_requestsInput, PlanUncheckedCreateWithoutService_requestsInput>
  }

  export type ConversationCreateWithoutService_requestInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutService_requestInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutService_requestInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
  }

  export type UserUpsertWithoutService_requestsInput = {
    update: XOR<UserUpdateWithoutService_requestsInput, UserUncheckedUpdateWithoutService_requestsInput>
    create: XOR<UserCreateWithoutService_requestsInput, UserUncheckedCreateWithoutService_requestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutService_requestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutService_requestsInput, UserUncheckedUpdateWithoutService_requestsInput>
  }

  export type UserUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutService_requestsInput = {
    update: XOR<ServiceUpdateWithoutService_requestsInput, ServiceUncheckedUpdateWithoutService_requestsInput>
    create: XOR<ServiceCreateWithoutService_requestsInput, ServiceUncheckedCreateWithoutService_requestsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutService_requestsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutService_requestsInput, ServiceUncheckedUpdateWithoutService_requestsInput>
  }

  export type ServiceUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type InvoiceUpsertWithoutService_requestInput = {
    update: XOR<InvoiceUpdateWithoutService_requestInput, InvoiceUncheckedUpdateWithoutService_requestInput>
    create: XOR<InvoiceCreateWithoutService_requestInput, InvoiceUncheckedCreateWithoutService_requestInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutService_requestInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutService_requestInput, InvoiceUncheckedUpdateWithoutService_requestInput>
  }

  export type InvoiceUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutService_requestInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutService_requestInput, MilestoneUncheckedUpdateWithoutService_requestInput>
    create: XOR<MilestoneCreateWithoutService_requestInput, MilestoneUncheckedCreateWithoutService_requestInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutService_requestInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutService_requestInput, MilestoneUncheckedUpdateWithoutService_requestInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutService_requestInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutService_requestInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    service_request_id?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    deadline?: DateTimeFilter<"Milestone"> | Date | string
    deliverable_file_url?: StringNullableFilter<"Milestone"> | string | null
    deliverable_file_name?: StringNullableFilter<"Milestone"> | string | null
    deliverable_link_url?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    rejection_reason?: StringNullableFilter<"Milestone"> | string | null
    created_at?: DateTimeFilter<"Milestone"> | Date | string
    updated_at?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type PlanUpsertWithoutService_requestsInput = {
    update: XOR<PlanUpdateWithoutService_requestsInput, PlanUncheckedUpdateWithoutService_requestsInput>
    create: XOR<PlanCreateWithoutService_requestsInput, PlanUncheckedCreateWithoutService_requestsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutService_requestsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutService_requestsInput, PlanUncheckedUpdateWithoutService_requestsInput>
  }

  export type PlanUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutPlansNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    Plan_type?: Plan_typeUpdateOneWithoutPlansNestedInput
    Billing_cycle?: Billing_cycleUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutService_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ConversationUpsertWithoutService_requestInput = {
    update: XOR<ConversationUpdateWithoutService_requestInput, ConversationUncheckedUpdateWithoutService_requestInput>
    create: XOR<ConversationCreateWithoutService_requestInput, ConversationUncheckedCreateWithoutService_requestInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutService_requestInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutService_requestInput, ConversationUncheckedUpdateWithoutService_requestInput>
  }

  export type ConversationUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ServiceRequestCreateWithoutMilestonesInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    service: ServiceCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
    conversation?: ConversationCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestUncheckedCreateWithoutMilestonesInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    conversation?: ConversationUncheckedCreateNestedOneWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutMilestonesInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutMilestonesInput, ServiceRequestUncheckedCreateWithoutMilestonesInput>
  }

  export type ServiceRequestUpsertWithoutMilestonesInput = {
    update: XOR<ServiceRequestUpdateWithoutMilestonesInput, ServiceRequestUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ServiceRequestCreateWithoutMilestonesInput, ServiceRequestUncheckedCreateWithoutMilestonesInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutMilestonesInput, ServiceRequestUncheckedUpdateWithoutMilestonesInput>
  }

  export type ServiceRequestUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type OrganisationCreateWithoutContactsInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyCreateNestedManyWithoutOrganisationInput
    user: UserCreateNestedOneWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    cert_of_inc_url: string
    mem_of_assoc_url: string
    proof_of_address_url: string
    company_status_report_url: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutContactsInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutContactsInput, OrganisationUncheckedCreateWithoutContactsInput>
  }

  export type OrganisationUpsertWithoutContactsInput = {
    update: XOR<OrganisationUpdateWithoutContactsInput, OrganisationUncheckedUpdateWithoutContactsInput>
    create: XOR<OrganisationCreateWithoutContactsInput, OrganisationUncheckedCreateWithoutContactsInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutContactsInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutContactsInput, OrganisationUncheckedUpdateWithoutContactsInput>
  }

  export type OrganisationUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUpdateManyWithoutOrganisationNestedInput
    user?: UserUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    cert_of_inc_url?: StringFieldUpdateOperationsInput | string
    mem_of_assoc_url?: StringFieldUpdateOperationsInput | string
    proof_of_address_url?: StringFieldUpdateOperationsInput | string
    company_status_report_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceRequestCreateWithoutConversationInput = {
    id?: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutService_requestsInput
    service: ServiceCreateNestedOneWithoutService_requestsInput
    invoice?: InvoiceCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneCreateNestedManyWithoutService_requestInput
    Plan?: PlanCreateNestedOneWithoutService_requestsInput
  }

  export type ServiceRequestUncheckedCreateWithoutConversationInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutService_requestInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutService_requestInput
  }

  export type ServiceRequestCreateOrConnectWithoutConversationInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutConversationInput, ServiceRequestUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    text: string
    created_at?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    sender_id: string
    text: string
    created_at?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestUpsertWithoutConversationInput = {
    update: XOR<ServiceRequestUpdateWithoutConversationInput, ServiceRequestUncheckedUpdateWithoutConversationInput>
    create: XOR<ServiceRequestCreateWithoutConversationInput, ServiceRequestUncheckedCreateWithoutConversationInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutConversationInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutConversationInput, ServiceRequestUncheckedUpdateWithoutConversationInput>
  }

  export type ServiceRequestUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    service_request: ServiceRequestCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    service_request_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service_request?: ServiceRequestUpdateOneRequiredWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPassword_tokensInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPassword_tokensInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPassword_tokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPassword_tokensInput, UserUncheckedCreateWithoutPassword_tokensInput>
  }

  export type UserUpsertWithoutPassword_tokensInput = {
    update: XOR<UserUpdateWithoutPassword_tokensInput, UserUncheckedUpdateWithoutPassword_tokensInput>
    create: XOR<UserCreateWithoutPassword_tokensInput, UserUncheckedCreateWithoutPassword_tokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPassword_tokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPassword_tokensInput, UserUncheckedUpdateWithoutPassword_tokensInput>
  }

  export type UserUpdateWithoutPassword_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPassword_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPrivacy_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrivacy_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrivacy_settingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
  }

  export type UserUpsertWithoutPrivacy_settingsInput = {
    update: XOR<UserUpdateWithoutPrivacy_settingsInput, UserUncheckedUpdateWithoutPrivacy_settingsInput>
    create: XOR<UserCreateWithoutPrivacy_settingsInput, UserUncheckedCreateWithoutPrivacy_settingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrivacy_settingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrivacy_settingsInput, UserUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type UserUpdateWithoutPrivacy_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrivacy_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotification_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotification_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotification_settingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
  }

  export type UserUpsertWithoutNotification_settingsInput = {
    update: XOR<UserUpdateWithoutNotification_settingsInput, UserUncheckedUpdateWithoutNotification_settingsInput>
    create: XOR<UserCreateWithoutNotification_settingsInput, UserUncheckedCreateWithoutNotification_settingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotification_settingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotification_settingsInput, UserUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type UserUpdateWithoutNotification_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotification_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlan_typesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlan_typesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlan_typesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlan_typesInput, UserUncheckedCreateWithoutPlan_typesInput>
  }

  export type PlanCreateWithoutPlan_typeInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service: ServiceCreateNestedOneWithoutPlansInput
    service_requests?: ServiceRequestCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    Billing_cycle?: Billing_cycleCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutPlan_typeInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    billing_cycleId?: string | null
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPlan_typeInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput>
  }

  export type PlanCreateManyPlan_typeInputEnvelope = {
    data: PlanCreateManyPlan_typeInput | PlanCreateManyPlan_typeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlan_typesInput = {
    update: XOR<UserUpdateWithoutPlan_typesInput, UserUncheckedUpdateWithoutPlan_typesInput>
    create: XOR<UserCreateWithoutPlan_typesInput, UserUncheckedCreateWithoutPlan_typesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlan_typesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlan_typesInput, UserUncheckedUpdateWithoutPlan_typesInput>
  }

  export type UserUpdateWithoutPlan_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlan_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanUpsertWithWhereUniqueWithoutPlan_typeInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutPlan_typeInput, PlanUncheckedUpdateWithoutPlan_typeInput>
    create: XOR<PlanCreateWithoutPlan_typeInput, PlanUncheckedCreateWithoutPlan_typeInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutPlan_typeInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutPlan_typeInput, PlanUncheckedUpdateWithoutPlan_typeInput>
  }

  export type PlanUpdateManyWithWhereWithoutPlan_typeInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutPlan_typeInput>
  }

  export type PlanCreateWithoutBilling_cycleInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service: ServiceCreateNestedOneWithoutPlansInput
    service_requests?: ServiceRequestCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
    Plan_type?: Plan_typeCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutBilling_cycleInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutBilling_cycleInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput>
  }

  export type PlanCreateManyBilling_cycleInputEnvelope = {
    data: PlanCreateManyBilling_cycleInput | PlanCreateManyBilling_cycleInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithWhereUniqueWithoutBilling_cycleInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutBilling_cycleInput, PlanUncheckedUpdateWithoutBilling_cycleInput>
    create: XOR<PlanCreateWithoutBilling_cycleInput, PlanUncheckedCreateWithoutBilling_cycleInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutBilling_cycleInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutBilling_cycleInput, PlanUncheckedUpdateWithoutBilling_cycleInput>
  }

  export type PlanUpdateManyWithWhereWithoutBilling_cycleInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutBilling_cycleInput>
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    service: ServiceCreateNestedOneWithoutPlansInput
    service_requests?: ServiceRequestCreateNestedManyWithoutPlanInput
    Plan_type?: Plan_typeCreateNestedOneWithoutPlansInput
    Billing_cycle?: Billing_cycleCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutPlansNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutPlanNestedInput
    Plan_type?: Plan_typeUpdateOneWithoutPlansNestedInput
    Billing_cycle?: Billing_cycleUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreated_rolesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    role: RoleCreateNestedOneWithoutUsersInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreated_rolesInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreated_rolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreated_rolesInput, UserUncheckedCreateWithoutCreated_rolesInput>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsCreateNestedManyWithoutUserInput
    organisation?: OrganisationCreateNestedOneWithoutUserInput
    otps?: OtpCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsCreateNestedManyWithoutUserInput
    created_roles?: RoleCreateNestedManyWithoutCreatorInput
    services?: ServiceCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    testimonials?: TestimonialCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeCreateNestedManyWithoutUserInput
    Invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: Notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: OrganisationUncheckedCreateNestedOneWithoutUserInput
    otps?: OtpUncheckedCreateNestedManyWithoutUserInput
    password_tokens?: Password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: Privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_roles?: RoleUncheckedCreateNestedManyWithoutCreatorInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
    service_requests?: ServiceRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonials?: TestimonialUncheckedCreateNestedManyWithoutUserInput
    plan_types?: Plan_typeUncheckedCreateNestedManyWithoutUserInput
    Invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreated_rolesInput = {
    update: XOR<UserUpdateWithoutCreated_rolesInput, UserUncheckedUpdateWithoutCreated_rolesInput>
    create: XOR<UserCreateWithoutCreated_rolesInput, UserUncheckedCreateWithoutCreated_rolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreated_rolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreated_rolesInput, UserUncheckedUpdateWithoutCreated_rolesInput>
  }

  export type UserUpdateWithoutCreated_rolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreated_rolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    tel?: StringFilter<"User"> | string
    country?: StringFilter<"User"> | string
    city?: StringNullableFilter<"User"> | string | null
    address?: StringFilter<"User"> | string
    category?: StringFilter<"User"> | string
    pfp_url?: StringNullableFilter<"User"> | string | null
    id_url?: JsonNullableFilter<"User">
    business_status?: BoolNullableFilter<"User"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"User"> | boolean | null
    password?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    role_id?: StringFilter<"User"> | string
    created_at?: DateTimeNullableFilter<"User"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversation_id: string
    text: string
    created_at?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type Notification_settingsCreateManyUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type OtpCreateManyUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type Password_tokenCreateManyUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type Privacy_settingsCreateManyUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type RoleCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type ServiceCreateManyUserInput = {
    id?: string
    title: string
    isPublic?: boolean
    heroHeadline?: string | null
    heroParagraph?: string | null
    heroImageUrl?: string | null
    blueprintHeadline?: string | null
    blueprintParagraph?: string | null
    blueprintImageUrl?: string | null
    bannerText?: string | null
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ServiceRequestCreateManyUserInput = {
    id?: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan_id: string
  }

  export type TestimonialCreateManyUserInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    service_id: string
  }

  export type Plan_typeCreateManyUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    service_request_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    status: string
    due_date: Date | string
    paid_at?: Date | string | null
    payment_method?: string | null
    payment_reference?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversation_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Notification_settingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Notification_settingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Notification_settingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OtpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_tokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_tokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Password_tokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Privacy_settingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Privacy_settingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Privacy_settingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUpdateManyWithoutServiceNestedInput
    faqs?: FaqUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutServiceNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutServiceNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutServiceNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutServiceNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutServiceNestedInput
    form?: ServiceFormUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    heroHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    heroParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintHeadline?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintParagraph?: NullableStringFieldUpdateOperationsInput | string | null
    blueprintImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerText?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type TestimonialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type TestimonialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type Plan_typeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUpdateManyWithoutPlan_typeNestedInput
  }

  export type Plan_typeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plans?: PlanUncheckedUpdateManyWithoutPlan_typeNestedInput
  }

  export type Plan_typeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service_request?: ServiceRequestUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_reference?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateManyOrganisationInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    service_id: string
  }

  export type ContactCreateManyOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type CaseStudyUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneRequiredWithoutCaseStudiesNestedInput
  }

  export type CaseStudyUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type CaseStudyUncheckedUpdateManyWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlanCreateManyServiceInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    position?: number
    plan_typeId?: string | null
    billing_cycleId?: string | null
  }

  export type CaseStudyCreateManyServiceInput = {
    id?: string
    title: string
    subtitle: string
    bannerImageUrl?: string | null
    challenge?: string | null
    challengeImageUrl?: string | null
    solution?: string | null
    solutionImageUrl?: string | null
    result?: string | null
    resultImageUrl?: string | null
    organisationId?: string | null
  }

  export type TestimonialCreateManyServiceInput = {
    id?: string
    quote: string
    authorName: string
    authorTitle: string
    stars?: number
    authorImageUrl?: string | null
    user_id: string
  }

  export type FaqCreateManyServiceInput = {
    id?: string
    question: string
    answer: string
  }

  export type ServiceRequestCreateManyServiceInput = {
    id?: string
    user_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    planId?: string | null
  }

  export type PlanUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service_requests?: ServiceRequestUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    Plan_type?: Plan_typeUpdateOneWithoutPlansNestedInput
    Billing_cycle?: Billing_cycleUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    Organisation?: OrganisationUpdateOneWithoutCaseStudiesNestedInput
  }

  export type CaseStudyUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: NullableStringFieldUpdateOperationsInput | string | null
    challengeImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    solutionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestimonialUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTestimonialsNestedInput
  }

  export type TestimonialUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type TestimonialUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quote?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    authorTitle?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    authorImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceRequestUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    Plan?: PlanUpdateOneWithoutService_requestsNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceRequestCreateManyPlanInput = {
    id?: string
    user_id: string
    service_id: string
    plan_name: string
    status?: $Enums.ServiceRequestStatus
    start_date?: Date | string | null
    end_date?: Date | string | null
    formData: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
  }

  export type ServiceRequestUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutService_requestsNestedInput
    service?: ServiceUpdateOneRequiredWithoutService_requestsNestedInput
    invoice?: InvoiceUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutService_requestNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutService_requestNestedInput
    conversation?: ConversationUncheckedUpdateOneWithoutService_requestNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_name?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceRequestStatusFieldUpdateOperationsInput | $Enums.ServiceRequestStatus
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    formData?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateManyService_requestInput = {
    id?: string
    title: string
    deadline: Date | string
    deliverable_file_url?: string | null
    deliverable_file_name?: string | null
    deliverable_link_url?: string | null
    status?: $Enums.MilestoneStatus
    rejection_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MilestoneUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverable_file_url?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_file_name?: NullableStringFieldUpdateOperationsInput | string | null
    deliverable_link_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    sender_id: string
    text: string
    created_at?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyPlan_typeInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    billing_cycleId?: string | null
  }

  export type PlanUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutPlansNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    Billing_cycle?: Billing_cycleUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    billing_cycleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanCreateManyBilling_cycleInput = {
    id?: string
    name: string
    price: string
    priceUnit: string
    audience: string
    features: JsonNullValueInput | InputJsonValue
    service_id: string
    position?: number
    plan_typeId?: string | null
  }

  export type PlanUpdateWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    position?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutPlansNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
    Plan_type?: Plan_typeUpdateOneWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    priceUnit?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    service_id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    plan_typeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    city?: string | null
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUpdateOneWithoutUserNestedInput
    otps?: OtpUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUpdateManyWithoutUserNestedInput
    created_roles?: RoleUpdateManyWithoutCreatorNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: Notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: OrganisationUncheckedUpdateOneWithoutUserNestedInput
    otps?: OtpUncheckedUpdateManyWithoutUserNestedInput
    password_tokens?: Password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: Privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_roles?: RoleUncheckedUpdateManyWithoutCreatorNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
    service_requests?: ServiceRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonials?: TestimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_types?: Plan_typeUncheckedUpdateManyWithoutUserNestedInput
    Invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}