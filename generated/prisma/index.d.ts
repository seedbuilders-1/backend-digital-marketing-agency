
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model organisation
 * 
 */
export type organisation = $Result.DefaultSelection<Prisma.$organisationPayload>
/**
 * Model service
 * 
 */
export type service = $Result.DefaultSelection<Prisma.$servicePayload>
/**
 * Model service_request
 * 
 */
export type service_request = $Result.DefaultSelection<Prisma.$service_requestPayload>
/**
 * Model case_studies
 * 
 */
export type case_studies = $Result.DefaultSelection<Prisma.$case_studiesPayload>
/**
 * Model testimonial
 * 
 */
export type testimonial = $Result.DefaultSelection<Prisma.$testimonialPayload>
/**
 * Model contact
 * 
 */
export type contact = $Result.DefaultSelection<Prisma.$contactPayload>
/**
 * Model otp
 * 
 */
export type otp = $Result.DefaultSelection<Prisma.$otpPayload>
/**
 * Model password_token
 * 
 */
export type password_token = $Result.DefaultSelection<Prisma.$password_tokenPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model privacy_settings
 * 
 */
export type privacy_settings = $Result.DefaultSelection<Prisma.$privacy_settingsPayload>
/**
 * Model notification_settings
 * 
 */
export type notification_settings = $Result.DefaultSelection<Prisma.$notification_settingsPayload>
/**
 * Model plan_type
 * 
 */
export type plan_type = $Result.DefaultSelection<Prisma.$plan_typePayload>
/**
 * Model billing_cycle
 * 
 */
export type billing_cycle = $Result.DefaultSelection<Prisma.$billing_cyclePayload>
/**
 * Model plan
 * 
 */
export type plan = $Result.DefaultSelection<Prisma.$planPayload>
/**
 * Model subscription
 * 
 */
export type subscription = $Result.DefaultSelection<Prisma.$subscriptionPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organisation`: Exposes CRUD operations for the **organisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisation.findMany()
    * ```
    */
  get organisation(): Prisma.organisationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.serviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_request`: Exposes CRUD operations for the **service_request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_requests
    * const service_requests = await prisma.service_request.findMany()
    * ```
    */
  get service_request(): Prisma.service_requestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.case_studies`: Exposes CRUD operations for the **case_studies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Case_studies
    * const case_studies = await prisma.case_studies.findMany()
    * ```
    */
  get case_studies(): Prisma.case_studiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.testimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.contactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.otpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_token`: Exposes CRUD operations for the **password_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_tokens
    * const password_tokens = await prisma.password_token.findMany()
    * ```
    */
  get password_token(): Prisma.password_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacy_settings`: Exposes CRUD operations for the **privacy_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privacy_settings
    * const privacy_settings = await prisma.privacy_settings.findMany()
    * ```
    */
  get privacy_settings(): Prisma.privacy_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification_settings`: Exposes CRUD operations for the **notification_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_settings
    * const notification_settings = await prisma.notification_settings.findMany()
    * ```
    */
  get notification_settings(): Prisma.notification_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan_type`: Exposes CRUD operations for the **plan_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plan_types
    * const plan_types = await prisma.plan_type.findMany()
    * ```
    */
  get plan_type(): Prisma.plan_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billing_cycle`: Exposes CRUD operations for the **billing_cycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billing_cycles
    * const billing_cycles = await prisma.billing_cycle.findMany()
    * ```
    */
  get billing_cycle(): Prisma.billing_cycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.planDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.subscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    organisation: 'organisation',
    service: 'service',
    service_request: 'service_request',
    case_studies: 'case_studies',
    testimonial: 'testimonial',
    contact: 'contact',
    otp: 'otp',
    password_token: 'password_token',
    notification: 'notification',
    privacy_settings: 'privacy_settings',
    notification_settings: 'notification_settings',
    plan_type: 'plan_type',
    billing_cycle: 'billing_cycle',
    plan: 'plan',
    subscription: 'subscription',
    role: 'role'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organisation" | "service" | "service_request" | "case_studies" | "testimonial" | "contact" | "otp" | "password_token" | "notification" | "privacy_settings" | "notification_settings" | "plan_type" | "billing_cycle" | "plan" | "subscription" | "role"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      organisation: {
        payload: Prisma.$organisationPayload<ExtArgs>
        fields: Prisma.organisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          findFirst: {
            args: Prisma.organisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          findMany: {
            args: Prisma.organisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>[]
          }
          create: {
            args: Prisma.organisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          createMany: {
            args: Prisma.organisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.organisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          update: {
            args: Prisma.organisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          deleteMany: {
            args: Prisma.organisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.organisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organisationPayload>
          }
          aggregate: {
            args: Prisma.OrganisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisation>
          }
          groupBy: {
            args: Prisma.organisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.organisationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationCountAggregateOutputType> | number
          }
        }
      }
      service: {
        payload: Prisma.$servicePayload<ExtArgs>
        fields: Prisma.serviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findFirst: {
            args: Prisma.serviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          findMany: {
            args: Prisma.serviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>[]
          }
          create: {
            args: Prisma.serviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          createMany: {
            args: Prisma.serviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          update: {
            args: Prisma.serviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          deleteMany: {
            args: Prisma.serviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.serviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      service_request: {
        payload: Prisma.$service_requestPayload<ExtArgs>
        fields: Prisma.service_requestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_requestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_requestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          findFirst: {
            args: Prisma.service_requestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_requestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          findMany: {
            args: Prisma.service_requestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>[]
          }
          create: {
            args: Prisma.service_requestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          createMany: {
            args: Prisma.service_requestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.service_requestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          update: {
            args: Prisma.service_requestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          deleteMany: {
            args: Prisma.service_requestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_requestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.service_requestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_requestPayload>
          }
          aggregate: {
            args: Prisma.Service_requestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_request>
          }
          groupBy: {
            args: Prisma.service_requestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_requestGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_requestCountArgs<ExtArgs>
            result: $Utils.Optional<Service_requestCountAggregateOutputType> | number
          }
        }
      }
      case_studies: {
        payload: Prisma.$case_studiesPayload<ExtArgs>
        fields: Prisma.case_studiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.case_studiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.case_studiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          findFirst: {
            args: Prisma.case_studiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.case_studiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          findMany: {
            args: Prisma.case_studiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>[]
          }
          create: {
            args: Prisma.case_studiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          createMany: {
            args: Prisma.case_studiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.case_studiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          update: {
            args: Prisma.case_studiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          deleteMany: {
            args: Prisma.case_studiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.case_studiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.case_studiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$case_studiesPayload>
          }
          aggregate: {
            args: Prisma.Case_studiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCase_studies>
          }
          groupBy: {
            args: Prisma.case_studiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Case_studiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.case_studiesCountArgs<ExtArgs>
            result: $Utils.Optional<Case_studiesCountAggregateOutputType> | number
          }
        }
      }
      testimonial: {
        payload: Prisma.$testimonialPayload<ExtArgs>
        fields: Prisma.testimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          findFirst: {
            args: Prisma.testimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          findMany: {
            args: Prisma.testimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>[]
          }
          create: {
            args: Prisma.testimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          createMany: {
            args: Prisma.testimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          update: {
            args: Prisma.testimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          deleteMany: {
            args: Prisma.testimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.testimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.testimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      contact: {
        payload: Prisma.$contactPayload<ExtArgs>
        fields: Prisma.contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findFirst: {
            args: Prisma.contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findMany: {
            args: Prisma.contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>[]
          }
          create: {
            args: Prisma.contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          createMany: {
            args: Prisma.contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          update: {
            args: Prisma.contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          deleteMany: {
            args: Prisma.contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      otp: {
        payload: Prisma.$otpPayload<ExtArgs>
        fields: Prisma.otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findFirst: {
            args: Prisma.otpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          findMany: {
            args: Prisma.otpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>[]
          }
          create: {
            args: Prisma.otpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          createMany: {
            args: Prisma.otpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.otpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          update: {
            args: Prisma.otpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          deleteMany: {
            args: Prisma.otpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.otpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.otpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.otpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.otpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      password_token: {
        payload: Prisma.$password_tokenPayload<ExtArgs>
        fields: Prisma.password_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          findFirst: {
            args: Prisma.password_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          findMany: {
            args: Prisma.password_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>[]
          }
          create: {
            args: Prisma.password_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          createMany: {
            args: Prisma.password_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.password_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          update: {
            args: Prisma.password_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          deleteMany: {
            args: Prisma.password_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.password_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_tokenPayload>
          }
          aggregate: {
            args: Prisma.Password_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_token>
          }
          groupBy: {
            args: Prisma.password_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Password_tokenCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      privacy_settings: {
        payload: Prisma.$privacy_settingsPayload<ExtArgs>
        fields: Prisma.privacy_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.privacy_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.privacy_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          findFirst: {
            args: Prisma.privacy_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.privacy_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          findMany: {
            args: Prisma.privacy_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>[]
          }
          create: {
            args: Prisma.privacy_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          createMany: {
            args: Prisma.privacy_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.privacy_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          update: {
            args: Prisma.privacy_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          deleteMany: {
            args: Prisma.privacy_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.privacy_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.privacy_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$privacy_settingsPayload>
          }
          aggregate: {
            args: Prisma.Privacy_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacy_settings>
          }
          groupBy: {
            args: Prisma.privacy_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Privacy_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.privacy_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Privacy_settingsCountAggregateOutputType> | number
          }
        }
      }
      notification_settings: {
        payload: Prisma.$notification_settingsPayload<ExtArgs>
        fields: Prisma.notification_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          findFirst: {
            args: Prisma.notification_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          findMany: {
            args: Prisma.notification_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>[]
          }
          create: {
            args: Prisma.notification_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          createMany: {
            args: Prisma.notification_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notification_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          update: {
            args: Prisma.notification_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          deleteMany: {
            args: Prisma.notification_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notification_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_settingsPayload>
          }
          aggregate: {
            args: Prisma.Notification_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_settings>
          }
          groupBy: {
            args: Prisma.notification_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_settingsCountAggregateOutputType> | number
          }
        }
      }
      plan_type: {
        payload: Prisma.$plan_typePayload<ExtArgs>
        fields: Prisma.plan_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plan_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plan_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          findFirst: {
            args: Prisma.plan_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plan_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          findMany: {
            args: Prisma.plan_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>[]
          }
          create: {
            args: Prisma.plan_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          createMany: {
            args: Prisma.plan_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.plan_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          update: {
            args: Prisma.plan_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          deleteMany: {
            args: Prisma.plan_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plan_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.plan_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plan_typePayload>
          }
          aggregate: {
            args: Prisma.Plan_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan_type>
          }
          groupBy: {
            args: Prisma.plan_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plan_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.plan_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Plan_typeCountAggregateOutputType> | number
          }
        }
      }
      billing_cycle: {
        payload: Prisma.$billing_cyclePayload<ExtArgs>
        fields: Prisma.billing_cycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.billing_cycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.billing_cycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          findFirst: {
            args: Prisma.billing_cycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.billing_cycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          findMany: {
            args: Prisma.billing_cycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>[]
          }
          create: {
            args: Prisma.billing_cycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          createMany: {
            args: Prisma.billing_cycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.billing_cycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          update: {
            args: Prisma.billing_cycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          deleteMany: {
            args: Prisma.billing_cycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.billing_cycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.billing_cycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$billing_cyclePayload>
          }
          aggregate: {
            args: Prisma.Billing_cycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBilling_cycle>
          }
          groupBy: {
            args: Prisma.billing_cycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Billing_cycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.billing_cycleCountArgs<ExtArgs>
            result: $Utils.Optional<Billing_cycleCountAggregateOutputType> | number
          }
        }
      }
      plan: {
        payload: Prisma.$planPayload<ExtArgs>
        fields: Prisma.planFieldRefs
        operations: {
          findUnique: {
            args: Prisma.planFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.planFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          findFirst: {
            args: Prisma.planFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.planFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          findMany: {
            args: Prisma.planFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>[]
          }
          create: {
            args: Prisma.planCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          createMany: {
            args: Prisma.planCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.planDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          update: {
            args: Prisma.planUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          deleteMany: {
            args: Prisma.planDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.planUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.planUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$planPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.planGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.planCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      subscription: {
        payload: Prisma.$subscriptionPayload<ExtArgs>
        fields: Prisma.subscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findFirst: {
            args: Prisma.subscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          findMany: {
            args: Prisma.subscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>[]
          }
          create: {
            args: Prisma.subscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          createMany: {
            args: Prisma.subscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          update: {
            args: Prisma.subscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.subscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    organisation?: organisationOmit
    service?: serviceOmit
    service_request?: service_requestOmit
    case_studies?: case_studiesOmit
    testimonial?: testimonialOmit
    contact?: contactOmit
    otp?: otpOmit
    password_token?: password_tokenOmit
    notification?: notificationOmit
    privacy_settings?: privacy_settingsOmit
    notification_settings?: notification_settingsOmit
    plan_type?: plan_typeOmit
    billing_cycle?: billing_cycleOmit
    plan?: planOmit
    subscription?: subscriptionOmit
    role?: roleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notification: number
    notification_settings: number
    organisation: number
    otp: number
    password_token: number
    privacy_settings: number
    created_role: number
    service: number
    service_request: number
    subscription: number
    testimonial: number
    plan_type: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    notification_settings?: boolean | UserCountOutputTypeCountNotification_settingsArgs
    organisation?: boolean | UserCountOutputTypeCountOrganisationArgs
    otp?: boolean | UserCountOutputTypeCountOtpArgs
    password_token?: boolean | UserCountOutputTypeCountPassword_tokenArgs
    privacy_settings?: boolean | UserCountOutputTypeCountPrivacy_settingsArgs
    created_role?: boolean | UserCountOutputTypeCountCreated_roleArgs
    service?: boolean | UserCountOutputTypeCountServiceArgs
    service_request?: boolean | UserCountOutputTypeCountService_requestArgs
    subscription?: boolean | UserCountOutputTypeCountSubscriptionArgs
    testimonial?: boolean | UserCountOutputTypeCountTestimonialArgs
    plan_type?: boolean | UserCountOutputTypeCountPlan_typeArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotification_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_settingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organisationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPassword_tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_tokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrivacy_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: privacy_settingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreated_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountService_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_requestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlan_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_typeWhereInput
  }


  /**
   * Count Type OrganisationCountOutputType
   */

  export type OrganisationCountOutputType = {
    case_studies: number
    contact: number
  }

  export type OrganisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case_studies?: boolean | OrganisationCountOutputTypeCountCase_studiesArgs
    contact?: boolean | OrganisationCountOutputTypeCountContactArgs
  }

  // Custom InputTypes
  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationCountOutputType
     */
    select?: OrganisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountCase_studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_studiesWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    service_request: number
    case_studies: number
    testimonial: number
    plan: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_request?: boolean | ServiceCountOutputTypeCountService_requestArgs
    case_studies?: boolean | ServiceCountOutputTypeCountCase_studiesArgs
    testimonial?: boolean | ServiceCountOutputTypeCountTestimonialArgs
    plan?: boolean | ServiceCountOutputTypeCountPlanArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountService_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_requestWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCase_studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_studiesWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planWhereInput
  }


  /**
   * Count Type Plan_typeCountOutputType
   */

  export type Plan_typeCountOutputType = {
    plan: number
  }

  export type Plan_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Plan_typeCountOutputTypeCountPlanArgs
  }

  // Custom InputTypes
  /**
   * Plan_typeCountOutputType without action
   */
  export type Plan_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan_typeCountOutputType
     */
    select?: Plan_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Plan_typeCountOutputType without action
   */
  export type Plan_typeCountOutputTypeCountPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planWhereInput
  }


  /**
   * Count Type Billing_cycleCountOutputType
   */

  export type Billing_cycleCountOutputType = {
    plan: number
  }

  export type Billing_cycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Billing_cycleCountOutputTypeCountPlanArgs
  }

  // Custom InputTypes
  /**
   * Billing_cycleCountOutputType without action
   */
  export type Billing_cycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billing_cycleCountOutputType
     */
    select?: Billing_cycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Billing_cycleCountOutputType without action
   */
  export type Billing_cycleCountOutputTypeCountPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    service_request: number
    subscription: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_request?: boolean | PlanCountOutputTypeCountService_requestArgs
    subscription?: boolean | PlanCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountService_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_requestWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    user: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | RoleCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    tel: string | null
    country: string | null
    address: string | null
    category: string | null
    pfp_url: string | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string | null
    status: string | null
    role_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    tel: string | null
    country: string | null
    address: string | null
    category: string | null
    pfp_url: string | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string | null
    status: string | null
    role_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    tel: number
    country: number
    address: number
    category: number
    pfp_url: number
    id_url: number
    business_status: number
    registered_with_a_business: number
    password: number
    status: number
    role_id: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    address?: true
    category?: true
    pfp_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    address?: true
    category?: true
    pfp_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    tel?: true
    country?: true
    address?: true
    category?: true
    pfp_url?: true
    id_url?: true
    business_status?: true
    registered_with_a_business?: true
    password?: true
    status?: true
    role_id?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url: string | null
    id_url: JsonValue | null
    business_status: boolean | null
    registered_with_a_business: boolean | null
    password: string
    status: string
    role_id: string
    created_at: Date | null
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    tel?: boolean
    country?: boolean
    address?: boolean
    category?: boolean
    pfp_url?: boolean
    id_url?: boolean
    business_status?: boolean
    registered_with_a_business?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    notification?: boolean | user$notificationArgs<ExtArgs>
    notification_settings?: boolean | user$notification_settingsArgs<ExtArgs>
    organisation?: boolean | user$organisationArgs<ExtArgs>
    otp?: boolean | user$otpArgs<ExtArgs>
    password_token?: boolean | user$password_tokenArgs<ExtArgs>
    privacy_settings?: boolean | user$privacy_settingsArgs<ExtArgs>
    created_role?: boolean | user$created_roleArgs<ExtArgs>
    service?: boolean | user$serviceArgs<ExtArgs>
    service_request?: boolean | user$service_requestArgs<ExtArgs>
    subscription?: boolean | user$subscriptionArgs<ExtArgs>
    testimonial?: boolean | user$testimonialArgs<ExtArgs>
    plan_type?: boolean | user$plan_typeArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    tel?: boolean
    country?: boolean
    address?: boolean
    category?: boolean
    pfp_url?: boolean
    id_url?: boolean
    business_status?: boolean
    registered_with_a_business?: boolean
    password?: boolean
    status?: boolean
    role_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "tel" | "country" | "address" | "category" | "pfp_url" | "id_url" | "business_status" | "registered_with_a_business" | "password" | "status" | "role_id" | "created_at" | "deleted_at", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | user$notificationArgs<ExtArgs>
    notification_settings?: boolean | user$notification_settingsArgs<ExtArgs>
    organisation?: boolean | user$organisationArgs<ExtArgs>
    otp?: boolean | user$otpArgs<ExtArgs>
    password_token?: boolean | user$password_tokenArgs<ExtArgs>
    privacy_settings?: boolean | user$privacy_settingsArgs<ExtArgs>
    created_role?: boolean | user$created_roleArgs<ExtArgs>
    service?: boolean | user$serviceArgs<ExtArgs>
    service_request?: boolean | user$service_requestArgs<ExtArgs>
    subscription?: boolean | user$subscriptionArgs<ExtArgs>
    testimonial?: boolean | user$testimonialArgs<ExtArgs>
    plan_type?: boolean | user$plan_typeArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      notification: Prisma.$notificationPayload<ExtArgs>[]
      notification_settings: Prisma.$notification_settingsPayload<ExtArgs>[]
      organisation: Prisma.$organisationPayload<ExtArgs>[]
      otp: Prisma.$otpPayload<ExtArgs>[]
      password_token: Prisma.$password_tokenPayload<ExtArgs>[]
      privacy_settings: Prisma.$privacy_settingsPayload<ExtArgs>[]
      created_role: Prisma.$rolePayload<ExtArgs>[]
      service: Prisma.$servicePayload<ExtArgs>[]
      service_request: Prisma.$service_requestPayload<ExtArgs>[]
      subscription: Prisma.$subscriptionPayload<ExtArgs>[]
      testimonial: Prisma.$testimonialPayload<ExtArgs>[]
      plan_type: Prisma.$plan_typePayload<ExtArgs>[]
      role: Prisma.$rolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      tel: string
      country: string
      address: string
      category: string
      pfp_url: string | null
      id_url: Prisma.JsonValue | null
      business_status: boolean | null
      registered_with_a_business: boolean | null
      password: string
      status: string
      role_id: string
      created_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends user$notificationArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_settings<T extends user$notification_settingsArgs<ExtArgs> = {}>(args?: Subset<T, user$notification_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organisation<T extends user$organisationArgs<ExtArgs> = {}>(args?: Subset<T, user$organisationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otp<T extends user$otpArgs<ExtArgs> = {}>(args?: Subset<T, user$otpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    password_token<T extends user$password_tokenArgs<ExtArgs> = {}>(args?: Subset<T, user$password_tokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privacy_settings<T extends user$privacy_settingsArgs<ExtArgs> = {}>(args?: Subset<T, user$privacy_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    created_role<T extends user$created_roleArgs<ExtArgs> = {}>(args?: Subset<T, user$created_roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service<T extends user$serviceArgs<ExtArgs> = {}>(args?: Subset<T, user$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_request<T extends user$service_requestArgs<ExtArgs> = {}>(args?: Subset<T, user$service_requestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends user$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, user$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonial<T extends user$testimonialArgs<ExtArgs> = {}>(args?: Subset<T, user$testimonialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan_type<T extends user$plan_typeArgs<ExtArgs> = {}>(args?: Subset<T, user$plan_typeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly tel: FieldRef<"user", 'String'>
    readonly country: FieldRef<"user", 'String'>
    readonly address: FieldRef<"user", 'String'>
    readonly category: FieldRef<"user", 'String'>
    readonly pfp_url: FieldRef<"user", 'String'>
    readonly id_url: FieldRef<"user", 'Json'>
    readonly business_status: FieldRef<"user", 'Boolean'>
    readonly registered_with_a_business: FieldRef<"user", 'Boolean'>
    readonly password: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'String'>
    readonly role_id: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly deleted_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.notification
   */
  export type user$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * user.notification_settings
   */
  export type user$notification_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    where?: notification_settingsWhereInput
    orderBy?: notification_settingsOrderByWithRelationInput | notification_settingsOrderByWithRelationInput[]
    cursor?: notification_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * user.organisation
   */
  export type user$organisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    where?: organisationWhereInput
    orderBy?: organisationOrderByWithRelationInput | organisationOrderByWithRelationInput[]
    cursor?: organisationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * user.otp
   */
  export type user$otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    where?: otpWhereInput
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    cursor?: otpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * user.password_token
   */
  export type user$password_tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    where?: password_tokenWhereInput
    orderBy?: password_tokenOrderByWithRelationInput | password_tokenOrderByWithRelationInput[]
    cursor?: password_tokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * user.privacy_settings
   */
  export type user$privacy_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    where?: privacy_settingsWhereInput
    orderBy?: privacy_settingsOrderByWithRelationInput | privacy_settingsOrderByWithRelationInput[]
    cursor?: privacy_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * user.created_role
   */
  export type user$created_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    where?: roleWhereInput
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    cursor?: roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * user.service
   */
  export type user$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    cursor?: serviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * user.service_request
   */
  export type user$service_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    where?: service_requestWhereInput
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    cursor?: service_requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * user.subscription
   */
  export type user$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    cursor?: subscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * user.testimonial
   */
  export type user$testimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    where?: testimonialWhereInput
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    cursor?: testimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * user.plan_type
   */
  export type user$plan_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    where?: plan_typeWhereInput
    orderBy?: plan_typeOrderByWithRelationInput | plan_typeOrderByWithRelationInput[]
    cursor?: plan_typeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model organisation
   */

  export type AggregateOrganisation = {
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  export type OrganisationMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    address: string | null
    country: string | null
    industry: string | null
    logo_url: string | null
    rc_number: string | null
    staff_size: string | null
    type: string | null
    created_at: Date | null
    user_id: string | null
    deleted_at: Date | null
  }

  export type OrganisationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    address: string | null
    country: string | null
    industry: string | null
    logo_url: string | null
    rc_number: string | null
    staff_size: string | null
    type: string | null
    created_at: Date | null
    user_id: string | null
    deleted_at: Date | null
  }

  export type OrganisationCountAggregateOutputType = {
    id: number
    name: number
    email: number
    address: number
    country: number
    industry: number
    logo_url: number
    rc_number: number
    staff_size: number
    type: number
    created_at: number
    user_id: number
    deleted_at: number
    _all: number
  }


  export type OrganisationMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
  }

  export type OrganisationMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
  }

  export type OrganisationCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    country?: true
    industry?: true
    logo_url?: true
    rc_number?: true
    staff_size?: true
    type?: true
    created_at?: true
    user_id?: true
    deleted_at?: true
    _all?: true
  }

  export type OrganisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organisation to aggregate.
     */
    where?: organisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisations to fetch.
     */
    orderBy?: organisationOrderByWithRelationInput | organisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organisations
    **/
    _count?: true | OrganisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMaxAggregateInputType
  }

  export type GetOrganisationAggregateType<T extends OrganisationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisation[P]>
      : GetScalarType<T[P], AggregateOrganisation[P]>
  }




  export type organisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organisationWhereInput
    orderBy?: organisationOrderByWithAggregationInput | organisationOrderByWithAggregationInput[]
    by: OrganisationScalarFieldEnum[] | OrganisationScalarFieldEnum
    having?: organisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationCountAggregateInputType | true
    _min?: OrganisationMinAggregateInputType
    _max?: OrganisationMaxAggregateInputType
  }

  export type OrganisationGroupByOutputType = {
    id: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at: Date
    user_id: string
    deleted_at: Date | null
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  type GetOrganisationGroupByPayload<T extends organisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
        }
      >
    >


  export type organisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    country?: boolean
    industry?: boolean
    logo_url?: boolean
    rc_number?: boolean
    staff_size?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
    deleted_at?: boolean
    case_studies?: boolean | organisation$case_studiesArgs<ExtArgs>
    contact?: boolean | organisation$contactArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisation"]>



  export type organisationSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    country?: boolean
    industry?: boolean
    logo_url?: boolean
    rc_number?: boolean
    staff_size?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
    deleted_at?: boolean
  }

  export type organisationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "address" | "country" | "industry" | "logo_url" | "rc_number" | "staff_size" | "type" | "created_at" | "user_id" | "deleted_at", ExtArgs["result"]["organisation"]>
  export type organisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case_studies?: boolean | organisation$case_studiesArgs<ExtArgs>
    contact?: boolean | organisation$contactArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $organisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organisation"
    objects: {
      case_studies: Prisma.$case_studiesPayload<ExtArgs>[]
      contact: Prisma.$contactPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      address: string
      country: string
      industry: string
      logo_url: string
      rc_number: string
      staff_size: string
      type: string
      created_at: Date
      user_id: string
      deleted_at: Date | null
    }, ExtArgs["result"]["organisation"]>
    composites: {}
  }

  type organisationGetPayload<S extends boolean | null | undefined | organisationDefaultArgs> = $Result.GetResult<Prisma.$organisationPayload, S>

  type organisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganisationCountAggregateInputType | true
    }

  export interface organisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organisation'], meta: { name: 'organisation' } }
    /**
     * Find zero or one Organisation that matches the filter.
     * @param {organisationFindUniqueArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organisationFindUniqueArgs>(args: SelectSubset<T, organisationFindUniqueArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organisation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organisationFindUniqueOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organisationFindUniqueOrThrowArgs>(args: SelectSubset<T, organisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationFindFirstArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organisationFindFirstArgs>(args?: SelectSubset<T, organisationFindFirstArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationFindFirstOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organisationFindFirstOrThrowArgs>(args?: SelectSubset<T, organisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisation.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationWithIdOnly = await prisma.organisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends organisationFindManyArgs>(args?: SelectSubset<T, organisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organisation.
     * @param {organisationCreateArgs} args - Arguments to create a Organisation.
     * @example
     * // Create one Organisation
     * const Organisation = await prisma.organisation.create({
     *   data: {
     *     // ... data to create a Organisation
     *   }
     * })
     * 
     */
    create<T extends organisationCreateArgs>(args: SelectSubset<T, organisationCreateArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organisations.
     * @param {organisationCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisation = await prisma.organisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organisationCreateManyArgs>(args?: SelectSubset<T, organisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organisation.
     * @param {organisationDeleteArgs} args - Arguments to delete one Organisation.
     * @example
     * // Delete one Organisation
     * const Organisation = await prisma.organisation.delete({
     *   where: {
     *     // ... filter to delete one Organisation
     *   }
     * })
     * 
     */
    delete<T extends organisationDeleteArgs>(args: SelectSubset<T, organisationDeleteArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organisation.
     * @param {organisationUpdateArgs} args - Arguments to update one Organisation.
     * @example
     * // Update one Organisation
     * const organisation = await prisma.organisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organisationUpdateArgs>(args: SelectSubset<T, organisationUpdateArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organisations.
     * @param {organisationDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organisationDeleteManyArgs>(args?: SelectSubset<T, organisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisation = await prisma.organisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organisationUpdateManyArgs>(args: SelectSubset<T, organisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisation.
     * @param {organisationUpsertArgs} args - Arguments to update or create a Organisation.
     * @example
     * // Update or create a Organisation
     * const organisation = await prisma.organisation.upsert({
     *   create: {
     *     // ... data to create a Organisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisation we want to update
     *   }
     * })
     */
    upsert<T extends organisationUpsertArgs>(args: SelectSubset<T, organisationUpsertArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisation.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends organisationCountArgs>(
      args?: Subset<T, organisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationAggregateArgs>(args: Subset<T, OrganisationAggregateArgs>): Prisma.PrismaPromise<GetOrganisationAggregateType<T>>

    /**
     * Group by Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organisationGroupByArgs['orderBy'] }
        : { orderBy?: organisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organisation model
   */
  readonly fields: organisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case_studies<T extends organisation$case_studiesArgs<ExtArgs> = {}>(args?: Subset<T, organisation$case_studiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends organisation$contactArgs<ExtArgs> = {}>(args?: Subset<T, organisation$contactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organisation model
   */
  interface organisationFieldRefs {
    readonly id: FieldRef<"organisation", 'String'>
    readonly name: FieldRef<"organisation", 'String'>
    readonly email: FieldRef<"organisation", 'String'>
    readonly address: FieldRef<"organisation", 'String'>
    readonly country: FieldRef<"organisation", 'String'>
    readonly industry: FieldRef<"organisation", 'String'>
    readonly logo_url: FieldRef<"organisation", 'String'>
    readonly rc_number: FieldRef<"organisation", 'String'>
    readonly staff_size: FieldRef<"organisation", 'String'>
    readonly type: FieldRef<"organisation", 'String'>
    readonly created_at: FieldRef<"organisation", 'DateTime'>
    readonly user_id: FieldRef<"organisation", 'String'>
    readonly deleted_at: FieldRef<"organisation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * organisation findUnique
   */
  export type organisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter, which organisation to fetch.
     */
    where: organisationWhereUniqueInput
  }

  /**
   * organisation findUniqueOrThrow
   */
  export type organisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter, which organisation to fetch.
     */
    where: organisationWhereUniqueInput
  }

  /**
   * organisation findFirst
   */
  export type organisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter, which organisation to fetch.
     */
    where?: organisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisations to fetch.
     */
    orderBy?: organisationOrderByWithRelationInput | organisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organisations.
     */
    cursor?: organisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * organisation findFirstOrThrow
   */
  export type organisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter, which organisation to fetch.
     */
    where?: organisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisations to fetch.
     */
    orderBy?: organisationOrderByWithRelationInput | organisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organisations.
     */
    cursor?: organisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * organisation findMany
   */
  export type organisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter, which organisations to fetch.
     */
    where?: organisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisations to fetch.
     */
    orderBy?: organisationOrderByWithRelationInput | organisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organisations.
     */
    cursor?: organisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisations.
     */
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * organisation create
   */
  export type organisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * The data needed to create a organisation.
     */
    data: XOR<organisationCreateInput, organisationUncheckedCreateInput>
  }

  /**
   * organisation createMany
   */
  export type organisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organisations.
     */
    data: organisationCreateManyInput | organisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organisation update
   */
  export type organisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * The data needed to update a organisation.
     */
    data: XOR<organisationUpdateInput, organisationUncheckedUpdateInput>
    /**
     * Choose, which organisation to update.
     */
    where: organisationWhereUniqueInput
  }

  /**
   * organisation updateMany
   */
  export type organisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organisations.
     */
    data: XOR<organisationUpdateManyMutationInput, organisationUncheckedUpdateManyInput>
    /**
     * Filter which organisations to update
     */
    where?: organisationWhereInput
    /**
     * Limit how many organisations to update.
     */
    limit?: number
  }

  /**
   * organisation upsert
   */
  export type organisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * The filter to search for the organisation to update in case it exists.
     */
    where: organisationWhereUniqueInput
    /**
     * In case the organisation found by the `where` argument doesn't exist, create a new organisation with this data.
     */
    create: XOR<organisationCreateInput, organisationUncheckedCreateInput>
    /**
     * In case the organisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organisationUpdateInput, organisationUncheckedUpdateInput>
  }

  /**
   * organisation delete
   */
  export type organisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
    /**
     * Filter which organisation to delete.
     */
    where: organisationWhereUniqueInput
  }

  /**
   * organisation deleteMany
   */
  export type organisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organisations to delete
     */
    where?: organisationWhereInput
    /**
     * Limit how many organisations to delete.
     */
    limit?: number
  }

  /**
   * organisation.case_studies
   */
  export type organisation$case_studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    where?: case_studiesWhereInput
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    cursor?: case_studiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_studiesScalarFieldEnum | Case_studiesScalarFieldEnum[]
  }

  /**
   * organisation.contact
   */
  export type organisation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    where?: contactWhereInput
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    cursor?: contactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * organisation without action
   */
  export type organisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organisation
     */
    select?: organisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organisation
     */
    omit?: organisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organisationInclude<ExtArgs> | null
  }


  /**
   * Model service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subtitle: string | null
    created_at: Date | null
    admin_id: string | null
    banner_url: string | null
    deleted_at: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    subtitle: string | null
    created_at: Date | null
    admin_id: string | null
    banner_url: string | null
    deleted_at: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    subtitle: number
    created_at: number
    admin_id: number
    banner_url: number
    deleted_at: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subtitle?: true
    created_at?: true
    admin_id?: true
    banner_url?: true
    deleted_at?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subtitle?: true
    created_at?: true
    admin_id?: true
    banner_url?: true
    deleted_at?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subtitle?: true
    created_at?: true
    admin_id?: true
    banner_url?: true
    deleted_at?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service to aggregate.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type serviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceWhereInput
    orderBy?: serviceOrderByWithAggregationInput | serviceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: serviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    title: string
    description: string
    subtitle: string
    created_at: Date | null
    admin_id: string
    banner_url: string
    deleted_at: Date | null
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends serviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type serviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subtitle?: boolean
    created_at?: boolean
    admin_id?: boolean
    banner_url?: boolean
    deleted_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    service_request?: boolean | service$service_requestArgs<ExtArgs>
    case_studies?: boolean | service$case_studiesArgs<ExtArgs>
    testimonial?: boolean | service$testimonialArgs<ExtArgs>
    plan?: boolean | service$planArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type serviceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    subtitle?: boolean
    created_at?: boolean
    admin_id?: boolean
    banner_url?: boolean
    deleted_at?: boolean
  }

  export type serviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "subtitle" | "created_at" | "admin_id" | "banner_url" | "deleted_at", ExtArgs["result"]["service"]>
  export type serviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    service_request?: boolean | service$service_requestArgs<ExtArgs>
    case_studies?: boolean | service$case_studiesArgs<ExtArgs>
    testimonial?: boolean | service$testimonialArgs<ExtArgs>
    plan?: boolean | service$planArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $servicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      service_request: Prisma.$service_requestPayload<ExtArgs>[]
      case_studies: Prisma.$case_studiesPayload<ExtArgs>[]
      testimonial: Prisma.$testimonialPayload<ExtArgs>[]
      plan: Prisma.$planPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      subtitle: string
      created_at: Date | null
      admin_id: string
      banner_url: string
      deleted_at: Date | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type serviceGetPayload<S extends boolean | null | undefined | serviceDefaultArgs> = $Result.GetResult<Prisma.$servicePayload, S>

  type serviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<serviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface serviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service'], meta: { name: 'service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {serviceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceFindUniqueArgs>(args: SelectSubset<T, serviceFindUniqueArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {serviceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceFindFirstArgs>(args?: SelectSubset<T, serviceFindFirstArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends serviceFindManyArgs>(args?: SelectSubset<T, serviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {serviceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends serviceCreateArgs>(args: SelectSubset<T, serviceCreateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {serviceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceCreateManyArgs>(args?: SelectSubset<T, serviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {serviceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends serviceDeleteArgs>(args: SelectSubset<T, serviceDeleteArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {serviceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceUpdateArgs>(args: SelectSubset<T, serviceUpdateArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {serviceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceDeleteManyArgs>(args?: SelectSubset<T, serviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceUpdateManyArgs>(args: SelectSubset<T, serviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {serviceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends serviceUpsertArgs>(args: SelectSubset<T, serviceUpsertArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends serviceCountArgs>(
      args?: Subset<T, serviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceGroupByArgs['orderBy'] }
        : { orderBy?: serviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service model
   */
  readonly fields: serviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service_request<T extends service$service_requestArgs<ExtArgs> = {}>(args?: Subset<T, service$service_requestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    case_studies<T extends service$case_studiesArgs<ExtArgs> = {}>(args?: Subset<T, service$case_studiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testimonial<T extends service$testimonialArgs<ExtArgs> = {}>(args?: Subset<T, service$testimonialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plan<T extends service$planArgs<ExtArgs> = {}>(args?: Subset<T, service$planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service model
   */
  interface serviceFieldRefs {
    readonly id: FieldRef<"service", 'String'>
    readonly title: FieldRef<"service", 'String'>
    readonly description: FieldRef<"service", 'String'>
    readonly subtitle: FieldRef<"service", 'String'>
    readonly created_at: FieldRef<"service", 'DateTime'>
    readonly admin_id: FieldRef<"service", 'String'>
    readonly banner_url: FieldRef<"service", 'String'>
    readonly deleted_at: FieldRef<"service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * service findUnique
   */
  export type serviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findUniqueOrThrow
   */
  export type serviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service findFirst
   */
  export type serviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findFirstOrThrow
   */
  export type serviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which service to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service findMany
   */
  export type serviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter, which services to fetch.
     */
    where?: serviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     */
    orderBy?: serviceOrderByWithRelationInput | serviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     */
    cursor?: serviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * service create
   */
  export type serviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to create a service.
     */
    data: XOR<serviceCreateInput, serviceUncheckedCreateInput>
  }

  /**
   * service createMany
   */
  export type serviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many services.
     */
    data: serviceCreateManyInput | serviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service update
   */
  export type serviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The data needed to update a service.
     */
    data: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
    /**
     * Choose, which service to update.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service updateMany
   */
  export type serviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update services.
     */
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to update.
     */
    limit?: number
  }

  /**
   * service upsert
   */
  export type serviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * The filter to search for the service to update in case it exists.
     */
    where: serviceWhereUniqueInput
    /**
     * In case the service found by the `where` argument doesn't exist, create a new service with this data.
     */
    create: XOR<serviceCreateInput, serviceUncheckedCreateInput>
    /**
     * In case the service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceUpdateInput, serviceUncheckedUpdateInput>
  }

  /**
   * service delete
   */
  export type serviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
    /**
     * Filter which service to delete.
     */
    where: serviceWhereUniqueInput
  }

  /**
   * service deleteMany
   */
  export type serviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which services to delete
     */
    where?: serviceWhereInput
    /**
     * Limit how many services to delete.
     */
    limit?: number
  }

  /**
   * service.service_request
   */
  export type service$service_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    where?: service_requestWhereInput
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    cursor?: service_requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * service.case_studies
   */
  export type service$case_studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    where?: case_studiesWhereInput
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    cursor?: case_studiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Case_studiesScalarFieldEnum | Case_studiesScalarFieldEnum[]
  }

  /**
   * service.testimonial
   */
  export type service$testimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    where?: testimonialWhereInput
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    cursor?: testimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * service.plan
   */
  export type service$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    where?: planWhereInput
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    cursor?: planWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * service without action
   */
  export type serviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service
     */
    select?: serviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service
     */
    omit?: serviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serviceInclude<ExtArgs> | null
  }


  /**
   * Model service_request
   */

  export type AggregateService_request = {
    _count: Service_requestCountAggregateOutputType | null
    _min: Service_requestMinAggregateOutputType | null
    _max: Service_requestMaxAggregateOutputType | null
  }

  export type Service_requestMinAggregateOutputType = {
    id: string | null
    message: string | null
    service_id: string | null
    user_id: string | null
    requested_at: Date | null
    status: string | null
    plan_id: string | null
  }

  export type Service_requestMaxAggregateOutputType = {
    id: string | null
    message: string | null
    service_id: string | null
    user_id: string | null
    requested_at: Date | null
    status: string | null
    plan_id: string | null
  }

  export type Service_requestCountAggregateOutputType = {
    id: number
    message: number
    service_id: number
    user_id: number
    requested_at: number
    status: number
    plan_id: number
    _all: number
  }


  export type Service_requestMinAggregateInputType = {
    id?: true
    message?: true
    service_id?: true
    user_id?: true
    requested_at?: true
    status?: true
    plan_id?: true
  }

  export type Service_requestMaxAggregateInputType = {
    id?: true
    message?: true
    service_id?: true
    user_id?: true
    requested_at?: true
    status?: true
    plan_id?: true
  }

  export type Service_requestCountAggregateInputType = {
    id?: true
    message?: true
    service_id?: true
    user_id?: true
    requested_at?: true
    status?: true
    plan_id?: true
    _all?: true
  }

  export type Service_requestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_request to aggregate.
     */
    where?: service_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_requests to fetch.
     */
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_requests
    **/
    _count?: true | Service_requestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_requestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_requestMaxAggregateInputType
  }

  export type GetService_requestAggregateType<T extends Service_requestAggregateArgs> = {
        [P in keyof T & keyof AggregateService_request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_request[P]>
      : GetScalarType<T[P], AggregateService_request[P]>
  }




  export type service_requestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_requestWhereInput
    orderBy?: service_requestOrderByWithAggregationInput | service_requestOrderByWithAggregationInput[]
    by: Service_requestScalarFieldEnum[] | Service_requestScalarFieldEnum
    having?: service_requestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_requestCountAggregateInputType | true
    _min?: Service_requestMinAggregateInputType
    _max?: Service_requestMaxAggregateInputType
  }

  export type Service_requestGroupByOutputType = {
    id: string
    message: string
    service_id: string
    user_id: string
    requested_at: Date
    status: string
    plan_id: string
    _count: Service_requestCountAggregateOutputType | null
    _min: Service_requestMinAggregateOutputType | null
    _max: Service_requestMaxAggregateOutputType | null
  }

  type GetService_requestGroupByPayload<T extends service_requestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_requestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_requestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_requestGroupByOutputType[P]>
            : GetScalarType<T[P], Service_requestGroupByOutputType[P]>
        }
      >
    >


  export type service_requestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    service_id?: boolean
    user_id?: boolean
    requested_at?: boolean
    status?: boolean
    plan_id?: boolean
    plan?: boolean | planDefaultArgs<ExtArgs>
    service?: boolean | serviceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_request"]>



  export type service_requestSelectScalar = {
    id?: boolean
    message?: boolean
    service_id?: boolean
    user_id?: boolean
    requested_at?: boolean
    status?: boolean
    plan_id?: boolean
  }

  export type service_requestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "service_id" | "user_id" | "requested_at" | "status" | "plan_id", ExtArgs["result"]["service_request"]>
  export type service_requestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | planDefaultArgs<ExtArgs>
    service?: boolean | serviceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $service_requestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_request"
    objects: {
      plan: Prisma.$planPayload<ExtArgs>
      service: Prisma.$servicePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      service_id: string
      user_id: string
      requested_at: Date
      status: string
      plan_id: string
    }, ExtArgs["result"]["service_request"]>
    composites: {}
  }

  type service_requestGetPayload<S extends boolean | null | undefined | service_requestDefaultArgs> = $Result.GetResult<Prisma.$service_requestPayload, S>

  type service_requestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_requestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_requestCountAggregateInputType | true
    }

  export interface service_requestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_request'], meta: { name: 'service_request' } }
    /**
     * Find zero or one Service_request that matches the filter.
     * @param {service_requestFindUniqueArgs} args - Arguments to find a Service_request
     * @example
     * // Get one Service_request
     * const service_request = await prisma.service_request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_requestFindUniqueArgs>(args: SelectSubset<T, service_requestFindUniqueArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_request that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_requestFindUniqueOrThrowArgs} args - Arguments to find a Service_request
     * @example
     * // Get one Service_request
     * const service_request = await prisma.service_request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_requestFindUniqueOrThrowArgs>(args: SelectSubset<T, service_requestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestFindFirstArgs} args - Arguments to find a Service_request
     * @example
     * // Get one Service_request
     * const service_request = await prisma.service_request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_requestFindFirstArgs>(args?: SelectSubset<T, service_requestFindFirstArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestFindFirstOrThrowArgs} args - Arguments to find a Service_request
     * @example
     * // Get one Service_request
     * const service_request = await prisma.service_request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_requestFindFirstOrThrowArgs>(args?: SelectSubset<T, service_requestFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_requests
     * const service_requests = await prisma.service_request.findMany()
     * 
     * // Get first 10 Service_requests
     * const service_requests = await prisma.service_request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_requestWithIdOnly = await prisma.service_request.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_requestFindManyArgs>(args?: SelectSubset<T, service_requestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_request.
     * @param {service_requestCreateArgs} args - Arguments to create a Service_request.
     * @example
     * // Create one Service_request
     * const Service_request = await prisma.service_request.create({
     *   data: {
     *     // ... data to create a Service_request
     *   }
     * })
     * 
     */
    create<T extends service_requestCreateArgs>(args: SelectSubset<T, service_requestCreateArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_requests.
     * @param {service_requestCreateManyArgs} args - Arguments to create many Service_requests.
     * @example
     * // Create many Service_requests
     * const service_request = await prisma.service_request.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_requestCreateManyArgs>(args?: SelectSubset<T, service_requestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service_request.
     * @param {service_requestDeleteArgs} args - Arguments to delete one Service_request.
     * @example
     * // Delete one Service_request
     * const Service_request = await prisma.service_request.delete({
     *   where: {
     *     // ... filter to delete one Service_request
     *   }
     * })
     * 
     */
    delete<T extends service_requestDeleteArgs>(args: SelectSubset<T, service_requestDeleteArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_request.
     * @param {service_requestUpdateArgs} args - Arguments to update one Service_request.
     * @example
     * // Update one Service_request
     * const service_request = await prisma.service_request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_requestUpdateArgs>(args: SelectSubset<T, service_requestUpdateArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_requests.
     * @param {service_requestDeleteManyArgs} args - Arguments to filter Service_requests to delete.
     * @example
     * // Delete a few Service_requests
     * const { count } = await prisma.service_request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_requestDeleteManyArgs>(args?: SelectSubset<T, service_requestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_requests
     * const service_request = await prisma.service_request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_requestUpdateManyArgs>(args: SelectSubset<T, service_requestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service_request.
     * @param {service_requestUpsertArgs} args - Arguments to update or create a Service_request.
     * @example
     * // Update or create a Service_request
     * const service_request = await prisma.service_request.upsert({
     *   create: {
     *     // ... data to create a Service_request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_request we want to update
     *   }
     * })
     */
    upsert<T extends service_requestUpsertArgs>(args: SelectSubset<T, service_requestUpsertArgs<ExtArgs>>): Prisma__service_requestClient<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestCountArgs} args - Arguments to filter Service_requests to count.
     * @example
     * // Count the number of Service_requests
     * const count = await prisma.service_request.count({
     *   where: {
     *     // ... the filter for the Service_requests we want to count
     *   }
     * })
    **/
    count<T extends service_requestCountArgs>(
      args?: Subset<T, service_requestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_requestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_requestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_requestAggregateArgs>(args: Subset<T, Service_requestAggregateArgs>): Prisma.PrismaPromise<GetService_requestAggregateType<T>>

    /**
     * Group by Service_request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_requestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_requestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_requestGroupByArgs['orderBy'] }
        : { orderBy?: service_requestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_requestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_requestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_request model
   */
  readonly fields: service_requestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_requestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends planDefaultArgs<ExtArgs> = {}>(args?: Subset<T, planDefaultArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_request model
   */
  interface service_requestFieldRefs {
    readonly id: FieldRef<"service_request", 'String'>
    readonly message: FieldRef<"service_request", 'String'>
    readonly service_id: FieldRef<"service_request", 'String'>
    readonly user_id: FieldRef<"service_request", 'String'>
    readonly requested_at: FieldRef<"service_request", 'DateTime'>
    readonly status: FieldRef<"service_request", 'String'>
    readonly plan_id: FieldRef<"service_request", 'String'>
  }
    

  // Custom InputTypes
  /**
   * service_request findUnique
   */
  export type service_requestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter, which service_request to fetch.
     */
    where: service_requestWhereUniqueInput
  }

  /**
   * service_request findUniqueOrThrow
   */
  export type service_requestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter, which service_request to fetch.
     */
    where: service_requestWhereUniqueInput
  }

  /**
   * service_request findFirst
   */
  export type service_requestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter, which service_request to fetch.
     */
    where?: service_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_requests to fetch.
     */
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_requests.
     */
    cursor?: service_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_requests.
     */
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * service_request findFirstOrThrow
   */
  export type service_requestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter, which service_request to fetch.
     */
    where?: service_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_requests to fetch.
     */
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_requests.
     */
    cursor?: service_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_requests.
     */
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * service_request findMany
   */
  export type service_requestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter, which service_requests to fetch.
     */
    where?: service_requestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_requests to fetch.
     */
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_requests.
     */
    cursor?: service_requestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_requests.
     */
    skip?: number
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * service_request create
   */
  export type service_requestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * The data needed to create a service_request.
     */
    data: XOR<service_requestCreateInput, service_requestUncheckedCreateInput>
  }

  /**
   * service_request createMany
   */
  export type service_requestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_requests.
     */
    data: service_requestCreateManyInput | service_requestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_request update
   */
  export type service_requestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * The data needed to update a service_request.
     */
    data: XOR<service_requestUpdateInput, service_requestUncheckedUpdateInput>
    /**
     * Choose, which service_request to update.
     */
    where: service_requestWhereUniqueInput
  }

  /**
   * service_request updateMany
   */
  export type service_requestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_requests.
     */
    data: XOR<service_requestUpdateManyMutationInput, service_requestUncheckedUpdateManyInput>
    /**
     * Filter which service_requests to update
     */
    where?: service_requestWhereInput
    /**
     * Limit how many service_requests to update.
     */
    limit?: number
  }

  /**
   * service_request upsert
   */
  export type service_requestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * The filter to search for the service_request to update in case it exists.
     */
    where: service_requestWhereUniqueInput
    /**
     * In case the service_request found by the `where` argument doesn't exist, create a new service_request with this data.
     */
    create: XOR<service_requestCreateInput, service_requestUncheckedCreateInput>
    /**
     * In case the service_request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_requestUpdateInput, service_requestUncheckedUpdateInput>
  }

  /**
   * service_request delete
   */
  export type service_requestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    /**
     * Filter which service_request to delete.
     */
    where: service_requestWhereUniqueInput
  }

  /**
   * service_request deleteMany
   */
  export type service_requestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_requests to delete
     */
    where?: service_requestWhereInput
    /**
     * Limit how many service_requests to delete.
     */
    limit?: number
  }

  /**
   * service_request without action
   */
  export type service_requestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
  }


  /**
   * Model case_studies
   */

  export type AggregateCase_studies = {
    _count: Case_studiesCountAggregateOutputType | null
    _min: Case_studiesMinAggregateOutputType | null
    _max: Case_studiesMaxAggregateOutputType | null
  }

  export type Case_studiesMinAggregateOutputType = {
    id: string | null
    banner: string | null
    challenge: string | null
    challenge_img: string | null
    solution: string | null
    solution_img: string | null
    result: string | null
    result_img: string | null
    service_id: string | null
    organisation_id: string | null
  }

  export type Case_studiesMaxAggregateOutputType = {
    id: string | null
    banner: string | null
    challenge: string | null
    challenge_img: string | null
    solution: string | null
    solution_img: string | null
    result: string | null
    result_img: string | null
    service_id: string | null
    organisation_id: string | null
  }

  export type Case_studiesCountAggregateOutputType = {
    id: number
    banner: number
    challenge: number
    challenge_img: number
    solution: number
    solution_img: number
    result: number
    result_img: number
    service_id: number
    organisation_id: number
    _all: number
  }


  export type Case_studiesMinAggregateInputType = {
    id?: true
    banner?: true
    challenge?: true
    challenge_img?: true
    solution?: true
    solution_img?: true
    result?: true
    result_img?: true
    service_id?: true
    organisation_id?: true
  }

  export type Case_studiesMaxAggregateInputType = {
    id?: true
    banner?: true
    challenge?: true
    challenge_img?: true
    solution?: true
    solution_img?: true
    result?: true
    result_img?: true
    service_id?: true
    organisation_id?: true
  }

  export type Case_studiesCountAggregateInputType = {
    id?: true
    banner?: true
    challenge?: true
    challenge_img?: true
    solution?: true
    solution_img?: true
    result?: true
    result_img?: true
    service_id?: true
    organisation_id?: true
    _all?: true
  }

  export type Case_studiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_studies to aggregate.
     */
    where?: case_studiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_studies to fetch.
     */
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: case_studiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned case_studies
    **/
    _count?: true | Case_studiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Case_studiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Case_studiesMaxAggregateInputType
  }

  export type GetCase_studiesAggregateType<T extends Case_studiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCase_studies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCase_studies[P]>
      : GetScalarType<T[P], AggregateCase_studies[P]>
  }




  export type case_studiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: case_studiesWhereInput
    orderBy?: case_studiesOrderByWithAggregationInput | case_studiesOrderByWithAggregationInput[]
    by: Case_studiesScalarFieldEnum[] | Case_studiesScalarFieldEnum
    having?: case_studiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Case_studiesCountAggregateInputType | true
    _min?: Case_studiesMinAggregateInputType
    _max?: Case_studiesMaxAggregateInputType
  }

  export type Case_studiesGroupByOutputType = {
    id: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service_id: string
    organisation_id: string
    _count: Case_studiesCountAggregateOutputType | null
    _min: Case_studiesMinAggregateOutputType | null
    _max: Case_studiesMaxAggregateOutputType | null
  }

  type GetCase_studiesGroupByPayload<T extends case_studiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Case_studiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Case_studiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Case_studiesGroupByOutputType[P]>
            : GetScalarType<T[P], Case_studiesGroupByOutputType[P]>
        }
      >
    >


  export type case_studiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banner?: boolean
    challenge?: boolean
    challenge_img?: boolean
    solution?: boolean
    solution_img?: boolean
    result?: boolean
    result_img?: boolean
    service_id?: boolean
    organisation_id?: boolean
    organisation?: boolean | organisationDefaultArgs<ExtArgs>
    service?: boolean | serviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["case_studies"]>



  export type case_studiesSelectScalar = {
    id?: boolean
    banner?: boolean
    challenge?: boolean
    challenge_img?: boolean
    solution?: boolean
    solution_img?: boolean
    result?: boolean
    result_img?: boolean
    service_id?: boolean
    organisation_id?: boolean
  }

  export type case_studiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "banner" | "challenge" | "challenge_img" | "solution" | "solution_img" | "result" | "result_img" | "service_id" | "organisation_id", ExtArgs["result"]["case_studies"]>
  export type case_studiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | organisationDefaultArgs<ExtArgs>
    service?: boolean | serviceDefaultArgs<ExtArgs>
  }

  export type $case_studiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "case_studies"
    objects: {
      organisation: Prisma.$organisationPayload<ExtArgs>
      service: Prisma.$servicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      banner: string
      challenge: string
      challenge_img: string
      solution: string
      solution_img: string
      result: string
      result_img: string
      service_id: string
      organisation_id: string
    }, ExtArgs["result"]["case_studies"]>
    composites: {}
  }

  type case_studiesGetPayload<S extends boolean | null | undefined | case_studiesDefaultArgs> = $Result.GetResult<Prisma.$case_studiesPayload, S>

  type case_studiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<case_studiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Case_studiesCountAggregateInputType | true
    }

  export interface case_studiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['case_studies'], meta: { name: 'case_studies' } }
    /**
     * Find zero or one Case_studies that matches the filter.
     * @param {case_studiesFindUniqueArgs} args - Arguments to find a Case_studies
     * @example
     * // Get one Case_studies
     * const case_studies = await prisma.case_studies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends case_studiesFindUniqueArgs>(args: SelectSubset<T, case_studiesFindUniqueArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Case_studies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {case_studiesFindUniqueOrThrowArgs} args - Arguments to find a Case_studies
     * @example
     * // Get one Case_studies
     * const case_studies = await prisma.case_studies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends case_studiesFindUniqueOrThrowArgs>(args: SelectSubset<T, case_studiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_studies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesFindFirstArgs} args - Arguments to find a Case_studies
     * @example
     * // Get one Case_studies
     * const case_studies = await prisma.case_studies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends case_studiesFindFirstArgs>(args?: SelectSubset<T, case_studiesFindFirstArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Case_studies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesFindFirstOrThrowArgs} args - Arguments to find a Case_studies
     * @example
     * // Get one Case_studies
     * const case_studies = await prisma.case_studies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends case_studiesFindFirstOrThrowArgs>(args?: SelectSubset<T, case_studiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Case_studies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Case_studies
     * const case_studies = await prisma.case_studies.findMany()
     * 
     * // Get first 10 Case_studies
     * const case_studies = await prisma.case_studies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const case_studiesWithIdOnly = await prisma.case_studies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends case_studiesFindManyArgs>(args?: SelectSubset<T, case_studiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Case_studies.
     * @param {case_studiesCreateArgs} args - Arguments to create a Case_studies.
     * @example
     * // Create one Case_studies
     * const Case_studies = await prisma.case_studies.create({
     *   data: {
     *     // ... data to create a Case_studies
     *   }
     * })
     * 
     */
    create<T extends case_studiesCreateArgs>(args: SelectSubset<T, case_studiesCreateArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Case_studies.
     * @param {case_studiesCreateManyArgs} args - Arguments to create many Case_studies.
     * @example
     * // Create many Case_studies
     * const case_studies = await prisma.case_studies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends case_studiesCreateManyArgs>(args?: SelectSubset<T, case_studiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Case_studies.
     * @param {case_studiesDeleteArgs} args - Arguments to delete one Case_studies.
     * @example
     * // Delete one Case_studies
     * const Case_studies = await prisma.case_studies.delete({
     *   where: {
     *     // ... filter to delete one Case_studies
     *   }
     * })
     * 
     */
    delete<T extends case_studiesDeleteArgs>(args: SelectSubset<T, case_studiesDeleteArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Case_studies.
     * @param {case_studiesUpdateArgs} args - Arguments to update one Case_studies.
     * @example
     * // Update one Case_studies
     * const case_studies = await prisma.case_studies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends case_studiesUpdateArgs>(args: SelectSubset<T, case_studiesUpdateArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Case_studies.
     * @param {case_studiesDeleteManyArgs} args - Arguments to filter Case_studies to delete.
     * @example
     * // Delete a few Case_studies
     * const { count } = await prisma.case_studies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends case_studiesDeleteManyArgs>(args?: SelectSubset<T, case_studiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Case_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Case_studies
     * const case_studies = await prisma.case_studies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends case_studiesUpdateManyArgs>(args: SelectSubset<T, case_studiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Case_studies.
     * @param {case_studiesUpsertArgs} args - Arguments to update or create a Case_studies.
     * @example
     * // Update or create a Case_studies
     * const case_studies = await prisma.case_studies.upsert({
     *   create: {
     *     // ... data to create a Case_studies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Case_studies we want to update
     *   }
     * })
     */
    upsert<T extends case_studiesUpsertArgs>(args: SelectSubset<T, case_studiesUpsertArgs<ExtArgs>>): Prisma__case_studiesClient<$Result.GetResult<Prisma.$case_studiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Case_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesCountArgs} args - Arguments to filter Case_studies to count.
     * @example
     * // Count the number of Case_studies
     * const count = await prisma.case_studies.count({
     *   where: {
     *     // ... the filter for the Case_studies we want to count
     *   }
     * })
    **/
    count<T extends case_studiesCountArgs>(
      args?: Subset<T, case_studiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Case_studiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Case_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Case_studiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Case_studiesAggregateArgs>(args: Subset<T, Case_studiesAggregateArgs>): Prisma.PrismaPromise<GetCase_studiesAggregateType<T>>

    /**
     * Group by Case_studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {case_studiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends case_studiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: case_studiesGroupByArgs['orderBy'] }
        : { orderBy?: case_studiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, case_studiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCase_studiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the case_studies model
   */
  readonly fields: case_studiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for case_studies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__case_studiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends organisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organisationDefaultArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the case_studies model
   */
  interface case_studiesFieldRefs {
    readonly id: FieldRef<"case_studies", 'String'>
    readonly banner: FieldRef<"case_studies", 'String'>
    readonly challenge: FieldRef<"case_studies", 'String'>
    readonly challenge_img: FieldRef<"case_studies", 'String'>
    readonly solution: FieldRef<"case_studies", 'String'>
    readonly solution_img: FieldRef<"case_studies", 'String'>
    readonly result: FieldRef<"case_studies", 'String'>
    readonly result_img: FieldRef<"case_studies", 'String'>
    readonly service_id: FieldRef<"case_studies", 'String'>
    readonly organisation_id: FieldRef<"case_studies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * case_studies findUnique
   */
  export type case_studiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter, which case_studies to fetch.
     */
    where: case_studiesWhereUniqueInput
  }

  /**
   * case_studies findUniqueOrThrow
   */
  export type case_studiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter, which case_studies to fetch.
     */
    where: case_studiesWhereUniqueInput
  }

  /**
   * case_studies findFirst
   */
  export type case_studiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter, which case_studies to fetch.
     */
    where?: case_studiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_studies to fetch.
     */
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_studies.
     */
    cursor?: case_studiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_studies.
     */
    distinct?: Case_studiesScalarFieldEnum | Case_studiesScalarFieldEnum[]
  }

  /**
   * case_studies findFirstOrThrow
   */
  export type case_studiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter, which case_studies to fetch.
     */
    where?: case_studiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_studies to fetch.
     */
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for case_studies.
     */
    cursor?: case_studiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of case_studies.
     */
    distinct?: Case_studiesScalarFieldEnum | Case_studiesScalarFieldEnum[]
  }

  /**
   * case_studies findMany
   */
  export type case_studiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter, which case_studies to fetch.
     */
    where?: case_studiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of case_studies to fetch.
     */
    orderBy?: case_studiesOrderByWithRelationInput | case_studiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing case_studies.
     */
    cursor?: case_studiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` case_studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` case_studies.
     */
    skip?: number
    distinct?: Case_studiesScalarFieldEnum | Case_studiesScalarFieldEnum[]
  }

  /**
   * case_studies create
   */
  export type case_studiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * The data needed to create a case_studies.
     */
    data: XOR<case_studiesCreateInput, case_studiesUncheckedCreateInput>
  }

  /**
   * case_studies createMany
   */
  export type case_studiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many case_studies.
     */
    data: case_studiesCreateManyInput | case_studiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * case_studies update
   */
  export type case_studiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * The data needed to update a case_studies.
     */
    data: XOR<case_studiesUpdateInput, case_studiesUncheckedUpdateInput>
    /**
     * Choose, which case_studies to update.
     */
    where: case_studiesWhereUniqueInput
  }

  /**
   * case_studies updateMany
   */
  export type case_studiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update case_studies.
     */
    data: XOR<case_studiesUpdateManyMutationInput, case_studiesUncheckedUpdateManyInput>
    /**
     * Filter which case_studies to update
     */
    where?: case_studiesWhereInput
    /**
     * Limit how many case_studies to update.
     */
    limit?: number
  }

  /**
   * case_studies upsert
   */
  export type case_studiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * The filter to search for the case_studies to update in case it exists.
     */
    where: case_studiesWhereUniqueInput
    /**
     * In case the case_studies found by the `where` argument doesn't exist, create a new case_studies with this data.
     */
    create: XOR<case_studiesCreateInput, case_studiesUncheckedCreateInput>
    /**
     * In case the case_studies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<case_studiesUpdateInput, case_studiesUncheckedUpdateInput>
  }

  /**
   * case_studies delete
   */
  export type case_studiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
    /**
     * Filter which case_studies to delete.
     */
    where: case_studiesWhereUniqueInput
  }

  /**
   * case_studies deleteMany
   */
  export type case_studiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which case_studies to delete
     */
    where?: case_studiesWhereInput
    /**
     * Limit how many case_studies to delete.
     */
    limit?: number
  }

  /**
   * case_studies without action
   */
  export type case_studiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the case_studies
     */
    select?: case_studiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the case_studies
     */
    omit?: case_studiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: case_studiesInclude<ExtArgs> | null
  }


  /**
   * Model testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    stars: Decimal | null
  }

  export type TestimonialSumAggregateOutputType = {
    stars: Decimal | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    message: string | null
    user_id: string | null
    service_id: string | null
    stars: Decimal | null
    user_title: string | null
    deleted_at: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    message: string | null
    user_id: string | null
    service_id: string | null
    stars: Decimal | null
    user_title: string | null
    deleted_at: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    message: number
    user_id: number
    service_id: number
    stars: number
    user_title: number
    deleted_at: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    stars?: true
  }

  export type TestimonialSumAggregateInputType = {
    stars?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    message?: true
    user_id?: true
    service_id?: true
    stars?: true
    user_title?: true
    deleted_at?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    message?: true
    user_id?: true
    service_id?: true
    stars?: true
    user_title?: true
    deleted_at?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    message?: true
    user_id?: true
    service_id?: true
    stars?: true
    user_title?: true
    deleted_at?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonial to aggregate.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type testimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialWhereInput
    orderBy?: testimonialOrderByWithAggregationInput | testimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: testimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    message: string
    user_id: string
    service_id: string
    stars: Decimal
    user_title: string
    deleted_at: Date | null
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends testimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type testimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    user_id?: boolean
    service_id?: boolean
    stars?: boolean
    user_title?: boolean
    deleted_at?: boolean
    service?: boolean | serviceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>



  export type testimonialSelectScalar = {
    id?: boolean
    message?: boolean
    user_id?: boolean
    service_id?: boolean
    stars?: boolean
    user_title?: boolean
    deleted_at?: boolean
  }

  export type testimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "user_id" | "service_id" | "stars" | "user_title" | "deleted_at", ExtArgs["result"]["testimonial"]>
  export type testimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | serviceDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $testimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testimonial"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      user_id: string
      service_id: string
      stars: Prisma.Decimal
      user_title: string
      deleted_at: Date | null
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type testimonialGetPayload<S extends boolean | null | undefined | testimonialDefaultArgs> = $Result.GetResult<Prisma.$testimonialPayload, S>

  type testimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface testimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testimonial'], meta: { name: 'testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {testimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testimonialFindUniqueArgs>(args: SelectSubset<T, testimonialFindUniqueArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, testimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testimonialFindFirstArgs>(args?: SelectSubset<T, testimonialFindFirstArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, testimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testimonialFindManyArgs>(args?: SelectSubset<T, testimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {testimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends testimonialCreateArgs>(args: SelectSubset<T, testimonialCreateArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {testimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testimonialCreateManyArgs>(args?: SelectSubset<T, testimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonial.
     * @param {testimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends testimonialDeleteArgs>(args: SelectSubset<T, testimonialDeleteArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {testimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testimonialUpdateArgs>(args: SelectSubset<T, testimonialUpdateArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {testimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testimonialDeleteManyArgs>(args?: SelectSubset<T, testimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testimonialUpdateManyArgs>(args: SelectSubset<T, testimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {testimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends testimonialUpsertArgs>(args: SelectSubset<T, testimonialUpsertArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends testimonialCountArgs>(
      args?: Subset<T, testimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testimonialGroupByArgs['orderBy'] }
        : { orderBy?: testimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testimonial model
   */
  readonly fields: testimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testimonial model
   */
  interface testimonialFieldRefs {
    readonly id: FieldRef<"testimonial", 'String'>
    readonly message: FieldRef<"testimonial", 'String'>
    readonly user_id: FieldRef<"testimonial", 'String'>
    readonly service_id: FieldRef<"testimonial", 'String'>
    readonly stars: FieldRef<"testimonial", 'Decimal'>
    readonly user_title: FieldRef<"testimonial", 'String'>
    readonly deleted_at: FieldRef<"testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testimonial findUnique
   */
  export type testimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial findUniqueOrThrow
   */
  export type testimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial findFirst
   */
  export type testimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial findFirstOrThrow
   */
  export type testimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial findMany
   */
  export type testimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial create
   */
  export type testimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a testimonial.
     */
    data: XOR<testimonialCreateInput, testimonialUncheckedCreateInput>
  }

  /**
   * testimonial createMany
   */
  export type testimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testimonials.
     */
    data: testimonialCreateManyInput | testimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testimonial update
   */
  export type testimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a testimonial.
     */
    data: XOR<testimonialUpdateInput, testimonialUncheckedUpdateInput>
    /**
     * Choose, which testimonial to update.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial updateMany
   */
  export type testimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testimonials.
     */
    data: XOR<testimonialUpdateManyMutationInput, testimonialUncheckedUpdateManyInput>
    /**
     * Filter which testimonials to update
     */
    where?: testimonialWhereInput
    /**
     * Limit how many testimonials to update.
     */
    limit?: number
  }

  /**
   * testimonial upsert
   */
  export type testimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the testimonial to update in case it exists.
     */
    where: testimonialWhereUniqueInput
    /**
     * In case the testimonial found by the `where` argument doesn't exist, create a new testimonial with this data.
     */
    create: XOR<testimonialCreateInput, testimonialUncheckedCreateInput>
    /**
     * In case the testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testimonialUpdateInput, testimonialUncheckedUpdateInput>
  }

  /**
   * testimonial delete
   */
  export type testimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter which testimonial to delete.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial deleteMany
   */
  export type testimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonials to delete
     */
    where?: testimonialWhereInput
    /**
     * Limit how many testimonials to delete.
     */
    limit?: number
  }

  /**
   * testimonial without action
   */
  export type testimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testimonial
     */
    omit?: testimonialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
  }


  /**
   * Model contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    pfp_url: string | null
    organisation_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pfp_url: string | null
    organisation_id: string | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    pfp_url: number
    organisation_id: number
    id_url: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    created_at?: true
    deleted_at?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    pfp_url?: true
    organisation_id?: true
    id_url?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact to aggregate.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactWhereInput
    orderBy?: contactOrderByWithAggregationInput | contactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonValue
    created_at: Date | null
    deleted_at: Date | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pfp_url?: boolean
    organisation_id?: boolean
    id_url?: boolean
    created_at?: boolean
    deleted_at?: boolean
    organisation?: boolean | organisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type contactSelectScalar = {
    id?: boolean
    name?: boolean
    pfp_url?: boolean
    organisation_id?: boolean
    id_url?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type contactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pfp_url" | "organisation_id" | "id_url" | "created_at" | "deleted_at", ExtArgs["result"]["contact"]>
  export type contactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | organisationDefaultArgs<ExtArgs>
  }

  export type $contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact"
    objects: {
      organisation: Prisma.$organisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      pfp_url: string
      organisation_id: string
      id_url: Prisma.JsonValue
      created_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type contactGetPayload<S extends boolean | null | undefined | contactDefaultArgs> = $Result.GetResult<Prisma.$contactPayload, S>

  type contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact'], meta: { name: 'contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {contactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactFindUniqueArgs>(args: SelectSubset<T, contactFindUniqueArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactFindUniqueOrThrowArgs>(args: SelectSubset<T, contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactFindFirstArgs>(args?: SelectSubset<T, contactFindFirstArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactFindFirstOrThrowArgs>(args?: SelectSubset<T, contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactFindManyArgs>(args?: SelectSubset<T, contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {contactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends contactCreateArgs>(args: SelectSubset<T, contactCreateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {contactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactCreateManyArgs>(args?: SelectSubset<T, contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {contactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends contactDeleteArgs>(args: SelectSubset<T, contactDeleteArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {contactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactUpdateArgs>(args: SelectSubset<T, contactUpdateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {contactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactDeleteManyArgs>(args?: SelectSubset<T, contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactUpdateManyArgs>(args: SelectSubset<T, contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {contactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends contactUpsertArgs>(args: SelectSubset<T, contactUpsertArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactCountArgs>(
      args?: Subset<T, contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactGroupByArgs['orderBy'] }
        : { orderBy?: contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact model
   */
  readonly fields: contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends organisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organisationDefaultArgs<ExtArgs>>): Prisma__organisationClient<$Result.GetResult<Prisma.$organisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact model
   */
  interface contactFieldRefs {
    readonly id: FieldRef<"contact", 'String'>
    readonly name: FieldRef<"contact", 'String'>
    readonly pfp_url: FieldRef<"contact", 'String'>
    readonly organisation_id: FieldRef<"contact", 'String'>
    readonly id_url: FieldRef<"contact", 'Json'>
    readonly created_at: FieldRef<"contact", 'DateTime'>
    readonly deleted_at: FieldRef<"contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact findUnique
   */
  export type contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findUniqueOrThrow
   */
  export type contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findFirst
   */
  export type contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findFirstOrThrow
   */
  export type contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findMany
   */
  export type contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact create
   */
  export type contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * The data needed to create a contact.
     */
    data: XOR<contactCreateInput, contactUncheckedCreateInput>
  }

  /**
   * contact createMany
   */
  export type contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactCreateManyInput | contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact update
   */
  export type contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * The data needed to update a contact.
     */
    data: XOR<contactUpdateInput, contactUncheckedUpdateInput>
    /**
     * Choose, which contact to update.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact updateMany
   */
  export type contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactUpdateManyMutationInput, contactUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
  }

  /**
   * contact upsert
   */
  export type contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * The filter to search for the contact to update in case it exists.
     */
    where: contactWhereUniqueInput
    /**
     * In case the contact found by the `where` argument doesn't exist, create a new contact with this data.
     */
    create: XOR<contactCreateInput, contactUncheckedCreateInput>
    /**
     * In case the contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactUpdateInput, contactUncheckedUpdateInput>
  }

  /**
   * contact delete
   */
  export type contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
    /**
     * Filter which contact to delete.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact deleteMany
   */
  export type contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactWhereInput
    /**
     * Limit how many contacts to delete.
     */
    limit?: number
  }

  /**
   * contact without action
   */
  export type contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactInclude<ExtArgs> | null
  }


  /**
   * Model otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    otp: string | null
    expires_at: Date | null
    created_at: Date | null
    user_id: string | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    otp: number
    expires_at: number
    created_at: number
    user_id: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    otp?: true
    expires_at?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp to aggregate.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otpWhereInput
    orderBy?: otpOrderByWithAggregationInput | otpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    otp: string
    expires_at: Date | null
    created_at: Date | null
    user_id: string
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type otpSelectScalar = {
    id?: boolean
    otp?: boolean
    expires_at?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type otpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "otp" | "expires_at" | "created_at" | "user_id", ExtArgs["result"]["otp"]>
  export type otpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otp"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      otp: string
      expires_at: Date | null
      created_at: Date | null
      user_id: string
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type otpGetPayload<S extends boolean | null | undefined | otpDefaultArgs> = $Result.GetResult<Prisma.$otpPayload, S>

  type otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<otpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otp'], meta: { name: 'otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {otpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends otpFindUniqueArgs>(args: SelectSubset<T, otpFindUniqueArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {otpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends otpFindUniqueOrThrowArgs>(args: SelectSubset<T, otpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends otpFindFirstArgs>(args?: SelectSubset<T, otpFindFirstArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends otpFindFirstOrThrowArgs>(args?: SelectSubset<T, otpFindFirstOrThrowArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends otpFindManyArgs>(args?: SelectSubset<T, otpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {otpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends otpCreateArgs>(args: SelectSubset<T, otpCreateArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {otpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends otpCreateManyArgs>(args?: SelectSubset<T, otpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {otpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends otpDeleteArgs>(args: SelectSubset<T, otpDeleteArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {otpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends otpUpdateArgs>(args: SelectSubset<T, otpUpdateArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {otpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends otpDeleteManyArgs>(args?: SelectSubset<T, otpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends otpUpdateManyArgs>(args: SelectSubset<T, otpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {otpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends otpUpsertArgs>(args: SelectSubset<T, otpUpsertArgs<ExtArgs>>): Prisma__otpClient<$Result.GetResult<Prisma.$otpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends otpCountArgs>(
      args?: Subset<T, otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otpGroupByArgs['orderBy'] }
        : { orderBy?: otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otp model
   */
  readonly fields: otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the otp model
   */
  interface otpFieldRefs {
    readonly id: FieldRef<"otp", 'String'>
    readonly otp: FieldRef<"otp", 'String'>
    readonly expires_at: FieldRef<"otp", 'DateTime'>
    readonly created_at: FieldRef<"otp", 'DateTime'>
    readonly user_id: FieldRef<"otp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * otp findUnique
   */
  export type otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findUniqueOrThrow
   */
  export type otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp findFirst
   */
  export type otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findFirstOrThrow
   */
  export type otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otp to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp findMany
   */
  export type otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter, which otps to fetch.
     */
    where?: otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otps to fetch.
     */
    orderBy?: otpOrderByWithRelationInput | otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otps.
     */
    cursor?: otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * otp create
   */
  export type otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to create a otp.
     */
    data: XOR<otpCreateInput, otpUncheckedCreateInput>
  }

  /**
   * otp createMany
   */
  export type otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otps.
     */
    data: otpCreateManyInput | otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otp update
   */
  export type otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The data needed to update a otp.
     */
    data: XOR<otpUpdateInput, otpUncheckedUpdateInput>
    /**
     * Choose, which otp to update.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp updateMany
   */
  export type otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otps.
     */
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyInput>
    /**
     * Filter which otps to update
     */
    where?: otpWhereInput
    /**
     * Limit how many otps to update.
     */
    limit?: number
  }

  /**
   * otp upsert
   */
  export type otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * The filter to search for the otp to update in case it exists.
     */
    where: otpWhereUniqueInput
    /**
     * In case the otp found by the `where` argument doesn't exist, create a new otp with this data.
     */
    create: XOR<otpCreateInput, otpUncheckedCreateInput>
    /**
     * In case the otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otpUpdateInput, otpUncheckedUpdateInput>
  }

  /**
   * otp delete
   */
  export type otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
    /**
     * Filter which otp to delete.
     */
    where: otpWhereUniqueInput
  }

  /**
   * otp deleteMany
   */
  export type otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otps to delete
     */
    where?: otpWhereInput
    /**
     * Limit how many otps to delete.
     */
    limit?: number
  }

  /**
   * otp without action
   */
  export type otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp
     */
    select?: otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the otp
     */
    omit?: otpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: otpInclude<ExtArgs> | null
  }


  /**
   * Model password_token
   */

  export type AggregatePassword_token = {
    _count: Password_tokenCountAggregateOutputType | null
    _min: Password_tokenMinAggregateOutputType | null
    _max: Password_tokenMaxAggregateOutputType | null
  }

  export type Password_tokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    expires_at: Date | null
    user_id: string | null
  }

  export type Password_tokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    expires_at: Date | null
    user_id: string | null
  }

  export type Password_tokenCountAggregateOutputType = {
    id: number
    token: number
    created_at: number
    expires_at: number
    user_id: number
    _all: number
  }


  export type Password_tokenMinAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
  }

  export type Password_tokenMaxAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
  }

  export type Password_tokenCountAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    expires_at?: true
    user_id?: true
    _all?: true
  }

  export type Password_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_token to aggregate.
     */
    where?: password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_tokens to fetch.
     */
    orderBy?: password_tokenOrderByWithRelationInput | password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_tokens
    **/
    _count?: true | Password_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_tokenMaxAggregateInputType
  }

  export type GetPassword_tokenAggregateType<T extends Password_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_token[P]>
      : GetScalarType<T[P], AggregatePassword_token[P]>
  }




  export type password_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_tokenWhereInput
    orderBy?: password_tokenOrderByWithAggregationInput | password_tokenOrderByWithAggregationInput[]
    by: Password_tokenScalarFieldEnum[] | Password_tokenScalarFieldEnum
    having?: password_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_tokenCountAggregateInputType | true
    _min?: Password_tokenMinAggregateInputType
    _max?: Password_tokenMaxAggregateInputType
  }

  export type Password_tokenGroupByOutputType = {
    id: string
    token: string
    created_at: Date | null
    expires_at: Date | null
    user_id: string
    _count: Password_tokenCountAggregateOutputType | null
    _min: Password_tokenMinAggregateOutputType | null
    _max: Password_tokenMaxAggregateOutputType | null
  }

  type GetPassword_tokenGroupByPayload<T extends password_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Password_tokenGroupByOutputType[P]>
        }
      >
    >


  export type password_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    created_at?: boolean
    expires_at?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_token"]>



  export type password_tokenSelectScalar = {
    id?: boolean
    token?: boolean
    created_at?: boolean
    expires_at?: boolean
    user_id?: boolean
  }

  export type password_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "created_at" | "expires_at" | "user_id", ExtArgs["result"]["password_token"]>
  export type password_tokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $password_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_token"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      created_at: Date | null
      expires_at: Date | null
      user_id: string
    }, ExtArgs["result"]["password_token"]>
    composites: {}
  }

  type password_tokenGetPayload<S extends boolean | null | undefined | password_tokenDefaultArgs> = $Result.GetResult<Prisma.$password_tokenPayload, S>

  type password_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_tokenCountAggregateInputType | true
    }

  export interface password_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_token'], meta: { name: 'password_token' } }
    /**
     * Find zero or one Password_token that matches the filter.
     * @param {password_tokenFindUniqueArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_tokenFindUniqueArgs>(args: SelectSubset<T, password_tokenFindUniqueArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_tokenFindUniqueOrThrowArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, password_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenFindFirstArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_tokenFindFirstArgs>(args?: SelectSubset<T, password_tokenFindFirstArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenFindFirstOrThrowArgs} args - Arguments to find a Password_token
     * @example
     * // Get one Password_token
     * const password_token = await prisma.password_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, password_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_tokens
     * const password_tokens = await prisma.password_token.findMany()
     * 
     * // Get first 10 Password_tokens
     * const password_tokens = await prisma.password_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_tokenWithIdOnly = await prisma.password_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends password_tokenFindManyArgs>(args?: SelectSubset<T, password_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_token.
     * @param {password_tokenCreateArgs} args - Arguments to create a Password_token.
     * @example
     * // Create one Password_token
     * const Password_token = await prisma.password_token.create({
     *   data: {
     *     // ... data to create a Password_token
     *   }
     * })
     * 
     */
    create<T extends password_tokenCreateArgs>(args: SelectSubset<T, password_tokenCreateArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_tokens.
     * @param {password_tokenCreateManyArgs} args - Arguments to create many Password_tokens.
     * @example
     * // Create many Password_tokens
     * const password_token = await prisma.password_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_tokenCreateManyArgs>(args?: SelectSubset<T, password_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Password_token.
     * @param {password_tokenDeleteArgs} args - Arguments to delete one Password_token.
     * @example
     * // Delete one Password_token
     * const Password_token = await prisma.password_token.delete({
     *   where: {
     *     // ... filter to delete one Password_token
     *   }
     * })
     * 
     */
    delete<T extends password_tokenDeleteArgs>(args: SelectSubset<T, password_tokenDeleteArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_token.
     * @param {password_tokenUpdateArgs} args - Arguments to update one Password_token.
     * @example
     * // Update one Password_token
     * const password_token = await prisma.password_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_tokenUpdateArgs>(args: SelectSubset<T, password_tokenUpdateArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_tokens.
     * @param {password_tokenDeleteManyArgs} args - Arguments to filter Password_tokens to delete.
     * @example
     * // Delete a few Password_tokens
     * const { count } = await prisma.password_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_tokenDeleteManyArgs>(args?: SelectSubset<T, password_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_tokens
     * const password_token = await prisma.password_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_tokenUpdateManyArgs>(args: SelectSubset<T, password_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_token.
     * @param {password_tokenUpsertArgs} args - Arguments to update or create a Password_token.
     * @example
     * // Update or create a Password_token
     * const password_token = await prisma.password_token.upsert({
     *   create: {
     *     // ... data to create a Password_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_token we want to update
     *   }
     * })
     */
    upsert<T extends password_tokenUpsertArgs>(args: SelectSubset<T, password_tokenUpsertArgs<ExtArgs>>): Prisma__password_tokenClient<$Result.GetResult<Prisma.$password_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenCountArgs} args - Arguments to filter Password_tokens to count.
     * @example
     * // Count the number of Password_tokens
     * const count = await prisma.password_token.count({
     *   where: {
     *     // ... the filter for the Password_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_tokenCountArgs>(
      args?: Subset<T, password_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_tokenAggregateArgs>(args: Subset<T, Password_tokenAggregateArgs>): Prisma.PrismaPromise<GetPassword_tokenAggregateType<T>>

    /**
     * Group by Password_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_tokenGroupByArgs['orderBy'] }
        : { orderBy?: password_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_token model
   */
  readonly fields: password_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_token model
   */
  interface password_tokenFieldRefs {
    readonly id: FieldRef<"password_token", 'String'>
    readonly token: FieldRef<"password_token", 'String'>
    readonly created_at: FieldRef<"password_token", 'DateTime'>
    readonly expires_at: FieldRef<"password_token", 'DateTime'>
    readonly user_id: FieldRef<"password_token", 'String'>
  }
    

  // Custom InputTypes
  /**
   * password_token findUnique
   */
  export type password_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which password_token to fetch.
     */
    where: password_tokenWhereUniqueInput
  }

  /**
   * password_token findUniqueOrThrow
   */
  export type password_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which password_token to fetch.
     */
    where: password_tokenWhereUniqueInput
  }

  /**
   * password_token findFirst
   */
  export type password_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which password_token to fetch.
     */
    where?: password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_tokens to fetch.
     */
    orderBy?: password_tokenOrderByWithRelationInput | password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_tokens.
     */
    cursor?: password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_tokens.
     */
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * password_token findFirstOrThrow
   */
  export type password_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which password_token to fetch.
     */
    where?: password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_tokens to fetch.
     */
    orderBy?: password_tokenOrderByWithRelationInput | password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_tokens.
     */
    cursor?: password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_tokens.
     */
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * password_token findMany
   */
  export type password_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter, which password_tokens to fetch.
     */
    where?: password_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_tokens to fetch.
     */
    orderBy?: password_tokenOrderByWithRelationInput | password_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_tokens.
     */
    cursor?: password_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_tokens.
     */
    skip?: number
    distinct?: Password_tokenScalarFieldEnum | Password_tokenScalarFieldEnum[]
  }

  /**
   * password_token create
   */
  export type password_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * The data needed to create a password_token.
     */
    data: XOR<password_tokenCreateInput, password_tokenUncheckedCreateInput>
  }

  /**
   * password_token createMany
   */
  export type password_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_tokens.
     */
    data: password_tokenCreateManyInput | password_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_token update
   */
  export type password_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * The data needed to update a password_token.
     */
    data: XOR<password_tokenUpdateInput, password_tokenUncheckedUpdateInput>
    /**
     * Choose, which password_token to update.
     */
    where: password_tokenWhereUniqueInput
  }

  /**
   * password_token updateMany
   */
  export type password_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_tokens.
     */
    data: XOR<password_tokenUpdateManyMutationInput, password_tokenUncheckedUpdateManyInput>
    /**
     * Filter which password_tokens to update
     */
    where?: password_tokenWhereInput
    /**
     * Limit how many password_tokens to update.
     */
    limit?: number
  }

  /**
   * password_token upsert
   */
  export type password_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * The filter to search for the password_token to update in case it exists.
     */
    where: password_tokenWhereUniqueInput
    /**
     * In case the password_token found by the `where` argument doesn't exist, create a new password_token with this data.
     */
    create: XOR<password_tokenCreateInput, password_tokenUncheckedCreateInput>
    /**
     * In case the password_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_tokenUpdateInput, password_tokenUncheckedUpdateInput>
  }

  /**
   * password_token delete
   */
  export type password_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
    /**
     * Filter which password_token to delete.
     */
    where: password_tokenWhereUniqueInput
  }

  /**
   * password_token deleteMany
   */
  export type password_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_tokens to delete
     */
    where?: password_tokenWhereInput
    /**
     * Limit how many password_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_token without action
   */
  export type password_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_token
     */
    select?: password_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_token
     */
    omit?: password_tokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_tokenInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    activity: string | null
    completed_at: Date | null
    user_id: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    activity: string | null
    completed_at: Date | null
    user_id: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    activity: number
    completed_at: number
    user_id: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    activity?: true
    completed_at?: true
    user_id?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    activity: string
    completed_at: Date | null
    user_id: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity?: boolean
    completed_at?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type notificationSelectScalar = {
    id?: boolean
    activity?: boolean
    completed_at?: boolean
    user_id?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activity" | "completed_at" | "user_id", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activity: string
      completed_at: Date | null
      user_id: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly activity: FieldRef<"notification", 'String'>
    readonly completed_at: FieldRef<"notification", 'DateTime'>
    readonly user_id: FieldRef<"notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model privacy_settings
   */

  export type AggregatePrivacy_settings = {
    _count: Privacy_settingsCountAggregateOutputType | null
    _min: Privacy_settingsMinAggregateOutputType | null
    _max: Privacy_settingsMaxAggregateOutputType | null
  }

  export type Privacy_settingsMinAggregateOutputType = {
    id: string | null
    ads: boolean | null
    data_sharing: boolean | null
    marketing_status: boolean | null
    activity_status: boolean | null
    user_id: string | null
  }

  export type Privacy_settingsMaxAggregateOutputType = {
    id: string | null
    ads: boolean | null
    data_sharing: boolean | null
    marketing_status: boolean | null
    activity_status: boolean | null
    user_id: string | null
  }

  export type Privacy_settingsCountAggregateOutputType = {
    id: number
    ads: number
    data_sharing: number
    marketing_status: number
    activity_status: number
    user_id: number
    _all: number
  }


  export type Privacy_settingsMinAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
  }

  export type Privacy_settingsMaxAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
  }

  export type Privacy_settingsCountAggregateInputType = {
    id?: true
    ads?: true
    data_sharing?: true
    marketing_status?: true
    activity_status?: true
    user_id?: true
    _all?: true
  }

  export type Privacy_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which privacy_settings to aggregate.
     */
    where?: privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privacy_settings to fetch.
     */
    orderBy?: privacy_settingsOrderByWithRelationInput | privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned privacy_settings
    **/
    _count?: true | Privacy_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Privacy_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Privacy_settingsMaxAggregateInputType
  }

  export type GetPrivacy_settingsAggregateType<T extends Privacy_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacy_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacy_settings[P]>
      : GetScalarType<T[P], AggregatePrivacy_settings[P]>
  }




  export type privacy_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: privacy_settingsWhereInput
    orderBy?: privacy_settingsOrderByWithAggregationInput | privacy_settingsOrderByWithAggregationInput[]
    by: Privacy_settingsScalarFieldEnum[] | Privacy_settingsScalarFieldEnum
    having?: privacy_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Privacy_settingsCountAggregateInputType | true
    _min?: Privacy_settingsMinAggregateInputType
    _max?: Privacy_settingsMaxAggregateInputType
  }

  export type Privacy_settingsGroupByOutputType = {
    id: string
    ads: boolean
    data_sharing: boolean
    marketing_status: boolean
    activity_status: boolean
    user_id: string
    _count: Privacy_settingsCountAggregateOutputType | null
    _min: Privacy_settingsMinAggregateOutputType | null
    _max: Privacy_settingsMaxAggregateOutputType | null
  }

  type GetPrivacy_settingsGroupByPayload<T extends privacy_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Privacy_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Privacy_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Privacy_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Privacy_settingsGroupByOutputType[P]>
        }
      >
    >


  export type privacy_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privacy_settings"]>



  export type privacy_settingsSelectScalar = {
    id?: boolean
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id?: boolean
  }

  export type privacy_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ads" | "data_sharing" | "marketing_status" | "activity_status" | "user_id", ExtArgs["result"]["privacy_settings"]>
  export type privacy_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $privacy_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "privacy_settings"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ads: boolean
      data_sharing: boolean
      marketing_status: boolean
      activity_status: boolean
      user_id: string
    }, ExtArgs["result"]["privacy_settings"]>
    composites: {}
  }

  type privacy_settingsGetPayload<S extends boolean | null | undefined | privacy_settingsDefaultArgs> = $Result.GetResult<Prisma.$privacy_settingsPayload, S>

  type privacy_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<privacy_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Privacy_settingsCountAggregateInputType | true
    }

  export interface privacy_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['privacy_settings'], meta: { name: 'privacy_settings' } }
    /**
     * Find zero or one Privacy_settings that matches the filter.
     * @param {privacy_settingsFindUniqueArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends privacy_settingsFindUniqueArgs>(args: SelectSubset<T, privacy_settingsFindUniqueArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Privacy_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {privacy_settingsFindUniqueOrThrowArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends privacy_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, privacy_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privacy_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsFindFirstArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends privacy_settingsFindFirstArgs>(args?: SelectSubset<T, privacy_settingsFindFirstArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privacy_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsFindFirstOrThrowArgs} args - Arguments to find a Privacy_settings
     * @example
     * // Get one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends privacy_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, privacy_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Privacy_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findMany()
     * 
     * // Get first 10 Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacy_settingsWithIdOnly = await prisma.privacy_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends privacy_settingsFindManyArgs>(args?: SelectSubset<T, privacy_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Privacy_settings.
     * @param {privacy_settingsCreateArgs} args - Arguments to create a Privacy_settings.
     * @example
     * // Create one Privacy_settings
     * const Privacy_settings = await prisma.privacy_settings.create({
     *   data: {
     *     // ... data to create a Privacy_settings
     *   }
     * })
     * 
     */
    create<T extends privacy_settingsCreateArgs>(args: SelectSubset<T, privacy_settingsCreateArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Privacy_settings.
     * @param {privacy_settingsCreateManyArgs} args - Arguments to create many Privacy_settings.
     * @example
     * // Create many Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends privacy_settingsCreateManyArgs>(args?: SelectSubset<T, privacy_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Privacy_settings.
     * @param {privacy_settingsDeleteArgs} args - Arguments to delete one Privacy_settings.
     * @example
     * // Delete one Privacy_settings
     * const Privacy_settings = await prisma.privacy_settings.delete({
     *   where: {
     *     // ... filter to delete one Privacy_settings
     *   }
     * })
     * 
     */
    delete<T extends privacy_settingsDeleteArgs>(args: SelectSubset<T, privacy_settingsDeleteArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Privacy_settings.
     * @param {privacy_settingsUpdateArgs} args - Arguments to update one Privacy_settings.
     * @example
     * // Update one Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends privacy_settingsUpdateArgs>(args: SelectSubset<T, privacy_settingsUpdateArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Privacy_settings.
     * @param {privacy_settingsDeleteManyArgs} args - Arguments to filter Privacy_settings to delete.
     * @example
     * // Delete a few Privacy_settings
     * const { count } = await prisma.privacy_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends privacy_settingsDeleteManyArgs>(args?: SelectSubset<T, privacy_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends privacy_settingsUpdateManyArgs>(args: SelectSubset<T, privacy_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Privacy_settings.
     * @param {privacy_settingsUpsertArgs} args - Arguments to update or create a Privacy_settings.
     * @example
     * // Update or create a Privacy_settings
     * const privacy_settings = await prisma.privacy_settings.upsert({
     *   create: {
     *     // ... data to create a Privacy_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privacy_settings we want to update
     *   }
     * })
     */
    upsert<T extends privacy_settingsUpsertArgs>(args: SelectSubset<T, privacy_settingsUpsertArgs<ExtArgs>>): Prisma__privacy_settingsClient<$Result.GetResult<Prisma.$privacy_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsCountArgs} args - Arguments to filter Privacy_settings to count.
     * @example
     * // Count the number of Privacy_settings
     * const count = await prisma.privacy_settings.count({
     *   where: {
     *     // ... the filter for the Privacy_settings we want to count
     *   }
     * })
    **/
    count<T extends privacy_settingsCountArgs>(
      args?: Subset<T, privacy_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Privacy_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Privacy_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Privacy_settingsAggregateArgs>(args: Subset<T, Privacy_settingsAggregateArgs>): Prisma.PrismaPromise<GetPrivacy_settingsAggregateType<T>>

    /**
     * Group by Privacy_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {privacy_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends privacy_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: privacy_settingsGroupByArgs['orderBy'] }
        : { orderBy?: privacy_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, privacy_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacy_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the privacy_settings model
   */
  readonly fields: privacy_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for privacy_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__privacy_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the privacy_settings model
   */
  interface privacy_settingsFieldRefs {
    readonly id: FieldRef<"privacy_settings", 'String'>
    readonly ads: FieldRef<"privacy_settings", 'Boolean'>
    readonly data_sharing: FieldRef<"privacy_settings", 'Boolean'>
    readonly marketing_status: FieldRef<"privacy_settings", 'Boolean'>
    readonly activity_status: FieldRef<"privacy_settings", 'Boolean'>
    readonly user_id: FieldRef<"privacy_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * privacy_settings findUnique
   */
  export type privacy_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which privacy_settings to fetch.
     */
    where: privacy_settingsWhereUniqueInput
  }

  /**
   * privacy_settings findUniqueOrThrow
   */
  export type privacy_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which privacy_settings to fetch.
     */
    where: privacy_settingsWhereUniqueInput
  }

  /**
   * privacy_settings findFirst
   */
  export type privacy_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which privacy_settings to fetch.
     */
    where?: privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privacy_settings to fetch.
     */
    orderBy?: privacy_settingsOrderByWithRelationInput | privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for privacy_settings.
     */
    cursor?: privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of privacy_settings.
     */
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * privacy_settings findFirstOrThrow
   */
  export type privacy_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which privacy_settings to fetch.
     */
    where?: privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privacy_settings to fetch.
     */
    orderBy?: privacy_settingsOrderByWithRelationInput | privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for privacy_settings.
     */
    cursor?: privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privacy_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of privacy_settings.
     */
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * privacy_settings findMany
   */
  export type privacy_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter, which privacy_settings to fetch.
     */
    where?: privacy_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of privacy_settings to fetch.
     */
    orderBy?: privacy_settingsOrderByWithRelationInput | privacy_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing privacy_settings.
     */
    cursor?: privacy_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` privacy_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` privacy_settings.
     */
    skip?: number
    distinct?: Privacy_settingsScalarFieldEnum | Privacy_settingsScalarFieldEnum[]
  }

  /**
   * privacy_settings create
   */
  export type privacy_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a privacy_settings.
     */
    data: XOR<privacy_settingsCreateInput, privacy_settingsUncheckedCreateInput>
  }

  /**
   * privacy_settings createMany
   */
  export type privacy_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many privacy_settings.
     */
    data: privacy_settingsCreateManyInput | privacy_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * privacy_settings update
   */
  export type privacy_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a privacy_settings.
     */
    data: XOR<privacy_settingsUpdateInput, privacy_settingsUncheckedUpdateInput>
    /**
     * Choose, which privacy_settings to update.
     */
    where: privacy_settingsWhereUniqueInput
  }

  /**
   * privacy_settings updateMany
   */
  export type privacy_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update privacy_settings.
     */
    data: XOR<privacy_settingsUpdateManyMutationInput, privacy_settingsUncheckedUpdateManyInput>
    /**
     * Filter which privacy_settings to update
     */
    where?: privacy_settingsWhereInput
    /**
     * Limit how many privacy_settings to update.
     */
    limit?: number
  }

  /**
   * privacy_settings upsert
   */
  export type privacy_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the privacy_settings to update in case it exists.
     */
    where: privacy_settingsWhereUniqueInput
    /**
     * In case the privacy_settings found by the `where` argument doesn't exist, create a new privacy_settings with this data.
     */
    create: XOR<privacy_settingsCreateInput, privacy_settingsUncheckedCreateInput>
    /**
     * In case the privacy_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<privacy_settingsUpdateInput, privacy_settingsUncheckedUpdateInput>
  }

  /**
   * privacy_settings delete
   */
  export type privacy_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
    /**
     * Filter which privacy_settings to delete.
     */
    where: privacy_settingsWhereUniqueInput
  }

  /**
   * privacy_settings deleteMany
   */
  export type privacy_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which privacy_settings to delete
     */
    where?: privacy_settingsWhereInput
    /**
     * Limit how many privacy_settings to delete.
     */
    limit?: number
  }

  /**
   * privacy_settings without action
   */
  export type privacy_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the privacy_settings
     */
    select?: privacy_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the privacy_settings
     */
    omit?: privacy_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: privacy_settingsInclude<ExtArgs> | null
  }


  /**
   * Model notification_settings
   */

  export type AggregateNotification_settings = {
    _count: Notification_settingsCountAggregateOutputType | null
    _min: Notification_settingsMinAggregateOutputType | null
    _max: Notification_settingsMaxAggregateOutputType | null
  }

  export type Notification_settingsMinAggregateOutputType = {
    id: string | null
    alerts: boolean | null
    messages: boolean | null
    updates: boolean | null
    billing_alerts: boolean | null
    email: boolean | null
    in_app: boolean | null
    user_id: string | null
  }

  export type Notification_settingsMaxAggregateOutputType = {
    id: string | null
    alerts: boolean | null
    messages: boolean | null
    updates: boolean | null
    billing_alerts: boolean | null
    email: boolean | null
    in_app: boolean | null
    user_id: string | null
  }

  export type Notification_settingsCountAggregateOutputType = {
    id: number
    alerts: number
    messages: number
    updates: number
    billing_alerts: number
    email: number
    in_app: number
    user_id: number
    _all: number
  }


  export type Notification_settingsMinAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
  }

  export type Notification_settingsMaxAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
  }

  export type Notification_settingsCountAggregateInputType = {
    id?: true
    alerts?: true
    messages?: true
    updates?: true
    billing_alerts?: true
    email?: true
    in_app?: true
    user_id?: true
    _all?: true
  }

  export type Notification_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_settings to aggregate.
     */
    where?: notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_settings to fetch.
     */
    orderBy?: notification_settingsOrderByWithRelationInput | notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_settings
    **/
    _count?: true | Notification_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_settingsMaxAggregateInputType
  }

  export type GetNotification_settingsAggregateType<T extends Notification_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_settings[P]>
      : GetScalarType<T[P], AggregateNotification_settings[P]>
  }




  export type notification_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_settingsWhereInput
    orderBy?: notification_settingsOrderByWithAggregationInput | notification_settingsOrderByWithAggregationInput[]
    by: Notification_settingsScalarFieldEnum[] | Notification_settingsScalarFieldEnum
    having?: notification_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_settingsCountAggregateInputType | true
    _min?: Notification_settingsMinAggregateInputType
    _max?: Notification_settingsMaxAggregateInputType
  }

  export type Notification_settingsGroupByOutputType = {
    id: string
    alerts: boolean
    messages: boolean
    updates: boolean
    billing_alerts: boolean
    email: boolean
    in_app: boolean
    user_id: string
    _count: Notification_settingsCountAggregateOutputType | null
    _min: Notification_settingsMinAggregateOutputType | null
    _max: Notification_settingsMaxAggregateOutputType | null
  }

  type GetNotification_settingsGroupByPayload<T extends notification_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_settingsGroupByOutputType[P]>
        }
      >
    >


  export type notification_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification_settings"]>



  export type notification_settingsSelectScalar = {
    id?: boolean
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id?: boolean
  }

  export type notification_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alerts" | "messages" | "updates" | "billing_alerts" | "email" | "in_app" | "user_id", ExtArgs["result"]["notification_settings"]>
  export type notification_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notification_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_settings"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alerts: boolean
      messages: boolean
      updates: boolean
      billing_alerts: boolean
      email: boolean
      in_app: boolean
      user_id: string
    }, ExtArgs["result"]["notification_settings"]>
    composites: {}
  }

  type notification_settingsGetPayload<S extends boolean | null | undefined | notification_settingsDefaultArgs> = $Result.GetResult<Prisma.$notification_settingsPayload, S>

  type notification_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notification_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Notification_settingsCountAggregateInputType | true
    }

  export interface notification_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_settings'], meta: { name: 'notification_settings' } }
    /**
     * Find zero or one Notification_settings that matches the filter.
     * @param {notification_settingsFindUniqueArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_settingsFindUniqueArgs>(args: SelectSubset<T, notification_settingsFindUniqueArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notification_settingsFindUniqueOrThrowArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsFindFirstArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_settingsFindFirstArgs>(args?: SelectSubset<T, notification_settingsFindFirstArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsFindFirstOrThrowArgs} args - Arguments to find a Notification_settings
     * @example
     * // Get one Notification_settings
     * const notification_settings = await prisma.notification_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notification_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_settings
     * const notification_settings = await prisma.notification_settings.findMany()
     * 
     * // Get first 10 Notification_settings
     * const notification_settings = await prisma.notification_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_settingsWithIdOnly = await prisma.notification_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_settingsFindManyArgs>(args?: SelectSubset<T, notification_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification_settings.
     * @param {notification_settingsCreateArgs} args - Arguments to create a Notification_settings.
     * @example
     * // Create one Notification_settings
     * const Notification_settings = await prisma.notification_settings.create({
     *   data: {
     *     // ... data to create a Notification_settings
     *   }
     * })
     * 
     */
    create<T extends notification_settingsCreateArgs>(args: SelectSubset<T, notification_settingsCreateArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notification_settings.
     * @param {notification_settingsCreateManyArgs} args - Arguments to create many Notification_settings.
     * @example
     * // Create many Notification_settings
     * const notification_settings = await prisma.notification_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_settingsCreateManyArgs>(args?: SelectSubset<T, notification_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification_settings.
     * @param {notification_settingsDeleteArgs} args - Arguments to delete one Notification_settings.
     * @example
     * // Delete one Notification_settings
     * const Notification_settings = await prisma.notification_settings.delete({
     *   where: {
     *     // ... filter to delete one Notification_settings
     *   }
     * })
     * 
     */
    delete<T extends notification_settingsDeleteArgs>(args: SelectSubset<T, notification_settingsDeleteArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification_settings.
     * @param {notification_settingsUpdateArgs} args - Arguments to update one Notification_settings.
     * @example
     * // Update one Notification_settings
     * const notification_settings = await prisma.notification_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_settingsUpdateArgs>(args: SelectSubset<T, notification_settingsUpdateArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notification_settings.
     * @param {notification_settingsDeleteManyArgs} args - Arguments to filter Notification_settings to delete.
     * @example
     * // Delete a few Notification_settings
     * const { count } = await prisma.notification_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_settingsDeleteManyArgs>(args?: SelectSubset<T, notification_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_settings
     * const notification_settings = await prisma.notification_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_settingsUpdateManyArgs>(args: SelectSubset<T, notification_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification_settings.
     * @param {notification_settingsUpsertArgs} args - Arguments to update or create a Notification_settings.
     * @example
     * // Update or create a Notification_settings
     * const notification_settings = await prisma.notification_settings.upsert({
     *   create: {
     *     // ... data to create a Notification_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_settings we want to update
     *   }
     * })
     */
    upsert<T extends notification_settingsUpsertArgs>(args: SelectSubset<T, notification_settingsUpsertArgs<ExtArgs>>): Prisma__notification_settingsClient<$Result.GetResult<Prisma.$notification_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsCountArgs} args - Arguments to filter Notification_settings to count.
     * @example
     * // Count the number of Notification_settings
     * const count = await prisma.notification_settings.count({
     *   where: {
     *     // ... the filter for the Notification_settings we want to count
     *   }
     * })
    **/
    count<T extends notification_settingsCountArgs>(
      args?: Subset<T, notification_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_settingsAggregateArgs>(args: Subset<T, Notification_settingsAggregateArgs>): Prisma.PrismaPromise<GetNotification_settingsAggregateType<T>>

    /**
     * Group by Notification_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_settingsGroupByArgs['orderBy'] }
        : { orderBy?: notification_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_settings model
   */
  readonly fields: notification_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_settings model
   */
  interface notification_settingsFieldRefs {
    readonly id: FieldRef<"notification_settings", 'String'>
    readonly alerts: FieldRef<"notification_settings", 'Boolean'>
    readonly messages: FieldRef<"notification_settings", 'Boolean'>
    readonly updates: FieldRef<"notification_settings", 'Boolean'>
    readonly billing_alerts: FieldRef<"notification_settings", 'Boolean'>
    readonly email: FieldRef<"notification_settings", 'Boolean'>
    readonly in_app: FieldRef<"notification_settings", 'Boolean'>
    readonly user_id: FieldRef<"notification_settings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification_settings findUnique
   */
  export type notification_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which notification_settings to fetch.
     */
    where: notification_settingsWhereUniqueInput
  }

  /**
   * notification_settings findUniqueOrThrow
   */
  export type notification_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which notification_settings to fetch.
     */
    where: notification_settingsWhereUniqueInput
  }

  /**
   * notification_settings findFirst
   */
  export type notification_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which notification_settings to fetch.
     */
    where?: notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_settings to fetch.
     */
    orderBy?: notification_settingsOrderByWithRelationInput | notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_settings.
     */
    cursor?: notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_settings.
     */
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * notification_settings findFirstOrThrow
   */
  export type notification_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which notification_settings to fetch.
     */
    where?: notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_settings to fetch.
     */
    orderBy?: notification_settingsOrderByWithRelationInput | notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_settings.
     */
    cursor?: notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_settings.
     */
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * notification_settings findMany
   */
  export type notification_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter, which notification_settings to fetch.
     */
    where?: notification_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_settings to fetch.
     */
    orderBy?: notification_settingsOrderByWithRelationInput | notification_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_settings.
     */
    cursor?: notification_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_settings.
     */
    skip?: number
    distinct?: Notification_settingsScalarFieldEnum | Notification_settingsScalarFieldEnum[]
  }

  /**
   * notification_settings create
   */
  export type notification_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a notification_settings.
     */
    data: XOR<notification_settingsCreateInput, notification_settingsUncheckedCreateInput>
  }

  /**
   * notification_settings createMany
   */
  export type notification_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_settings.
     */
    data: notification_settingsCreateManyInput | notification_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_settings update
   */
  export type notification_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a notification_settings.
     */
    data: XOR<notification_settingsUpdateInput, notification_settingsUncheckedUpdateInput>
    /**
     * Choose, which notification_settings to update.
     */
    where: notification_settingsWhereUniqueInput
  }

  /**
   * notification_settings updateMany
   */
  export type notification_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_settings.
     */
    data: XOR<notification_settingsUpdateManyMutationInput, notification_settingsUncheckedUpdateManyInput>
    /**
     * Filter which notification_settings to update
     */
    where?: notification_settingsWhereInput
    /**
     * Limit how many notification_settings to update.
     */
    limit?: number
  }

  /**
   * notification_settings upsert
   */
  export type notification_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the notification_settings to update in case it exists.
     */
    where: notification_settingsWhereUniqueInput
    /**
     * In case the notification_settings found by the `where` argument doesn't exist, create a new notification_settings with this data.
     */
    create: XOR<notification_settingsCreateInput, notification_settingsUncheckedCreateInput>
    /**
     * In case the notification_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_settingsUpdateInput, notification_settingsUncheckedUpdateInput>
  }

  /**
   * notification_settings delete
   */
  export type notification_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
    /**
     * Filter which notification_settings to delete.
     */
    where: notification_settingsWhereUniqueInput
  }

  /**
   * notification_settings deleteMany
   */
  export type notification_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_settings to delete
     */
    where?: notification_settingsWhereInput
    /**
     * Limit how many notification_settings to delete.
     */
    limit?: number
  }

  /**
   * notification_settings without action
   */
  export type notification_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_settings
     */
    select?: notification_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification_settings
     */
    omit?: notification_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notification_settingsInclude<ExtArgs> | null
  }


  /**
   * Model plan_type
   */

  export type AggregatePlan_type = {
    _count: Plan_typeCountAggregateOutputType | null
    _min: Plan_typeMinAggregateOutputType | null
    _max: Plan_typeMaxAggregateOutputType | null
  }

  export type Plan_typeMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type Plan_typeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type Plan_typeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    created_by: number
    deleted_at: number
    _all: number
  }


  export type Plan_typeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type Plan_typeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type Plan_typeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Plan_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_type to aggregate.
     */
    where?: plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_types to fetch.
     */
    orderBy?: plan_typeOrderByWithRelationInput | plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plan_types
    **/
    _count?: true | Plan_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plan_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plan_typeMaxAggregateInputType
  }

  export type GetPlan_typeAggregateType<T extends Plan_typeAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan_type[P]>
      : GetScalarType<T[P], AggregatePlan_type[P]>
  }




  export type plan_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plan_typeWhereInput
    orderBy?: plan_typeOrderByWithAggregationInput | plan_typeOrderByWithAggregationInput[]
    by: Plan_typeScalarFieldEnum[] | Plan_typeScalarFieldEnum
    having?: plan_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plan_typeCountAggregateInputType | true
    _min?: Plan_typeMinAggregateInputType
    _max?: Plan_typeMaxAggregateInputType
  }

  export type Plan_typeGroupByOutputType = {
    id: string
    name: string
    created_at: Date
    created_by: string
    deleted_at: Date | null
    _count: Plan_typeCountAggregateOutputType | null
    _min: Plan_typeMinAggregateOutputType | null
    _max: Plan_typeMaxAggregateOutputType | null
  }

  type GetPlan_typeGroupByPayload<T extends plan_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plan_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plan_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plan_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Plan_typeGroupByOutputType[P]>
        }
      >
    >


  export type plan_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | plan_type$planArgs<ExtArgs>
    _count?: boolean | Plan_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan_type"]>



  export type plan_typeSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
  }

  export type plan_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "created_by" | "deleted_at", ExtArgs["result"]["plan_type"]>
  export type plan_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    plan?: boolean | plan_type$planArgs<ExtArgs>
    _count?: boolean | Plan_typeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $plan_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan_type"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      plan: Prisma.$planPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      created_at: Date
      created_by: string
      deleted_at: Date | null
    }, ExtArgs["result"]["plan_type"]>
    composites: {}
  }

  type plan_typeGetPayload<S extends boolean | null | undefined | plan_typeDefaultArgs> = $Result.GetResult<Prisma.$plan_typePayload, S>

  type plan_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plan_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plan_typeCountAggregateInputType | true
    }

  export interface plan_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan_type'], meta: { name: 'plan_type' } }
    /**
     * Find zero or one Plan_type that matches the filter.
     * @param {plan_typeFindUniqueArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plan_typeFindUniqueArgs>(args: SelectSubset<T, plan_typeFindUniqueArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plan_typeFindUniqueOrThrowArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plan_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, plan_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeFindFirstArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plan_typeFindFirstArgs>(args?: SelectSubset<T, plan_typeFindFirstArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeFindFirstOrThrowArgs} args - Arguments to find a Plan_type
     * @example
     * // Get one Plan_type
     * const plan_type = await prisma.plan_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plan_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, plan_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plan_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plan_types
     * const plan_types = await prisma.plan_type.findMany()
     * 
     * // Get first 10 Plan_types
     * const plan_types = await prisma.plan_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plan_typeWithIdOnly = await prisma.plan_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plan_typeFindManyArgs>(args?: SelectSubset<T, plan_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan_type.
     * @param {plan_typeCreateArgs} args - Arguments to create a Plan_type.
     * @example
     * // Create one Plan_type
     * const Plan_type = await prisma.plan_type.create({
     *   data: {
     *     // ... data to create a Plan_type
     *   }
     * })
     * 
     */
    create<T extends plan_typeCreateArgs>(args: SelectSubset<T, plan_typeCreateArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plan_types.
     * @param {plan_typeCreateManyArgs} args - Arguments to create many Plan_types.
     * @example
     * // Create many Plan_types
     * const plan_type = await prisma.plan_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plan_typeCreateManyArgs>(args?: SelectSubset<T, plan_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan_type.
     * @param {plan_typeDeleteArgs} args - Arguments to delete one Plan_type.
     * @example
     * // Delete one Plan_type
     * const Plan_type = await prisma.plan_type.delete({
     *   where: {
     *     // ... filter to delete one Plan_type
     *   }
     * })
     * 
     */
    delete<T extends plan_typeDeleteArgs>(args: SelectSubset<T, plan_typeDeleteArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan_type.
     * @param {plan_typeUpdateArgs} args - Arguments to update one Plan_type.
     * @example
     * // Update one Plan_type
     * const plan_type = await prisma.plan_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plan_typeUpdateArgs>(args: SelectSubset<T, plan_typeUpdateArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plan_types.
     * @param {plan_typeDeleteManyArgs} args - Arguments to filter Plan_types to delete.
     * @example
     * // Delete a few Plan_types
     * const { count } = await prisma.plan_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plan_typeDeleteManyArgs>(args?: SelectSubset<T, plan_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plan_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plan_types
     * const plan_type = await prisma.plan_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plan_typeUpdateManyArgs>(args: SelectSubset<T, plan_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan_type.
     * @param {plan_typeUpsertArgs} args - Arguments to update or create a Plan_type.
     * @example
     * // Update or create a Plan_type
     * const plan_type = await prisma.plan_type.upsert({
     *   create: {
     *     // ... data to create a Plan_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan_type we want to update
     *   }
     * })
     */
    upsert<T extends plan_typeUpsertArgs>(args: SelectSubset<T, plan_typeUpsertArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plan_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeCountArgs} args - Arguments to filter Plan_types to count.
     * @example
     * // Count the number of Plan_types
     * const count = await prisma.plan_type.count({
     *   where: {
     *     // ... the filter for the Plan_types we want to count
     *   }
     * })
    **/
    count<T extends plan_typeCountArgs>(
      args?: Subset<T, plan_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plan_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plan_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plan_typeAggregateArgs>(args: Subset<T, Plan_typeAggregateArgs>): Prisma.PrismaPromise<GetPlan_typeAggregateType<T>>

    /**
     * Group by Plan_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plan_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plan_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plan_typeGroupByArgs['orderBy'] }
        : { orderBy?: plan_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plan_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlan_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan_type model
   */
  readonly fields: plan_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plan_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends plan_type$planArgs<ExtArgs> = {}>(args?: Subset<T, plan_type$planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan_type model
   */
  interface plan_typeFieldRefs {
    readonly id: FieldRef<"plan_type", 'String'>
    readonly name: FieldRef<"plan_type", 'String'>
    readonly created_at: FieldRef<"plan_type", 'DateTime'>
    readonly created_by: FieldRef<"plan_type", 'String'>
    readonly deleted_at: FieldRef<"plan_type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plan_type findUnique
   */
  export type plan_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which plan_type to fetch.
     */
    where: plan_typeWhereUniqueInput
  }

  /**
   * plan_type findUniqueOrThrow
   */
  export type plan_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which plan_type to fetch.
     */
    where: plan_typeWhereUniqueInput
  }

  /**
   * plan_type findFirst
   */
  export type plan_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which plan_type to fetch.
     */
    where?: plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_types to fetch.
     */
    orderBy?: plan_typeOrderByWithRelationInput | plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_types.
     */
    cursor?: plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_types.
     */
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * plan_type findFirstOrThrow
   */
  export type plan_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which plan_type to fetch.
     */
    where?: plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_types to fetch.
     */
    orderBy?: plan_typeOrderByWithRelationInput | plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plan_types.
     */
    cursor?: plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plan_types.
     */
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * plan_type findMany
   */
  export type plan_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter, which plan_types to fetch.
     */
    where?: plan_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plan_types to fetch.
     */
    orderBy?: plan_typeOrderByWithRelationInput | plan_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plan_types.
     */
    cursor?: plan_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plan_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plan_types.
     */
    skip?: number
    distinct?: Plan_typeScalarFieldEnum | Plan_typeScalarFieldEnum[]
  }

  /**
   * plan_type create
   */
  export type plan_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a plan_type.
     */
    data: XOR<plan_typeCreateInput, plan_typeUncheckedCreateInput>
  }

  /**
   * plan_type createMany
   */
  export type plan_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plan_types.
     */
    data: plan_typeCreateManyInput | plan_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan_type update
   */
  export type plan_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a plan_type.
     */
    data: XOR<plan_typeUpdateInput, plan_typeUncheckedUpdateInput>
    /**
     * Choose, which plan_type to update.
     */
    where: plan_typeWhereUniqueInput
  }

  /**
   * plan_type updateMany
   */
  export type plan_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plan_types.
     */
    data: XOR<plan_typeUpdateManyMutationInput, plan_typeUncheckedUpdateManyInput>
    /**
     * Filter which plan_types to update
     */
    where?: plan_typeWhereInput
    /**
     * Limit how many plan_types to update.
     */
    limit?: number
  }

  /**
   * plan_type upsert
   */
  export type plan_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the plan_type to update in case it exists.
     */
    where: plan_typeWhereUniqueInput
    /**
     * In case the plan_type found by the `where` argument doesn't exist, create a new plan_type with this data.
     */
    create: XOR<plan_typeCreateInput, plan_typeUncheckedCreateInput>
    /**
     * In case the plan_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plan_typeUpdateInput, plan_typeUncheckedUpdateInput>
  }

  /**
   * plan_type delete
   */
  export type plan_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
    /**
     * Filter which plan_type to delete.
     */
    where: plan_typeWhereUniqueInput
  }

  /**
   * plan_type deleteMany
   */
  export type plan_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan_types to delete
     */
    where?: plan_typeWhereInput
    /**
     * Limit how many plan_types to delete.
     */
    limit?: number
  }

  /**
   * plan_type.plan
   */
  export type plan_type$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    where?: planWhereInput
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    cursor?: planWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan_type without action
   */
  export type plan_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan_type
     */
    select?: plan_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan_type
     */
    omit?: plan_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plan_typeInclude<ExtArgs> | null
  }


  /**
   * Model billing_cycle
   */

  export type AggregateBilling_cycle = {
    _count: Billing_cycleCountAggregateOutputType | null
    _avg: Billing_cycleAvgAggregateOutputType | null
    _sum: Billing_cycleSumAggregateOutputType | null
    _min: Billing_cycleMinAggregateOutputType | null
    _max: Billing_cycleMaxAggregateOutputType | null
  }

  export type Billing_cycleAvgAggregateOutputType = {
    duration_in_days: number | null
  }

  export type Billing_cycleSumAggregateOutputType = {
    duration_in_days: number | null
  }

  export type Billing_cycleMinAggregateOutputType = {
    id: string | null
    name: string | null
    duration_in_days: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type Billing_cycleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    duration_in_days: number | null
    created_at: Date | null
    deleted_at: Date | null
  }

  export type Billing_cycleCountAggregateOutputType = {
    id: number
    name: number
    duration_in_days: number
    created_at: number
    deleted_at: number
    _all: number
  }


  export type Billing_cycleAvgAggregateInputType = {
    duration_in_days?: true
  }

  export type Billing_cycleSumAggregateInputType = {
    duration_in_days?: true
  }

  export type Billing_cycleMinAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
  }

  export type Billing_cycleMaxAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
  }

  export type Billing_cycleCountAggregateInputType = {
    id?: true
    name?: true
    duration_in_days?: true
    created_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Billing_cycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billing_cycle to aggregate.
     */
    where?: billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_cycles to fetch.
     */
    orderBy?: billing_cycleOrderByWithRelationInput | billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned billing_cycles
    **/
    _count?: true | Billing_cycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Billing_cycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Billing_cycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Billing_cycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Billing_cycleMaxAggregateInputType
  }

  export type GetBilling_cycleAggregateType<T extends Billing_cycleAggregateArgs> = {
        [P in keyof T & keyof AggregateBilling_cycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBilling_cycle[P]>
      : GetScalarType<T[P], AggregateBilling_cycle[P]>
  }




  export type billing_cycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: billing_cycleWhereInput
    orderBy?: billing_cycleOrderByWithAggregationInput | billing_cycleOrderByWithAggregationInput[]
    by: Billing_cycleScalarFieldEnum[] | Billing_cycleScalarFieldEnum
    having?: billing_cycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Billing_cycleCountAggregateInputType | true
    _avg?: Billing_cycleAvgAggregateInputType
    _sum?: Billing_cycleSumAggregateInputType
    _min?: Billing_cycleMinAggregateInputType
    _max?: Billing_cycleMaxAggregateInputType
  }

  export type Billing_cycleGroupByOutputType = {
    id: string
    name: string
    duration_in_days: number
    created_at: Date
    deleted_at: Date | null
    _count: Billing_cycleCountAggregateOutputType | null
    _avg: Billing_cycleAvgAggregateOutputType | null
    _sum: Billing_cycleSumAggregateOutputType | null
    _min: Billing_cycleMinAggregateOutputType | null
    _max: Billing_cycleMaxAggregateOutputType | null
  }

  type GetBilling_cycleGroupByPayload<T extends billing_cycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Billing_cycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Billing_cycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Billing_cycleGroupByOutputType[P]>
            : GetScalarType<T[P], Billing_cycleGroupByOutputType[P]>
        }
      >
    >


  export type billing_cycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    duration_in_days?: boolean
    created_at?: boolean
    deleted_at?: boolean
    plan?: boolean | billing_cycle$planArgs<ExtArgs>
    _count?: boolean | Billing_cycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billing_cycle"]>



  export type billing_cycleSelectScalar = {
    id?: boolean
    name?: boolean
    duration_in_days?: boolean
    created_at?: boolean
    deleted_at?: boolean
  }

  export type billing_cycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "duration_in_days" | "created_at" | "deleted_at", ExtArgs["result"]["billing_cycle"]>
  export type billing_cycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | billing_cycle$planArgs<ExtArgs>
    _count?: boolean | Billing_cycleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $billing_cyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "billing_cycle"
    objects: {
      plan: Prisma.$planPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      duration_in_days: number
      created_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["billing_cycle"]>
    composites: {}
  }

  type billing_cycleGetPayload<S extends boolean | null | undefined | billing_cycleDefaultArgs> = $Result.GetResult<Prisma.$billing_cyclePayload, S>

  type billing_cycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<billing_cycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Billing_cycleCountAggregateInputType | true
    }

  export interface billing_cycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['billing_cycle'], meta: { name: 'billing_cycle' } }
    /**
     * Find zero or one Billing_cycle that matches the filter.
     * @param {billing_cycleFindUniqueArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends billing_cycleFindUniqueArgs>(args: SelectSubset<T, billing_cycleFindUniqueArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Billing_cycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {billing_cycleFindUniqueOrThrowArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends billing_cycleFindUniqueOrThrowArgs>(args: SelectSubset<T, billing_cycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing_cycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleFindFirstArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends billing_cycleFindFirstArgs>(args?: SelectSubset<T, billing_cycleFindFirstArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Billing_cycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleFindFirstOrThrowArgs} args - Arguments to find a Billing_cycle
     * @example
     * // Get one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends billing_cycleFindFirstOrThrowArgs>(args?: SelectSubset<T, billing_cycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Billing_cycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billing_cycles
     * const billing_cycles = await prisma.billing_cycle.findMany()
     * 
     * // Get first 10 Billing_cycles
     * const billing_cycles = await prisma.billing_cycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billing_cycleWithIdOnly = await prisma.billing_cycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends billing_cycleFindManyArgs>(args?: SelectSubset<T, billing_cycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Billing_cycle.
     * @param {billing_cycleCreateArgs} args - Arguments to create a Billing_cycle.
     * @example
     * // Create one Billing_cycle
     * const Billing_cycle = await prisma.billing_cycle.create({
     *   data: {
     *     // ... data to create a Billing_cycle
     *   }
     * })
     * 
     */
    create<T extends billing_cycleCreateArgs>(args: SelectSubset<T, billing_cycleCreateArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Billing_cycles.
     * @param {billing_cycleCreateManyArgs} args - Arguments to create many Billing_cycles.
     * @example
     * // Create many Billing_cycles
     * const billing_cycle = await prisma.billing_cycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends billing_cycleCreateManyArgs>(args?: SelectSubset<T, billing_cycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Billing_cycle.
     * @param {billing_cycleDeleteArgs} args - Arguments to delete one Billing_cycle.
     * @example
     * // Delete one Billing_cycle
     * const Billing_cycle = await prisma.billing_cycle.delete({
     *   where: {
     *     // ... filter to delete one Billing_cycle
     *   }
     * })
     * 
     */
    delete<T extends billing_cycleDeleteArgs>(args: SelectSubset<T, billing_cycleDeleteArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Billing_cycle.
     * @param {billing_cycleUpdateArgs} args - Arguments to update one Billing_cycle.
     * @example
     * // Update one Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends billing_cycleUpdateArgs>(args: SelectSubset<T, billing_cycleUpdateArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Billing_cycles.
     * @param {billing_cycleDeleteManyArgs} args - Arguments to filter Billing_cycles to delete.
     * @example
     * // Delete a few Billing_cycles
     * const { count } = await prisma.billing_cycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends billing_cycleDeleteManyArgs>(args?: SelectSubset<T, billing_cycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billing_cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billing_cycles
     * const billing_cycle = await prisma.billing_cycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends billing_cycleUpdateManyArgs>(args: SelectSubset<T, billing_cycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billing_cycle.
     * @param {billing_cycleUpsertArgs} args - Arguments to update or create a Billing_cycle.
     * @example
     * // Update or create a Billing_cycle
     * const billing_cycle = await prisma.billing_cycle.upsert({
     *   create: {
     *     // ... data to create a Billing_cycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billing_cycle we want to update
     *   }
     * })
     */
    upsert<T extends billing_cycleUpsertArgs>(args: SelectSubset<T, billing_cycleUpsertArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Billing_cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleCountArgs} args - Arguments to filter Billing_cycles to count.
     * @example
     * // Count the number of Billing_cycles
     * const count = await prisma.billing_cycle.count({
     *   where: {
     *     // ... the filter for the Billing_cycles we want to count
     *   }
     * })
    **/
    count<T extends billing_cycleCountArgs>(
      args?: Subset<T, billing_cycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Billing_cycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billing_cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Billing_cycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Billing_cycleAggregateArgs>(args: Subset<T, Billing_cycleAggregateArgs>): Prisma.PrismaPromise<GetBilling_cycleAggregateType<T>>

    /**
     * Group by Billing_cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {billing_cycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends billing_cycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: billing_cycleGroupByArgs['orderBy'] }
        : { orderBy?: billing_cycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, billing_cycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBilling_cycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the billing_cycle model
   */
  readonly fields: billing_cycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for billing_cycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__billing_cycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends billing_cycle$planArgs<ExtArgs> = {}>(args?: Subset<T, billing_cycle$planArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the billing_cycle model
   */
  interface billing_cycleFieldRefs {
    readonly id: FieldRef<"billing_cycle", 'String'>
    readonly name: FieldRef<"billing_cycle", 'String'>
    readonly duration_in_days: FieldRef<"billing_cycle", 'Int'>
    readonly created_at: FieldRef<"billing_cycle", 'DateTime'>
    readonly deleted_at: FieldRef<"billing_cycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * billing_cycle findUnique
   */
  export type billing_cycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which billing_cycle to fetch.
     */
    where: billing_cycleWhereUniqueInput
  }

  /**
   * billing_cycle findUniqueOrThrow
   */
  export type billing_cycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which billing_cycle to fetch.
     */
    where: billing_cycleWhereUniqueInput
  }

  /**
   * billing_cycle findFirst
   */
  export type billing_cycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which billing_cycle to fetch.
     */
    where?: billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_cycles to fetch.
     */
    orderBy?: billing_cycleOrderByWithRelationInput | billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billing_cycles.
     */
    cursor?: billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billing_cycles.
     */
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * billing_cycle findFirstOrThrow
   */
  export type billing_cycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which billing_cycle to fetch.
     */
    where?: billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_cycles to fetch.
     */
    orderBy?: billing_cycleOrderByWithRelationInput | billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for billing_cycles.
     */
    cursor?: billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of billing_cycles.
     */
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * billing_cycle findMany
   */
  export type billing_cycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter, which billing_cycles to fetch.
     */
    where?: billing_cycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of billing_cycles to fetch.
     */
    orderBy?: billing_cycleOrderByWithRelationInput | billing_cycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing billing_cycles.
     */
    cursor?: billing_cycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` billing_cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` billing_cycles.
     */
    skip?: number
    distinct?: Billing_cycleScalarFieldEnum | Billing_cycleScalarFieldEnum[]
  }

  /**
   * billing_cycle create
   */
  export type billing_cycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * The data needed to create a billing_cycle.
     */
    data: XOR<billing_cycleCreateInput, billing_cycleUncheckedCreateInput>
  }

  /**
   * billing_cycle createMany
   */
  export type billing_cycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many billing_cycles.
     */
    data: billing_cycleCreateManyInput | billing_cycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * billing_cycle update
   */
  export type billing_cycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * The data needed to update a billing_cycle.
     */
    data: XOR<billing_cycleUpdateInput, billing_cycleUncheckedUpdateInput>
    /**
     * Choose, which billing_cycle to update.
     */
    where: billing_cycleWhereUniqueInput
  }

  /**
   * billing_cycle updateMany
   */
  export type billing_cycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update billing_cycles.
     */
    data: XOR<billing_cycleUpdateManyMutationInput, billing_cycleUncheckedUpdateManyInput>
    /**
     * Filter which billing_cycles to update
     */
    where?: billing_cycleWhereInput
    /**
     * Limit how many billing_cycles to update.
     */
    limit?: number
  }

  /**
   * billing_cycle upsert
   */
  export type billing_cycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * The filter to search for the billing_cycle to update in case it exists.
     */
    where: billing_cycleWhereUniqueInput
    /**
     * In case the billing_cycle found by the `where` argument doesn't exist, create a new billing_cycle with this data.
     */
    create: XOR<billing_cycleCreateInput, billing_cycleUncheckedCreateInput>
    /**
     * In case the billing_cycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<billing_cycleUpdateInput, billing_cycleUncheckedUpdateInput>
  }

  /**
   * billing_cycle delete
   */
  export type billing_cycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
    /**
     * Filter which billing_cycle to delete.
     */
    where: billing_cycleWhereUniqueInput
  }

  /**
   * billing_cycle deleteMany
   */
  export type billing_cycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which billing_cycles to delete
     */
    where?: billing_cycleWhereInput
    /**
     * Limit how many billing_cycles to delete.
     */
    limit?: number
  }

  /**
   * billing_cycle.plan
   */
  export type billing_cycle$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    where?: planWhereInput
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    cursor?: planWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * billing_cycle without action
   */
  export type billing_cycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the billing_cycle
     */
    select?: billing_cycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the billing_cycle
     */
    omit?: billing_cycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: billing_cycleInclude<ExtArgs> | null
  }


  /**
   * Model plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    service_id: string | null
    plan_type_id: string | null
    billing_cycle_id: string | null
    price: number | null
    description: string | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    service_id: string | null
    plan_type_id: string | null
    billing_cycle_id: string | null
    price: number | null
    description: string | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    service_id: number
    plan_type_id: number
    billing_cycle_id: number
    price: number
    description: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    service_id?: true
    plan_type_id?: true
    billing_cycle_id?: true
    price?: true
    description?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    service_id?: true
    plan_type_id?: true
    billing_cycle_id?: true
    price?: true
    description?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    service_id?: true
    plan_type_id?: true
    billing_cycle_id?: true
    price?: true
    description?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plan to aggregate.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type planGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: planWhereInput
    orderBy?: planOrderByWithAggregationInput | planOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: planScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    service_id: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends planGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type planSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_id?: boolean
    plan_type_id?: boolean
    billing_cycle_id?: boolean
    price?: boolean
    description?: boolean
    service?: boolean | serviceDefaultArgs<ExtArgs>
    plan_type?: boolean | plan_typeDefaultArgs<ExtArgs>
    billing_cycle?: boolean | billing_cycleDefaultArgs<ExtArgs>
    service_request?: boolean | plan$service_requestArgs<ExtArgs>
    subscription?: boolean | plan$subscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>



  export type planSelectScalar = {
    id?: boolean
    service_id?: boolean
    plan_type_id?: boolean
    billing_cycle_id?: boolean
    price?: boolean
    description?: boolean
  }

  export type planOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service_id" | "plan_type_id" | "billing_cycle_id" | "price" | "description", ExtArgs["result"]["plan"]>
  export type planInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | serviceDefaultArgs<ExtArgs>
    plan_type?: boolean | plan_typeDefaultArgs<ExtArgs>
    billing_cycle?: boolean | billing_cycleDefaultArgs<ExtArgs>
    service_request?: boolean | plan$service_requestArgs<ExtArgs>
    subscription?: boolean | plan$subscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $planPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plan"
    objects: {
      service: Prisma.$servicePayload<ExtArgs>
      plan_type: Prisma.$plan_typePayload<ExtArgs>
      billing_cycle: Prisma.$billing_cyclePayload<ExtArgs>
      service_request: Prisma.$service_requestPayload<ExtArgs>[]
      subscription: Prisma.$subscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_id: string
      plan_type_id: string
      billing_cycle_id: string
      price: number
      description: string
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type planGetPayload<S extends boolean | null | undefined | planDefaultArgs> = $Result.GetResult<Prisma.$planPayload, S>

  type planCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<planFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface planDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plan'], meta: { name: 'plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {planFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends planFindUniqueArgs>(args: SelectSubset<T, planFindUniqueArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {planFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends planFindUniqueOrThrowArgs>(args: SelectSubset<T, planFindUniqueOrThrowArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends planFindFirstArgs>(args?: SelectSubset<T, planFindFirstArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends planFindFirstOrThrowArgs>(args?: SelectSubset<T, planFindFirstOrThrowArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends planFindManyArgs>(args?: SelectSubset<T, planFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {planCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends planCreateArgs>(args: SelectSubset<T, planCreateArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {planCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends planCreateManyArgs>(args?: SelectSubset<T, planCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {planDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends planDeleteArgs>(args: SelectSubset<T, planDeleteArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {planUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends planUpdateArgs>(args: SelectSubset<T, planUpdateArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {planDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends planDeleteManyArgs>(args?: SelectSubset<T, planDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends planUpdateManyArgs>(args: SelectSubset<T, planUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {planUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends planUpsertArgs>(args: SelectSubset<T, planUpsertArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends planCountArgs>(
      args?: Subset<T, planCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {planGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends planGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: planGroupByArgs['orderBy'] }
        : { orderBy?: planGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, planGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plan model
   */
  readonly fields: planFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__planClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends serviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serviceDefaultArgs<ExtArgs>>): Prisma__serviceClient<$Result.GetResult<Prisma.$servicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan_type<T extends plan_typeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, plan_typeDefaultArgs<ExtArgs>>): Prisma__plan_typeClient<$Result.GetResult<Prisma.$plan_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    billing_cycle<T extends billing_cycleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, billing_cycleDefaultArgs<ExtArgs>>): Prisma__billing_cycleClient<$Result.GetResult<Prisma.$billing_cyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service_request<T extends plan$service_requestArgs<ExtArgs> = {}>(args?: Subset<T, plan$service_requestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_requestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends plan$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, plan$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plan model
   */
  interface planFieldRefs {
    readonly id: FieldRef<"plan", 'String'>
    readonly service_id: FieldRef<"plan", 'String'>
    readonly plan_type_id: FieldRef<"plan", 'String'>
    readonly billing_cycle_id: FieldRef<"plan", 'String'>
    readonly price: FieldRef<"plan", 'Int'>
    readonly description: FieldRef<"plan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plan findUnique
   */
  export type planFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan findUniqueOrThrow
   */
  export type planFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan findFirst
   */
  export type planFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan findFirstOrThrow
   */
  export type planFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plan to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan findMany
   */
  export type planFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter, which plans to fetch.
     */
    where?: planWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plans to fetch.
     */
    orderBy?: planOrderByWithRelationInput | planOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plans.
     */
    cursor?: planWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * plan create
   */
  export type planCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The data needed to create a plan.
     */
    data: XOR<planCreateInput, planUncheckedCreateInput>
  }

  /**
   * plan createMany
   */
  export type planCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plans.
     */
    data: planCreateManyInput | planCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plan update
   */
  export type planUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The data needed to update a plan.
     */
    data: XOR<planUpdateInput, planUncheckedUpdateInput>
    /**
     * Choose, which plan to update.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan updateMany
   */
  export type planUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plans.
     */
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyInput>
    /**
     * Filter which plans to update
     */
    where?: planWhereInput
    /**
     * Limit how many plans to update.
     */
    limit?: number
  }

  /**
   * plan upsert
   */
  export type planUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * The filter to search for the plan to update in case it exists.
     */
    where: planWhereUniqueInput
    /**
     * In case the plan found by the `where` argument doesn't exist, create a new plan with this data.
     */
    create: XOR<planCreateInput, planUncheckedCreateInput>
    /**
     * In case the plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<planUpdateInput, planUncheckedUpdateInput>
  }

  /**
   * plan delete
   */
  export type planDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
    /**
     * Filter which plan to delete.
     */
    where: planWhereUniqueInput
  }

  /**
   * plan deleteMany
   */
  export type planDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plans to delete
     */
    where?: planWhereInput
    /**
     * Limit how many plans to delete.
     */
    limit?: number
  }

  /**
   * plan.service_request
   */
  export type plan$service_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_request
     */
    select?: service_requestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_request
     */
    omit?: service_requestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_requestInclude<ExtArgs> | null
    where?: service_requestWhereInput
    orderBy?: service_requestOrderByWithRelationInput | service_requestOrderByWithRelationInput[]
    cursor?: service_requestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_requestScalarFieldEnum | Service_requestScalarFieldEnum[]
  }

  /**
   * plan.subscription
   */
  export type plan$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    cursor?: subscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * plan without action
   */
  export type planDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plan
     */
    select?: planSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plan
     */
    omit?: planOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: planInclude<ExtArgs> | null
  }


  /**
   * Model subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    user_id: string | null
    plan_id: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    user_id: string | null
    plan_id: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    start_date: number
    end_date: number
    status: number
    user_id: number
    plan_id: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    status?: true
    user_id?: true
    plan_id?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscription to aggregate.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type subscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionWhereInput
    orderBy?: subscriptionOrderByWithAggregationInput | subscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: subscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    start_date: Date | null
    end_date: Date | null
    status: string
    user_id: string
    plan_id: string
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends subscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    plan?: boolean | planDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>



  export type subscriptionSelectScalar = {
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
  }

  export type subscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start_date" | "end_date" | "status" | "user_id" | "plan_id", ExtArgs["result"]["subscription"]>
  export type subscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | planDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $subscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscription"
    objects: {
      plan: Prisma.$planPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      start_date: Date | null
      end_date: Date | null
      status: string
      user_id: string
      plan_id: string
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type subscriptionGetPayload<S extends boolean | null | undefined | subscriptionDefaultArgs> = $Result.GetResult<Prisma.$subscriptionPayload, S>

  type subscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface subscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscription'], meta: { name: 'subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {subscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionFindUniqueArgs>(args: SelectSubset<T, subscriptionFindUniqueArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionFindFirstArgs>(args?: SelectSubset<T, subscriptionFindFirstArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionFindManyArgs>(args?: SelectSubset<T, subscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {subscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends subscriptionCreateArgs>(args: SelectSubset<T, subscriptionCreateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionCreateManyArgs>(args?: SelectSubset<T, subscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {subscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends subscriptionDeleteArgs>(args: SelectSubset<T, subscriptionDeleteArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {subscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionUpdateArgs>(args: SelectSubset<T, subscriptionUpdateArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionDeleteManyArgs>(args?: SelectSubset<T, subscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionUpdateManyArgs>(args: SelectSubset<T, subscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {subscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionUpsertArgs>(args: SelectSubset<T, subscriptionUpsertArgs<ExtArgs>>): Prisma__subscriptionClient<$Result.GetResult<Prisma.$subscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionCountArgs>(
      args?: Subset<T, subscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscription model
   */
  readonly fields: subscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends planDefaultArgs<ExtArgs> = {}>(args?: Subset<T, planDefaultArgs<ExtArgs>>): Prisma__planClient<$Result.GetResult<Prisma.$planPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscription model
   */
  interface subscriptionFieldRefs {
    readonly id: FieldRef<"subscription", 'String'>
    readonly start_date: FieldRef<"subscription", 'DateTime'>
    readonly end_date: FieldRef<"subscription", 'DateTime'>
    readonly status: FieldRef<"subscription", 'String'>
    readonly user_id: FieldRef<"subscription", 'String'>
    readonly plan_id: FieldRef<"subscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subscription findUnique
   */
  export type subscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findUniqueOrThrow
   */
  export type subscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription findFirst
   */
  export type subscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findFirstOrThrow
   */
  export type subscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscription to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription findMany
   */
  export type subscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionOrderByWithRelationInput | subscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * subscription create
   */
  export type subscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a subscription.
     */
    data: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
  }

  /**
   * subscription createMany
   */
  export type subscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionCreateManyInput | subscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscription update
   */
  export type subscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a subscription.
     */
    data: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
    /**
     * Choose, which subscription to update.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription updateMany
   */
  export type subscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscription upsert
   */
  export type subscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the subscription to update in case it exists.
     */
    where: subscriptionWhereUniqueInput
    /**
     * In case the subscription found by the `where` argument doesn't exist, create a new subscription with this data.
     */
    create: XOR<subscriptionCreateInput, subscriptionUncheckedCreateInput>
    /**
     * In case the subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionUpdateInput, subscriptionUncheckedUpdateInput>
  }

  /**
   * subscription delete
   */
  export type subscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
    /**
     * Filter which subscription to delete.
     */
    where: subscriptionWhereUniqueInput
  }

  /**
   * subscription deleteMany
   */
  export type subscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscription without action
   */
  export type subscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscription
     */
    select?: subscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscription
     */
    omit?: subscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    created_by: string | null
    deleted_at: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    created_at: number
    created_by: number
    deleted_at: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    created_by?: true
    deleted_at?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    created_at: Date
    created_by: string | null
    deleted_at: Date | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
    creator?: boolean | role$creatorArgs<ExtArgs>
    user?: boolean | role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type roleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    created_by?: boolean
    deleted_at?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "created_at" | "created_by" | "deleted_at", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | role$creatorArgs<ExtArgs>
    user?: boolean | role$userArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      creator: Prisma.$userPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      created_at: Date
      created_by: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends role$creatorArgs<ExtArgs> = {}>(args?: Subset<T, role$creatorArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends role$userArgs<ExtArgs> = {}>(args?: Subset<T, role$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'String'>
    readonly title: FieldRef<"role", 'String'>
    readonly description: FieldRef<"role", 'String'>
    readonly created_at: FieldRef<"role", 'DateTime'>
    readonly created_by: FieldRef<"role", 'String'>
    readonly deleted_at: FieldRef<"role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.creator
   */
  export type role$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * role.user
   */
  export type role$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    tel: 'tel',
    country: 'country',
    address: 'address',
    category: 'category',
    pfp_url: 'pfp_url',
    id_url: 'id_url',
    business_status: 'business_status',
    registered_with_a_business: 'registered_with_a_business',
    password: 'password',
    status: 'status',
    role_id: 'role_id',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganisationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    country: 'country',
    industry: 'industry',
    logo_url: 'logo_url',
    rc_number: 'rc_number',
    staff_size: 'staff_size',
    type: 'type',
    created_at: 'created_at',
    user_id: 'user_id',
    deleted_at: 'deleted_at'
  };

  export type OrganisationScalarFieldEnum = (typeof OrganisationScalarFieldEnum)[keyof typeof OrganisationScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    subtitle: 'subtitle',
    created_at: 'created_at',
    admin_id: 'admin_id',
    banner_url: 'banner_url',
    deleted_at: 'deleted_at'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const Service_requestScalarFieldEnum: {
    id: 'id',
    message: 'message',
    service_id: 'service_id',
    user_id: 'user_id',
    requested_at: 'requested_at',
    status: 'status',
    plan_id: 'plan_id'
  };

  export type Service_requestScalarFieldEnum = (typeof Service_requestScalarFieldEnum)[keyof typeof Service_requestScalarFieldEnum]


  export const Case_studiesScalarFieldEnum: {
    id: 'id',
    banner: 'banner',
    challenge: 'challenge',
    challenge_img: 'challenge_img',
    solution: 'solution',
    solution_img: 'solution_img',
    result: 'result',
    result_img: 'result_img',
    service_id: 'service_id',
    organisation_id: 'organisation_id'
  };

  export type Case_studiesScalarFieldEnum = (typeof Case_studiesScalarFieldEnum)[keyof typeof Case_studiesScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    message: 'message',
    user_id: 'user_id',
    service_id: 'service_id',
    stars: 'stars',
    user_title: 'user_title',
    deleted_at: 'deleted_at'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pfp_url: 'pfp_url',
    organisation_id: 'organisation_id',
    id_url: 'id_url',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    otp: 'otp',
    expires_at: 'expires_at',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const Password_tokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    created_at: 'created_at',
    expires_at: 'expires_at',
    user_id: 'user_id'
  };

  export type Password_tokenScalarFieldEnum = (typeof Password_tokenScalarFieldEnum)[keyof typeof Password_tokenScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    activity: 'activity',
    completed_at: 'completed_at',
    user_id: 'user_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const Privacy_settingsScalarFieldEnum: {
    id: 'id',
    ads: 'ads',
    data_sharing: 'data_sharing',
    marketing_status: 'marketing_status',
    activity_status: 'activity_status',
    user_id: 'user_id'
  };

  export type Privacy_settingsScalarFieldEnum = (typeof Privacy_settingsScalarFieldEnum)[keyof typeof Privacy_settingsScalarFieldEnum]


  export const Notification_settingsScalarFieldEnum: {
    id: 'id',
    alerts: 'alerts',
    messages: 'messages',
    updates: 'updates',
    billing_alerts: 'billing_alerts',
    email: 'email',
    in_app: 'in_app',
    user_id: 'user_id'
  };

  export type Notification_settingsScalarFieldEnum = (typeof Notification_settingsScalarFieldEnum)[keyof typeof Notification_settingsScalarFieldEnum]


  export const Plan_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    created_by: 'created_by',
    deleted_at: 'deleted_at'
  };

  export type Plan_typeScalarFieldEnum = (typeof Plan_typeScalarFieldEnum)[keyof typeof Plan_typeScalarFieldEnum]


  export const Billing_cycleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    duration_in_days: 'duration_in_days',
    created_at: 'created_at',
    deleted_at: 'deleted_at'
  };

  export type Billing_cycleScalarFieldEnum = (typeof Billing_cycleScalarFieldEnum)[keyof typeof Billing_cycleScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    plan_type_id: 'plan_type_id',
    billing_cycle_id: 'billing_cycle_id',
    price: 'price',
    description: 'description'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    user_id: 'user_id',
    plan_id: 'plan_id'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    created_at: 'created_at',
    created_by: 'created_by',
    deleted_at: 'deleted_at'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    tel: 'tel',
    country: 'country',
    address: 'address',
    category: 'category',
    pfp_url: 'pfp_url',
    password: 'password',
    status: 'status',
    role_id: 'role_id'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const organisationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    country: 'country',
    industry: 'industry',
    logo_url: 'logo_url',
    rc_number: 'rc_number',
    staff_size: 'staff_size',
    type: 'type',
    user_id: 'user_id'
  };

  export type organisationOrderByRelevanceFieldEnum = (typeof organisationOrderByRelevanceFieldEnum)[keyof typeof organisationOrderByRelevanceFieldEnum]


  export const serviceOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    subtitle: 'subtitle',
    admin_id: 'admin_id',
    banner_url: 'banner_url'
  };

  export type serviceOrderByRelevanceFieldEnum = (typeof serviceOrderByRelevanceFieldEnum)[keyof typeof serviceOrderByRelevanceFieldEnum]


  export const service_requestOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message',
    service_id: 'service_id',
    user_id: 'user_id',
    status: 'status',
    plan_id: 'plan_id'
  };

  export type service_requestOrderByRelevanceFieldEnum = (typeof service_requestOrderByRelevanceFieldEnum)[keyof typeof service_requestOrderByRelevanceFieldEnum]


  export const case_studiesOrderByRelevanceFieldEnum: {
    id: 'id',
    banner: 'banner',
    challenge: 'challenge',
    challenge_img: 'challenge_img',
    solution: 'solution',
    solution_img: 'solution_img',
    result: 'result',
    result_img: 'result_img',
    service_id: 'service_id',
    organisation_id: 'organisation_id'
  };

  export type case_studiesOrderByRelevanceFieldEnum = (typeof case_studiesOrderByRelevanceFieldEnum)[keyof typeof case_studiesOrderByRelevanceFieldEnum]


  export const testimonialOrderByRelevanceFieldEnum: {
    id: 'id',
    message: 'message',
    user_id: 'user_id',
    service_id: 'service_id',
    user_title: 'user_title'
  };

  export type testimonialOrderByRelevanceFieldEnum = (typeof testimonialOrderByRelevanceFieldEnum)[keyof typeof testimonialOrderByRelevanceFieldEnum]


  export const contactOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    pfp_url: 'pfp_url',
    organisation_id: 'organisation_id'
  };

  export type contactOrderByRelevanceFieldEnum = (typeof contactOrderByRelevanceFieldEnum)[keyof typeof contactOrderByRelevanceFieldEnum]


  export const otpOrderByRelevanceFieldEnum: {
    id: 'id',
    otp: 'otp',
    user_id: 'user_id'
  };

  export type otpOrderByRelevanceFieldEnum = (typeof otpOrderByRelevanceFieldEnum)[keyof typeof otpOrderByRelevanceFieldEnum]


  export const password_tokenOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    user_id: 'user_id'
  };

  export type password_tokenOrderByRelevanceFieldEnum = (typeof password_tokenOrderByRelevanceFieldEnum)[keyof typeof password_tokenOrderByRelevanceFieldEnum]


  export const notificationOrderByRelevanceFieldEnum: {
    id: 'id',
    activity: 'activity',
    user_id: 'user_id'
  };

  export type notificationOrderByRelevanceFieldEnum = (typeof notificationOrderByRelevanceFieldEnum)[keyof typeof notificationOrderByRelevanceFieldEnum]


  export const privacy_settingsOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type privacy_settingsOrderByRelevanceFieldEnum = (typeof privacy_settingsOrderByRelevanceFieldEnum)[keyof typeof privacy_settingsOrderByRelevanceFieldEnum]


  export const notification_settingsOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type notification_settingsOrderByRelevanceFieldEnum = (typeof notification_settingsOrderByRelevanceFieldEnum)[keyof typeof notification_settingsOrderByRelevanceFieldEnum]


  export const plan_typeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    created_by: 'created_by'
  };

  export type plan_typeOrderByRelevanceFieldEnum = (typeof plan_typeOrderByRelevanceFieldEnum)[keyof typeof plan_typeOrderByRelevanceFieldEnum]


  export const billing_cycleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type billing_cycleOrderByRelevanceFieldEnum = (typeof billing_cycleOrderByRelevanceFieldEnum)[keyof typeof billing_cycleOrderByRelevanceFieldEnum]


  export const planOrderByRelevanceFieldEnum: {
    id: 'id',
    service_id: 'service_id',
    plan_type_id: 'plan_type_id',
    billing_cycle_id: 'billing_cycle_id',
    description: 'description'
  };

  export type planOrderByRelevanceFieldEnum = (typeof planOrderByRelevanceFieldEnum)[keyof typeof planOrderByRelevanceFieldEnum]


  export const subscriptionOrderByRelevanceFieldEnum: {
    id: 'id',
    status: 'status',
    user_id: 'user_id',
    plan_id: 'plan_id'
  };

  export type subscriptionOrderByRelevanceFieldEnum = (typeof subscriptionOrderByRelevanceFieldEnum)[keyof typeof subscriptionOrderByRelevanceFieldEnum]


  export const roleOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    created_by: 'created_by'
  };

  export type roleOrderByRelevanceFieldEnum = (typeof roleOrderByRelevanceFieldEnum)[keyof typeof roleOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    tel?: StringFilter<"user"> | string
    country?: StringFilter<"user"> | string
    address?: StringFilter<"user"> | string
    category?: StringFilter<"user"> | string
    pfp_url?: StringNullableFilter<"user"> | string | null
    id_url?: JsonNullableFilter<"user">
    business_status?: BoolNullableFilter<"user"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"user"> | boolean | null
    password?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    role_id?: StringFilter<"user"> | string
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    notification?: NotificationListRelationFilter
    notification_settings?: Notification_settingsListRelationFilter
    organisation?: OrganisationListRelationFilter
    otp?: OtpListRelationFilter
    password_token?: Password_tokenListRelationFilter
    privacy_settings?: Privacy_settingsListRelationFilter
    created_role?: RoleListRelationFilter
    service?: ServiceListRelationFilter
    service_request?: Service_requestListRelationFilter
    subscription?: SubscriptionListRelationFilter
    testimonial?: TestimonialListRelationFilter
    plan_type?: Plan_typeListRelationFilter
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrderInput | SortOrder
    id_url?: SortOrderInput | SortOrder
    business_status?: SortOrderInput | SortOrder
    registered_with_a_business?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    notification?: notificationOrderByRelationAggregateInput
    notification_settings?: notification_settingsOrderByRelationAggregateInput
    organisation?: organisationOrderByRelationAggregateInput
    otp?: otpOrderByRelationAggregateInput
    password_token?: password_tokenOrderByRelationAggregateInput
    privacy_settings?: privacy_settingsOrderByRelationAggregateInput
    created_role?: roleOrderByRelationAggregateInput
    service?: serviceOrderByRelationAggregateInput
    service_request?: service_requestOrderByRelationAggregateInput
    subscription?: subscriptionOrderByRelationAggregateInput
    testimonial?: testimonialOrderByRelationAggregateInput
    plan_type?: plan_typeOrderByRelationAggregateInput
    role?: roleOrderByWithRelationInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    tel?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    country?: StringFilter<"user"> | string
    address?: StringFilter<"user"> | string
    category?: StringFilter<"user"> | string
    pfp_url?: StringNullableFilter<"user"> | string | null
    id_url?: JsonNullableFilter<"user">
    business_status?: BoolNullableFilter<"user"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"user"> | boolean | null
    password?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    role_id?: StringFilter<"user"> | string
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    notification?: NotificationListRelationFilter
    notification_settings?: Notification_settingsListRelationFilter
    organisation?: OrganisationListRelationFilter
    otp?: OtpListRelationFilter
    password_token?: Password_tokenListRelationFilter
    privacy_settings?: Privacy_settingsListRelationFilter
    created_role?: RoleListRelationFilter
    service?: ServiceListRelationFilter
    service_request?: Service_requestListRelationFilter
    subscription?: SubscriptionListRelationFilter
    testimonial?: TestimonialListRelationFilter
    plan_type?: Plan_typeListRelationFilter
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
  }, "id" | "email" | "tel">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrderInput | SortOrder
    id_url?: SortOrderInput | SortOrder
    business_status?: SortOrderInput | SortOrder
    registered_with_a_business?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    tel?: StringWithAggregatesFilter<"user"> | string
    country?: StringWithAggregatesFilter<"user"> | string
    address?: StringWithAggregatesFilter<"user"> | string
    category?: StringWithAggregatesFilter<"user"> | string
    pfp_url?: StringNullableWithAggregatesFilter<"user"> | string | null
    id_url?: JsonNullableWithAggregatesFilter<"user">
    business_status?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    registered_with_a_business?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    password?: StringWithAggregatesFilter<"user"> | string
    status?: StringWithAggregatesFilter<"user"> | string
    role_id?: StringWithAggregatesFilter<"user"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type organisationWhereInput = {
    AND?: organisationWhereInput | organisationWhereInput[]
    OR?: organisationWhereInput[]
    NOT?: organisationWhereInput | organisationWhereInput[]
    id?: StringFilter<"organisation"> | string
    name?: StringFilter<"organisation"> | string
    email?: StringFilter<"organisation"> | string
    address?: StringFilter<"organisation"> | string
    country?: StringFilter<"organisation"> | string
    industry?: StringFilter<"organisation"> | string
    logo_url?: StringFilter<"organisation"> | string
    rc_number?: StringFilter<"organisation"> | string
    staff_size?: StringFilter<"organisation"> | string
    type?: StringFilter<"organisation"> | string
    created_at?: DateTimeFilter<"organisation"> | Date | string
    user_id?: StringFilter<"organisation"> | string
    deleted_at?: DateTimeNullableFilter<"organisation"> | Date | string | null
    case_studies?: Case_studiesListRelationFilter
    contact?: ContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type organisationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    case_studies?: case_studiesOrderByRelationAggregateInput
    contact?: contactOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    _relevance?: organisationOrderByRelevanceInput
  }

  export type organisationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    rc_number?: string
    AND?: organisationWhereInput | organisationWhereInput[]
    OR?: organisationWhereInput[]
    NOT?: organisationWhereInput | organisationWhereInput[]
    name?: StringFilter<"organisation"> | string
    address?: StringFilter<"organisation"> | string
    country?: StringFilter<"organisation"> | string
    industry?: StringFilter<"organisation"> | string
    logo_url?: StringFilter<"organisation"> | string
    staff_size?: StringFilter<"organisation"> | string
    type?: StringFilter<"organisation"> | string
    created_at?: DateTimeFilter<"organisation"> | Date | string
    user_id?: StringFilter<"organisation"> | string
    deleted_at?: DateTimeNullableFilter<"organisation"> | Date | string | null
    case_studies?: Case_studiesListRelationFilter
    contact?: ContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "email" | "rc_number">

  export type organisationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: organisationCountOrderByAggregateInput
    _max?: organisationMaxOrderByAggregateInput
    _min?: organisationMinOrderByAggregateInput
  }

  export type organisationScalarWhereWithAggregatesInput = {
    AND?: organisationScalarWhereWithAggregatesInput | organisationScalarWhereWithAggregatesInput[]
    OR?: organisationScalarWhereWithAggregatesInput[]
    NOT?: organisationScalarWhereWithAggregatesInput | organisationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"organisation"> | string
    name?: StringWithAggregatesFilter<"organisation"> | string
    email?: StringWithAggregatesFilter<"organisation"> | string
    address?: StringWithAggregatesFilter<"organisation"> | string
    country?: StringWithAggregatesFilter<"organisation"> | string
    industry?: StringWithAggregatesFilter<"organisation"> | string
    logo_url?: StringWithAggregatesFilter<"organisation"> | string
    rc_number?: StringWithAggregatesFilter<"organisation"> | string
    staff_size?: StringWithAggregatesFilter<"organisation"> | string
    type?: StringWithAggregatesFilter<"organisation"> | string
    created_at?: DateTimeWithAggregatesFilter<"organisation"> | Date | string
    user_id?: StringWithAggregatesFilter<"organisation"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"organisation"> | Date | string | null
  }

  export type serviceWhereInput = {
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    id?: StringFilter<"service"> | string
    title?: StringFilter<"service"> | string
    description?: StringFilter<"service"> | string
    subtitle?: StringFilter<"service"> | string
    created_at?: DateTimeNullableFilter<"service"> | Date | string | null
    admin_id?: StringFilter<"service"> | string
    banner_url?: StringFilter<"service"> | string
    deleted_at?: DateTimeNullableFilter<"service"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    service_request?: Service_requestListRelationFilter
    case_studies?: Case_studiesListRelationFilter
    testimonial?: TestimonialListRelationFilter
    plan?: PlanListRelationFilter
  }

  export type serviceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtitle?: SortOrder
    created_at?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    banner_url?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    service_request?: service_requestOrderByRelationAggregateInput
    case_studies?: case_studiesOrderByRelationAggregateInput
    testimonial?: testimonialOrderByRelationAggregateInput
    plan?: planOrderByRelationAggregateInput
    _relevance?: serviceOrderByRelevanceInput
  }

  export type serviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: serviceWhereInput | serviceWhereInput[]
    OR?: serviceWhereInput[]
    NOT?: serviceWhereInput | serviceWhereInput[]
    title?: StringFilter<"service"> | string
    description?: StringFilter<"service"> | string
    subtitle?: StringFilter<"service"> | string
    created_at?: DateTimeNullableFilter<"service"> | Date | string | null
    admin_id?: StringFilter<"service"> | string
    banner_url?: StringFilter<"service"> | string
    deleted_at?: DateTimeNullableFilter<"service"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    service_request?: Service_requestListRelationFilter
    case_studies?: Case_studiesListRelationFilter
    testimonial?: TestimonialListRelationFilter
    plan?: PlanListRelationFilter
  }, "id">

  export type serviceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtitle?: SortOrder
    created_at?: SortOrderInput | SortOrder
    admin_id?: SortOrder
    banner_url?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: serviceCountOrderByAggregateInput
    _max?: serviceMaxOrderByAggregateInput
    _min?: serviceMinOrderByAggregateInput
  }

  export type serviceScalarWhereWithAggregatesInput = {
    AND?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    OR?: serviceScalarWhereWithAggregatesInput[]
    NOT?: serviceScalarWhereWithAggregatesInput | serviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"service"> | string
    title?: StringWithAggregatesFilter<"service"> | string
    description?: StringWithAggregatesFilter<"service"> | string
    subtitle?: StringWithAggregatesFilter<"service"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"service"> | Date | string | null
    admin_id?: StringWithAggregatesFilter<"service"> | string
    banner_url?: StringWithAggregatesFilter<"service"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"service"> | Date | string | null
  }

  export type service_requestWhereInput = {
    AND?: service_requestWhereInput | service_requestWhereInput[]
    OR?: service_requestWhereInput[]
    NOT?: service_requestWhereInput | service_requestWhereInput[]
    id?: StringFilter<"service_request"> | string
    message?: StringFilter<"service_request"> | string
    service_id?: StringFilter<"service_request"> | string
    user_id?: StringFilter<"service_request"> | string
    requested_at?: DateTimeFilter<"service_request"> | Date | string
    status?: StringFilter<"service_request"> | string
    plan_id?: StringFilter<"service_request"> | string
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type service_requestOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    requested_at?: SortOrder
    status?: SortOrder
    plan_id?: SortOrder
    plan?: planOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: service_requestOrderByRelevanceInput
  }

  export type service_requestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: service_requestWhereInput | service_requestWhereInput[]
    OR?: service_requestWhereInput[]
    NOT?: service_requestWhereInput | service_requestWhereInput[]
    message?: StringFilter<"service_request"> | string
    service_id?: StringFilter<"service_request"> | string
    user_id?: StringFilter<"service_request"> | string
    requested_at?: DateTimeFilter<"service_request"> | Date | string
    status?: StringFilter<"service_request"> | string
    plan_id?: StringFilter<"service_request"> | string
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type service_requestOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    requested_at?: SortOrder
    status?: SortOrder
    plan_id?: SortOrder
    _count?: service_requestCountOrderByAggregateInput
    _max?: service_requestMaxOrderByAggregateInput
    _min?: service_requestMinOrderByAggregateInput
  }

  export type service_requestScalarWhereWithAggregatesInput = {
    AND?: service_requestScalarWhereWithAggregatesInput | service_requestScalarWhereWithAggregatesInput[]
    OR?: service_requestScalarWhereWithAggregatesInput[]
    NOT?: service_requestScalarWhereWithAggregatesInput | service_requestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"service_request"> | string
    message?: StringWithAggregatesFilter<"service_request"> | string
    service_id?: StringWithAggregatesFilter<"service_request"> | string
    user_id?: StringWithAggregatesFilter<"service_request"> | string
    requested_at?: DateTimeWithAggregatesFilter<"service_request"> | Date | string
    status?: StringWithAggregatesFilter<"service_request"> | string
    plan_id?: StringWithAggregatesFilter<"service_request"> | string
  }

  export type case_studiesWhereInput = {
    AND?: case_studiesWhereInput | case_studiesWhereInput[]
    OR?: case_studiesWhereInput[]
    NOT?: case_studiesWhereInput | case_studiesWhereInput[]
    id?: StringFilter<"case_studies"> | string
    banner?: StringFilter<"case_studies"> | string
    challenge?: StringFilter<"case_studies"> | string
    challenge_img?: StringFilter<"case_studies"> | string
    solution?: StringFilter<"case_studies"> | string
    solution_img?: StringFilter<"case_studies"> | string
    result?: StringFilter<"case_studies"> | string
    result_img?: StringFilter<"case_studies"> | string
    service_id?: StringFilter<"case_studies"> | string
    organisation_id?: StringFilter<"case_studies"> | string
    organisation?: XOR<OrganisationScalarRelationFilter, organisationWhereInput>
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
  }

  export type case_studiesOrderByWithRelationInput = {
    id?: SortOrder
    banner?: SortOrder
    challenge?: SortOrder
    challenge_img?: SortOrder
    solution?: SortOrder
    solution_img?: SortOrder
    result?: SortOrder
    result_img?: SortOrder
    service_id?: SortOrder
    organisation_id?: SortOrder
    organisation?: organisationOrderByWithRelationInput
    service?: serviceOrderByWithRelationInput
    _relevance?: case_studiesOrderByRelevanceInput
  }

  export type case_studiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: case_studiesWhereInput | case_studiesWhereInput[]
    OR?: case_studiesWhereInput[]
    NOT?: case_studiesWhereInput | case_studiesWhereInput[]
    banner?: StringFilter<"case_studies"> | string
    challenge?: StringFilter<"case_studies"> | string
    challenge_img?: StringFilter<"case_studies"> | string
    solution?: StringFilter<"case_studies"> | string
    solution_img?: StringFilter<"case_studies"> | string
    result?: StringFilter<"case_studies"> | string
    result_img?: StringFilter<"case_studies"> | string
    service_id?: StringFilter<"case_studies"> | string
    organisation_id?: StringFilter<"case_studies"> | string
    organisation?: XOR<OrganisationScalarRelationFilter, organisationWhereInput>
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
  }, "id">

  export type case_studiesOrderByWithAggregationInput = {
    id?: SortOrder
    banner?: SortOrder
    challenge?: SortOrder
    challenge_img?: SortOrder
    solution?: SortOrder
    solution_img?: SortOrder
    result?: SortOrder
    result_img?: SortOrder
    service_id?: SortOrder
    organisation_id?: SortOrder
    _count?: case_studiesCountOrderByAggregateInput
    _max?: case_studiesMaxOrderByAggregateInput
    _min?: case_studiesMinOrderByAggregateInput
  }

  export type case_studiesScalarWhereWithAggregatesInput = {
    AND?: case_studiesScalarWhereWithAggregatesInput | case_studiesScalarWhereWithAggregatesInput[]
    OR?: case_studiesScalarWhereWithAggregatesInput[]
    NOT?: case_studiesScalarWhereWithAggregatesInput | case_studiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"case_studies"> | string
    banner?: StringWithAggregatesFilter<"case_studies"> | string
    challenge?: StringWithAggregatesFilter<"case_studies"> | string
    challenge_img?: StringWithAggregatesFilter<"case_studies"> | string
    solution?: StringWithAggregatesFilter<"case_studies"> | string
    solution_img?: StringWithAggregatesFilter<"case_studies"> | string
    result?: StringWithAggregatesFilter<"case_studies"> | string
    result_img?: StringWithAggregatesFilter<"case_studies"> | string
    service_id?: StringWithAggregatesFilter<"case_studies"> | string
    organisation_id?: StringWithAggregatesFilter<"case_studies"> | string
  }

  export type testimonialWhereInput = {
    AND?: testimonialWhereInput | testimonialWhereInput[]
    OR?: testimonialWhereInput[]
    NOT?: testimonialWhereInput | testimonialWhereInput[]
    id?: StringFilter<"testimonial"> | string
    message?: StringFilter<"testimonial"> | string
    user_id?: StringFilter<"testimonial"> | string
    service_id?: StringFilter<"testimonial"> | string
    stars?: DecimalFilter<"testimonial"> | Decimal | DecimalJsLike | number | string
    user_title?: StringFilter<"testimonial"> | string
    deleted_at?: DateTimeNullableFilter<"testimonial"> | Date | string | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type testimonialOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    stars?: SortOrder
    user_title?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    service?: serviceOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: testimonialOrderByRelevanceInput
  }

  export type testimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testimonialWhereInput | testimonialWhereInput[]
    OR?: testimonialWhereInput[]
    NOT?: testimonialWhereInput | testimonialWhereInput[]
    message?: StringFilter<"testimonial"> | string
    user_id?: StringFilter<"testimonial"> | string
    service_id?: StringFilter<"testimonial"> | string
    stars?: DecimalFilter<"testimonial"> | Decimal | DecimalJsLike | number | string
    user_title?: StringFilter<"testimonial"> | string
    deleted_at?: DateTimeNullableFilter<"testimonial"> | Date | string | null
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type testimonialOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    stars?: SortOrder
    user_title?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: testimonialCountOrderByAggregateInput
    _avg?: testimonialAvgOrderByAggregateInput
    _max?: testimonialMaxOrderByAggregateInput
    _min?: testimonialMinOrderByAggregateInput
    _sum?: testimonialSumOrderByAggregateInput
  }

  export type testimonialScalarWhereWithAggregatesInput = {
    AND?: testimonialScalarWhereWithAggregatesInput | testimonialScalarWhereWithAggregatesInput[]
    OR?: testimonialScalarWhereWithAggregatesInput[]
    NOT?: testimonialScalarWhereWithAggregatesInput | testimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testimonial"> | string
    message?: StringWithAggregatesFilter<"testimonial"> | string
    user_id?: StringWithAggregatesFilter<"testimonial"> | string
    service_id?: StringWithAggregatesFilter<"testimonial"> | string
    stars?: DecimalWithAggregatesFilter<"testimonial"> | Decimal | DecimalJsLike | number | string
    user_title?: StringWithAggregatesFilter<"testimonial"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"testimonial"> | Date | string | null
  }

  export type contactWhereInput = {
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    id?: StringFilter<"contact"> | string
    name?: StringFilter<"contact"> | string
    pfp_url?: StringFilter<"contact"> | string
    organisation_id?: StringFilter<"contact"> | string
    id_url?: JsonFilter<"contact">
    created_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, organisationWhereInput>
  }

  export type contactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    organisation?: organisationOrderByWithRelationInput
    _relevance?: contactOrderByRelevanceInput
  }

  export type contactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    name?: StringFilter<"contact"> | string
    pfp_url?: StringFilter<"contact"> | string
    organisation_id?: StringFilter<"contact"> | string
    id_url?: JsonFilter<"contact">
    created_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, organisationWhereInput>
  }, "id">

  export type contactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: contactCountOrderByAggregateInput
    _max?: contactMaxOrderByAggregateInput
    _min?: contactMinOrderByAggregateInput
  }

  export type contactScalarWhereWithAggregatesInput = {
    AND?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    OR?: contactScalarWhereWithAggregatesInput[]
    NOT?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contact"> | string
    name?: StringWithAggregatesFilter<"contact"> | string
    pfp_url?: StringWithAggregatesFilter<"contact"> | string
    organisation_id?: StringWithAggregatesFilter<"contact"> | string
    id_url?: JsonWithAggregatesFilter<"contact">
    created_at?: DateTimeNullableWithAggregatesFilter<"contact"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"contact"> | Date | string | null
  }

  export type otpWhereInput = {
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    id?: StringFilter<"otp"> | string
    otp?: StringFilter<"otp"> | string
    expires_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    user_id?: StringFilter<"otp"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type otpOrderByWithRelationInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: otpOrderByRelevanceInput
  }

  export type otpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: otpWhereInput | otpWhereInput[]
    OR?: otpWhereInput[]
    NOT?: otpWhereInput | otpWhereInput[]
    otp?: StringFilter<"otp"> | string
    expires_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    user_id?: StringFilter<"otp"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type otpOrderByWithAggregationInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: otpCountOrderByAggregateInput
    _max?: otpMaxOrderByAggregateInput
    _min?: otpMinOrderByAggregateInput
  }

  export type otpScalarWhereWithAggregatesInput = {
    AND?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    OR?: otpScalarWhereWithAggregatesInput[]
    NOT?: otpScalarWhereWithAggregatesInput | otpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"otp"> | string
    otp?: StringWithAggregatesFilter<"otp"> | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"otp"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"otp"> | string
  }

  export type password_tokenWhereInput = {
    AND?: password_tokenWhereInput | password_tokenWhereInput[]
    OR?: password_tokenWhereInput[]
    NOT?: password_tokenWhereInput | password_tokenWhereInput[]
    id?: StringFilter<"password_token"> | string
    token?: StringFilter<"password_token"> | string
    created_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    user_id?: StringFilter<"password_token"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type password_tokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: password_tokenOrderByRelevanceInput
  }

  export type password_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: password_tokenWhereInput | password_tokenWhereInput[]
    OR?: password_tokenWhereInput[]
    NOT?: password_tokenWhereInput | password_tokenWhereInput[]
    token?: StringFilter<"password_token"> | string
    created_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    user_id?: StringFilter<"password_token"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type password_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: password_tokenCountOrderByAggregateInput
    _max?: password_tokenMaxOrderByAggregateInput
    _min?: password_tokenMinOrderByAggregateInput
  }

  export type password_tokenScalarWhereWithAggregatesInput = {
    AND?: password_tokenScalarWhereWithAggregatesInput | password_tokenScalarWhereWithAggregatesInput[]
    OR?: password_tokenScalarWhereWithAggregatesInput[]
    NOT?: password_tokenScalarWhereWithAggregatesInput | password_tokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"password_token"> | string
    token?: StringWithAggregatesFilter<"password_token"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"password_token"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"password_token"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"password_token"> | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    activity?: StringFilter<"notification"> | string
    completed_at?: DateTimeNullableFilter<"notification"> | Date | string | null
    user_id?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: notificationOrderByRelevanceInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    activity?: StringFilter<"notification"> | string
    completed_at?: DateTimeNullableFilter<"notification"> | Date | string | null
    user_id?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    activity?: StringWithAggregatesFilter<"notification"> | string
    completed_at?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
    user_id?: StringWithAggregatesFilter<"notification"> | string
  }

  export type privacy_settingsWhereInput = {
    AND?: privacy_settingsWhereInput | privacy_settingsWhereInput[]
    OR?: privacy_settingsWhereInput[]
    NOT?: privacy_settingsWhereInput | privacy_settingsWhereInput[]
    id?: StringFilter<"privacy_settings"> | string
    ads?: BoolFilter<"privacy_settings"> | boolean
    data_sharing?: BoolFilter<"privacy_settings"> | boolean
    marketing_status?: BoolFilter<"privacy_settings"> | boolean
    activity_status?: BoolFilter<"privacy_settings"> | boolean
    user_id?: StringFilter<"privacy_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type privacy_settingsOrderByWithRelationInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: privacy_settingsOrderByRelevanceInput
  }

  export type privacy_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: privacy_settingsWhereInput | privacy_settingsWhereInput[]
    OR?: privacy_settingsWhereInput[]
    NOT?: privacy_settingsWhereInput | privacy_settingsWhereInput[]
    ads?: BoolFilter<"privacy_settings"> | boolean
    data_sharing?: BoolFilter<"privacy_settings"> | boolean
    marketing_status?: BoolFilter<"privacy_settings"> | boolean
    activity_status?: BoolFilter<"privacy_settings"> | boolean
    user_id?: StringFilter<"privacy_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type privacy_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
    _count?: privacy_settingsCountOrderByAggregateInput
    _max?: privacy_settingsMaxOrderByAggregateInput
    _min?: privacy_settingsMinOrderByAggregateInput
  }

  export type privacy_settingsScalarWhereWithAggregatesInput = {
    AND?: privacy_settingsScalarWhereWithAggregatesInput | privacy_settingsScalarWhereWithAggregatesInput[]
    OR?: privacy_settingsScalarWhereWithAggregatesInput[]
    NOT?: privacy_settingsScalarWhereWithAggregatesInput | privacy_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"privacy_settings"> | string
    ads?: BoolWithAggregatesFilter<"privacy_settings"> | boolean
    data_sharing?: BoolWithAggregatesFilter<"privacy_settings"> | boolean
    marketing_status?: BoolWithAggregatesFilter<"privacy_settings"> | boolean
    activity_status?: BoolWithAggregatesFilter<"privacy_settings"> | boolean
    user_id?: StringWithAggregatesFilter<"privacy_settings"> | string
  }

  export type notification_settingsWhereInput = {
    AND?: notification_settingsWhereInput | notification_settingsWhereInput[]
    OR?: notification_settingsWhereInput[]
    NOT?: notification_settingsWhereInput | notification_settingsWhereInput[]
    id?: StringFilter<"notification_settings"> | string
    alerts?: BoolFilter<"notification_settings"> | boolean
    messages?: BoolFilter<"notification_settings"> | boolean
    updates?: BoolFilter<"notification_settings"> | boolean
    billing_alerts?: BoolFilter<"notification_settings"> | boolean
    email?: BoolFilter<"notification_settings"> | boolean
    in_app?: BoolFilter<"notification_settings"> | boolean
    user_id?: StringFilter<"notification_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type notification_settingsOrderByWithRelationInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
    _relevance?: notification_settingsOrderByRelevanceInput
  }

  export type notification_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notification_settingsWhereInput | notification_settingsWhereInput[]
    OR?: notification_settingsWhereInput[]
    NOT?: notification_settingsWhereInput | notification_settingsWhereInput[]
    alerts?: BoolFilter<"notification_settings"> | boolean
    messages?: BoolFilter<"notification_settings"> | boolean
    updates?: BoolFilter<"notification_settings"> | boolean
    billing_alerts?: BoolFilter<"notification_settings"> | boolean
    email?: BoolFilter<"notification_settings"> | boolean
    in_app?: BoolFilter<"notification_settings"> | boolean
    user_id?: StringFilter<"notification_settings"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type notification_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
    _count?: notification_settingsCountOrderByAggregateInput
    _max?: notification_settingsMaxOrderByAggregateInput
    _min?: notification_settingsMinOrderByAggregateInput
  }

  export type notification_settingsScalarWhereWithAggregatesInput = {
    AND?: notification_settingsScalarWhereWithAggregatesInput | notification_settingsScalarWhereWithAggregatesInput[]
    OR?: notification_settingsScalarWhereWithAggregatesInput[]
    NOT?: notification_settingsScalarWhereWithAggregatesInput | notification_settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification_settings"> | string
    alerts?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    messages?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    updates?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    billing_alerts?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    email?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    in_app?: BoolWithAggregatesFilter<"notification_settings"> | boolean
    user_id?: StringWithAggregatesFilter<"notification_settings"> | string
  }

  export type plan_typeWhereInput = {
    AND?: plan_typeWhereInput | plan_typeWhereInput[]
    OR?: plan_typeWhereInput[]
    NOT?: plan_typeWhereInput | plan_typeWhereInput[]
    id?: StringFilter<"plan_type"> | string
    name?: StringFilter<"plan_type"> | string
    created_at?: DateTimeFilter<"plan_type"> | Date | string
    created_by?: StringFilter<"plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"plan_type"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    plan?: PlanListRelationFilter
  }

  export type plan_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    plan?: planOrderByRelationAggregateInput
    _relevance?: plan_typeOrderByRelevanceInput
  }

  export type plan_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plan_typeWhereInput | plan_typeWhereInput[]
    OR?: plan_typeWhereInput[]
    NOT?: plan_typeWhereInput | plan_typeWhereInput[]
    name?: StringFilter<"plan_type"> | string
    created_at?: DateTimeFilter<"plan_type"> | Date | string
    created_by?: StringFilter<"plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"plan_type"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    plan?: PlanListRelationFilter
  }, "id">

  export type plan_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: plan_typeCountOrderByAggregateInput
    _max?: plan_typeMaxOrderByAggregateInput
    _min?: plan_typeMinOrderByAggregateInput
  }

  export type plan_typeScalarWhereWithAggregatesInput = {
    AND?: plan_typeScalarWhereWithAggregatesInput | plan_typeScalarWhereWithAggregatesInput[]
    OR?: plan_typeScalarWhereWithAggregatesInput[]
    NOT?: plan_typeScalarWhereWithAggregatesInput | plan_typeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"plan_type"> | string
    name?: StringWithAggregatesFilter<"plan_type"> | string
    created_at?: DateTimeWithAggregatesFilter<"plan_type"> | Date | string
    created_by?: StringWithAggregatesFilter<"plan_type"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"plan_type"> | Date | string | null
  }

  export type billing_cycleWhereInput = {
    AND?: billing_cycleWhereInput | billing_cycleWhereInput[]
    OR?: billing_cycleWhereInput[]
    NOT?: billing_cycleWhereInput | billing_cycleWhereInput[]
    id?: StringFilter<"billing_cycle"> | string
    name?: StringFilter<"billing_cycle"> | string
    duration_in_days?: IntFilter<"billing_cycle"> | number
    created_at?: DateTimeFilter<"billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"billing_cycle"> | Date | string | null
    plan?: PlanListRelationFilter
  }

  export type billing_cycleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    plan?: planOrderByRelationAggregateInput
    _relevance?: billing_cycleOrderByRelevanceInput
  }

  export type billing_cycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: billing_cycleWhereInput | billing_cycleWhereInput[]
    OR?: billing_cycleWhereInput[]
    NOT?: billing_cycleWhereInput | billing_cycleWhereInput[]
    name?: StringFilter<"billing_cycle"> | string
    duration_in_days?: IntFilter<"billing_cycle"> | number
    created_at?: DateTimeFilter<"billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableFilter<"billing_cycle"> | Date | string | null
    plan?: PlanListRelationFilter
  }, "id">

  export type billing_cycleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: billing_cycleCountOrderByAggregateInput
    _avg?: billing_cycleAvgOrderByAggregateInput
    _max?: billing_cycleMaxOrderByAggregateInput
    _min?: billing_cycleMinOrderByAggregateInput
    _sum?: billing_cycleSumOrderByAggregateInput
  }

  export type billing_cycleScalarWhereWithAggregatesInput = {
    AND?: billing_cycleScalarWhereWithAggregatesInput | billing_cycleScalarWhereWithAggregatesInput[]
    OR?: billing_cycleScalarWhereWithAggregatesInput[]
    NOT?: billing_cycleScalarWhereWithAggregatesInput | billing_cycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"billing_cycle"> | string
    name?: StringWithAggregatesFilter<"billing_cycle"> | string
    duration_in_days?: IntWithAggregatesFilter<"billing_cycle"> | number
    created_at?: DateTimeWithAggregatesFilter<"billing_cycle"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"billing_cycle"> | Date | string | null
  }

  export type planWhereInput = {
    AND?: planWhereInput | planWhereInput[]
    OR?: planWhereInput[]
    NOT?: planWhereInput | planWhereInput[]
    id?: StringFilter<"plan"> | string
    service_id?: StringFilter<"plan"> | string
    plan_type_id?: StringFilter<"plan"> | string
    billing_cycle_id?: StringFilter<"plan"> | string
    price?: IntFilter<"plan"> | number
    description?: StringFilter<"plan"> | string
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    plan_type?: XOR<Plan_typeScalarRelationFilter, plan_typeWhereInput>
    billing_cycle?: XOR<Billing_cycleScalarRelationFilter, billing_cycleWhereInput>
    service_request?: Service_requestListRelationFilter
    subscription?: SubscriptionListRelationFilter
  }

  export type planOrderByWithRelationInput = {
    id?: SortOrder
    service_id?: SortOrder
    plan_type_id?: SortOrder
    billing_cycle_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    service?: serviceOrderByWithRelationInput
    plan_type?: plan_typeOrderByWithRelationInput
    billing_cycle?: billing_cycleOrderByWithRelationInput
    service_request?: service_requestOrderByRelationAggregateInput
    subscription?: subscriptionOrderByRelationAggregateInput
    _relevance?: planOrderByRelevanceInput
  }

  export type planWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: planWhereInput | planWhereInput[]
    OR?: planWhereInput[]
    NOT?: planWhereInput | planWhereInput[]
    service_id?: StringFilter<"plan"> | string
    plan_type_id?: StringFilter<"plan"> | string
    billing_cycle_id?: StringFilter<"plan"> | string
    price?: IntFilter<"plan"> | number
    description?: StringFilter<"plan"> | string
    service?: XOR<ServiceScalarRelationFilter, serviceWhereInput>
    plan_type?: XOR<Plan_typeScalarRelationFilter, plan_typeWhereInput>
    billing_cycle?: XOR<Billing_cycleScalarRelationFilter, billing_cycleWhereInput>
    service_request?: Service_requestListRelationFilter
    subscription?: SubscriptionListRelationFilter
  }, "id">

  export type planOrderByWithAggregationInput = {
    id?: SortOrder
    service_id?: SortOrder
    plan_type_id?: SortOrder
    billing_cycle_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    _count?: planCountOrderByAggregateInput
    _avg?: planAvgOrderByAggregateInput
    _max?: planMaxOrderByAggregateInput
    _min?: planMinOrderByAggregateInput
    _sum?: planSumOrderByAggregateInput
  }

  export type planScalarWhereWithAggregatesInput = {
    AND?: planScalarWhereWithAggregatesInput | planScalarWhereWithAggregatesInput[]
    OR?: planScalarWhereWithAggregatesInput[]
    NOT?: planScalarWhereWithAggregatesInput | planScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"plan"> | string
    service_id?: StringWithAggregatesFilter<"plan"> | string
    plan_type_id?: StringWithAggregatesFilter<"plan"> | string
    billing_cycle_id?: StringWithAggregatesFilter<"plan"> | string
    price?: IntWithAggregatesFilter<"plan"> | number
    description?: StringWithAggregatesFilter<"plan"> | string
  }

  export type subscriptionWhereInput = {
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    id?: StringFilter<"subscription"> | string
    start_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    status?: StringFilter<"subscription"> | string
    user_id?: StringFilter<"subscription"> | string
    plan_id?: StringFilter<"subscription"> | string
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type subscriptionOrderByWithRelationInput = {
    id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    plan?: planOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: subscriptionOrderByRelevanceInput
  }

  export type subscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: subscriptionWhereInput | subscriptionWhereInput[]
    OR?: subscriptionWhereInput[]
    NOT?: subscriptionWhereInput | subscriptionWhereInput[]
    start_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    status?: StringFilter<"subscription"> | string
    user_id?: StringFilter<"subscription"> | string
    plan_id?: StringFilter<"subscription"> | string
    plan?: XOR<PlanScalarRelationFilter, planWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type subscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    _count?: subscriptionCountOrderByAggregateInput
    _max?: subscriptionMaxOrderByAggregateInput
    _min?: subscriptionMinOrderByAggregateInput
  }

  export type subscriptionScalarWhereWithAggregatesInput = {
    AND?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    OR?: subscriptionScalarWhereWithAggregatesInput[]
    NOT?: subscriptionScalarWhereWithAggregatesInput | subscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subscription"> | string
    start_date?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"subscription"> | Date | string | null
    status?: StringWithAggregatesFilter<"subscription"> | string
    user_id?: StringWithAggregatesFilter<"subscription"> | string
    plan_id?: StringWithAggregatesFilter<"subscription"> | string
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: StringFilter<"role"> | string
    title?: StringFilter<"role"> | string
    description?: StringNullableFilter<"role"> | string | null
    created_at?: DateTimeFilter<"role"> | Date | string
    created_by?: StringNullableFilter<"role"> | string | null
    deleted_at?: DateTimeNullableFilter<"role"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: UserListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    creator?: userOrderByWithRelationInput
    user?: userOrderByRelationAggregateInput
    _relevance?: roleOrderByRelevanceInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    title?: StringFilter<"role"> | string
    description?: StringNullableFilter<"role"> | string | null
    created_at?: DateTimeFilter<"role"> | Date | string
    created_by?: StringNullableFilter<"role"> | string | null
    deleted_at?: DateTimeNullableFilter<"role"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user?: UserListRelationFilter
  }, "id">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"role"> | string
    title?: StringWithAggregatesFilter<"role"> | string
    description?: StringNullableWithAggregatesFilter<"role"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"role"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"role"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"role"> | Date | string | null
  }

  export type userCreateInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organisationCreateInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    case_studies?: case_studiesCreateNestedManyWithoutOrganisationInput
    contact?: contactCreateNestedManyWithoutOrganisationInput
    user: userCreateNestedOneWithoutOrganisationInput
  }

  export type organisationUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutOrganisationInput
    contact?: contactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type organisationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUpdateManyWithoutOrganisationNestedInput
    contact?: contactUpdateManyWithoutOrganisationNestedInput
    user?: userUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type organisationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUncheckedUpdateManyWithoutOrganisationNestedInput
    contact?: contactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type organisationCreateManyInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
  }

  export type organisationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type organisationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceCreateInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutServiceInput
    service_request?: service_requestCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesCreateNestedManyWithoutServiceInput
    testimonial?: testimonialCreateNestedManyWithoutServiceInput
    plan?: planCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestUncheckedCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutServiceInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutServiceInput
    plan?: planUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceNestedInput
    service_request?: service_requestUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUpdateManyWithoutServiceNestedInput
    plan?: planUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUncheckedUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUncheckedUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutServiceNestedInput
    plan?: planUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceCreateManyInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
  }

  export type serviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type service_requestCreateInput = {
    id?: string
    message: string
    requested_at?: Date | string
    status: string
    plan: planCreateNestedOneWithoutService_requestInput
    service: serviceCreateNestedOneWithoutService_requestInput
    user: userCreateNestedOneWithoutService_requestInput
  }

  export type service_requestUncheckedCreateInput = {
    id?: string
    message: string
    service_id: string
    user_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type service_requestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: planUpdateOneRequiredWithoutService_requestNestedInput
    service?: serviceUpdateOneRequiredWithoutService_requestNestedInput
    user?: userUpdateOneRequiredWithoutService_requestNestedInput
  }

  export type service_requestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestCreateManyInput = {
    id?: string
    message: string
    service_id: string
    user_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type service_requestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesCreateInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    organisation: organisationCreateNestedOneWithoutCase_studiesInput
    service: serviceCreateNestedOneWithoutCase_studiesInput
  }

  export type case_studiesUncheckedCreateInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service_id: string
    organisation_id: string
  }

  export type case_studiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    organisation?: organisationUpdateOneRequiredWithoutCase_studiesNestedInput
    service?: serviceUpdateOneRequiredWithoutCase_studiesNestedInput
  }

  export type case_studiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesCreateManyInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service_id: string
    organisation_id: string
  }

  export type case_studiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
  }

  export type testimonialCreateInput = {
    id?: string
    message: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
    service: serviceCreateNestedOneWithoutTestimonialInput
    user: userCreateNestedOneWithoutTestimonialInput
  }

  export type testimonialUncheckedCreateInput = {
    id?: string
    message: string
    user_id: string
    service_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type testimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: serviceUpdateOneRequiredWithoutTestimonialNestedInput
    user?: userUpdateOneRequiredWithoutTestimonialNestedInput
  }

  export type testimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testimonialCreateManyInput = {
    id?: string
    message: string
    user_id: string
    service_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type testimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactCreateInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    organisation: organisationCreateNestedOneWithoutContactInput
  }

  export type contactUncheckedCreateInput = {
    id?: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organisation?: organisationUpdateOneRequiredWithoutContactNestedInput
  }

  export type contactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactCreateManyInput = {
    id?: string
    name: string
    pfp_url: string
    organisation_id: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpCreateInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user: userCreateNestedOneWithoutOtpInput
  }

  export type otpUncheckedCreateInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user_id: string
  }

  export type otpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutOtpNestedInput
  }

  export type otpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type otpCreateManyInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
    user_id: string
  }

  export type otpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type password_tokenCreateInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user: userCreateNestedOneWithoutPassword_tokenInput
  }

  export type password_tokenUncheckedCreateInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user_id: string
  }

  export type password_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutPassword_tokenNestedInput
  }

  export type password_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type password_tokenCreateManyInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
    user_id: string
  }

  export type password_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user: userCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user_id: string
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateManyInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
    user_id: string
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type privacy_settingsCreateInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user: userCreateNestedOneWithoutPrivacy_settingsInput
  }

  export type privacy_settingsUncheckedCreateInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id: string
  }

  export type privacy_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutPrivacy_settingsNestedInput
  }

  export type privacy_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type privacy_settingsCreateManyInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
    user_id: string
  }

  export type privacy_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type privacy_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type notification_settingsCreateInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user: userCreateNestedOneWithoutNotification_settingsInput
  }

  export type notification_settingsUncheckedCreateInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id: string
  }

  export type notification_settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutNotification_settingsNestedInput
  }

  export type notification_settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type notification_settingsCreateManyInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
    user_id: string
  }

  export type notification_settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type plan_typeCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutPlan_typeInput
    plan?: planCreateNestedManyWithoutPlan_typeInput
  }

  export type plan_typeUncheckedCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
    plan?: planUncheckedCreateNestedManyWithoutPlan_typeInput
  }

  export type plan_typeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutPlan_typeNestedInput
    plan?: planUpdateManyWithoutPlan_typeNestedInput
  }

  export type plan_typeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUncheckedUpdateManyWithoutPlan_typeNestedInput
  }

  export type plan_typeCreateManyInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
  }

  export type plan_typeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plan_typeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type billing_cycleCreateInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    plan?: planCreateNestedManyWithoutBilling_cycleInput
  }

  export type billing_cycleUncheckedCreateInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    plan?: planUncheckedCreateNestedManyWithoutBilling_cycleInput
  }

  export type billing_cycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUpdateManyWithoutBilling_cycleNestedInput
  }

  export type billing_cycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUncheckedUpdateManyWithoutBilling_cycleNestedInput
  }

  export type billing_cycleCreateManyInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type billing_cycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type billing_cycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type planCreateInput = {
    id?: string
    price: number
    description: string
    service: serviceCreateNestedOneWithoutPlanInput
    plan_type: plan_typeCreateNestedOneWithoutPlanInput
    billing_cycle: billing_cycleCreateNestedOneWithoutPlanInput
    service_request?: service_requestCreateNestedManyWithoutPlanInput
    subscription?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateInput = {
    id?: string
    service_id: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
    service_request?: service_requestUncheckedCreateNestedManyWithoutPlanInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutPlanNestedInput
    plan_type?: plan_typeUpdateOneRequiredWithoutPlanNestedInput
    billing_cycle?: billing_cycleUpdateOneRequiredWithoutPlanNestedInput
    service_request?: service_requestUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service_request?: service_requestUncheckedUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type planCreateManyInput = {
    id?: string
    service_id: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
  }

  export type planUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type planUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionCreateInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan: planCreateNestedOneWithoutSubscriptionInput
    user: userCreateNestedOneWithoutSubscriptionInput
  }

  export type subscriptionUncheckedCreateInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
    plan_id: string
  }

  export type subscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: planUpdateOneRequiredWithoutSubscriptionNestedInput
    user?: userUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type subscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionCreateManyInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
    plan_id: string
  }

  export type subscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type roleCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    creator?: userCreateNestedOneWithoutCreated_roleInput
    user?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
    user?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: userUpdateOneWithoutCreated_roleNestedInput
    user?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
  }

  export type roleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type Notification_settingsListRelationFilter = {
    every?: notification_settingsWhereInput
    some?: notification_settingsWhereInput
    none?: notification_settingsWhereInput
  }

  export type OrganisationListRelationFilter = {
    every?: organisationWhereInput
    some?: organisationWhereInput
    none?: organisationWhereInput
  }

  export type OtpListRelationFilter = {
    every?: otpWhereInput
    some?: otpWhereInput
    none?: otpWhereInput
  }

  export type Password_tokenListRelationFilter = {
    every?: password_tokenWhereInput
    some?: password_tokenWhereInput
    none?: password_tokenWhereInput
  }

  export type Privacy_settingsListRelationFilter = {
    every?: privacy_settingsWhereInput
    some?: privacy_settingsWhereInput
    none?: privacy_settingsWhereInput
  }

  export type RoleListRelationFilter = {
    every?: roleWhereInput
    some?: roleWhereInput
    none?: roleWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: serviceWhereInput
    some?: serviceWhereInput
    none?: serviceWhereInput
  }

  export type Service_requestListRelationFilter = {
    every?: service_requestWhereInput
    some?: service_requestWhereInput
    none?: service_requestWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: subscriptionWhereInput
    some?: subscriptionWhereInput
    none?: subscriptionWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: testimonialWhereInput
    some?: testimonialWhereInput
    none?: testimonialWhereInput
  }

  export type Plan_typeListRelationFilter = {
    every?: plan_typeWhereInput
    some?: plan_typeWhereInput
    none?: plan_typeWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notification_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organisationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type otpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type password_tokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type privacy_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_requestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type testimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plan_typeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    id_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    tel?: SortOrder
    country?: SortOrder
    address?: SortOrder
    category?: SortOrder
    pfp_url?: SortOrder
    business_status?: SortOrder
    registered_with_a_business?: SortOrder
    password?: SortOrder
    status?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Case_studiesListRelationFilter = {
    every?: case_studiesWhereInput
    some?: case_studiesWhereInput
    none?: case_studiesWhereInput
  }

  export type ContactListRelationFilter = {
    every?: contactWhereInput
    some?: contactWhereInput
    none?: contactWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type case_studiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type contactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organisationOrderByRelevanceInput = {
    fields: organisationOrderByRelevanceFieldEnum | organisationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type organisationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type organisationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type organisationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    country?: SortOrder
    industry?: SortOrder
    logo_url?: SortOrder
    rc_number?: SortOrder
    staff_size?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    deleted_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PlanListRelationFilter = {
    every?: planWhereInput
    some?: planWhereInput
    none?: planWhereInput
  }

  export type planOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serviceOrderByRelevanceInput = {
    fields: serviceOrderByRelevanceFieldEnum | serviceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type serviceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtitle?: SortOrder
    created_at?: SortOrder
    admin_id?: SortOrder
    banner_url?: SortOrder
    deleted_at?: SortOrder
  }

  export type serviceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtitle?: SortOrder
    created_at?: SortOrder
    admin_id?: SortOrder
    banner_url?: SortOrder
    deleted_at?: SortOrder
  }

  export type serviceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subtitle?: SortOrder
    created_at?: SortOrder
    admin_id?: SortOrder
    banner_url?: SortOrder
    deleted_at?: SortOrder
  }

  export type PlanScalarRelationFilter = {
    is?: planWhereInput
    isNot?: planWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: serviceWhereInput
    isNot?: serviceWhereInput
  }

  export type service_requestOrderByRelevanceInput = {
    fields: service_requestOrderByRelevanceFieldEnum | service_requestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type service_requestCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    requested_at?: SortOrder
    status?: SortOrder
    plan_id?: SortOrder
  }

  export type service_requestMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    requested_at?: SortOrder
    status?: SortOrder
    plan_id?: SortOrder
  }

  export type service_requestMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    service_id?: SortOrder
    user_id?: SortOrder
    requested_at?: SortOrder
    status?: SortOrder
    plan_id?: SortOrder
  }

  export type OrganisationScalarRelationFilter = {
    is?: organisationWhereInput
    isNot?: organisationWhereInput
  }

  export type case_studiesOrderByRelevanceInput = {
    fields: case_studiesOrderByRelevanceFieldEnum | case_studiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type case_studiesCountOrderByAggregateInput = {
    id?: SortOrder
    banner?: SortOrder
    challenge?: SortOrder
    challenge_img?: SortOrder
    solution?: SortOrder
    solution_img?: SortOrder
    result?: SortOrder
    result_img?: SortOrder
    service_id?: SortOrder
    organisation_id?: SortOrder
  }

  export type case_studiesMaxOrderByAggregateInput = {
    id?: SortOrder
    banner?: SortOrder
    challenge?: SortOrder
    challenge_img?: SortOrder
    solution?: SortOrder
    solution_img?: SortOrder
    result?: SortOrder
    result_img?: SortOrder
    service_id?: SortOrder
    organisation_id?: SortOrder
  }

  export type case_studiesMinOrderByAggregateInput = {
    id?: SortOrder
    banner?: SortOrder
    challenge?: SortOrder
    challenge_img?: SortOrder
    solution?: SortOrder
    solution_img?: SortOrder
    result?: SortOrder
    result_img?: SortOrder
    service_id?: SortOrder
    organisation_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type testimonialOrderByRelevanceInput = {
    fields: testimonialOrderByRelevanceFieldEnum | testimonialOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testimonialCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    stars?: SortOrder
    user_title?: SortOrder
    deleted_at?: SortOrder
  }

  export type testimonialAvgOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type testimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    stars?: SortOrder
    user_title?: SortOrder
    deleted_at?: SortOrder
  }

  export type testimonialMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    user_id?: SortOrder
    service_id?: SortOrder
    stars?: SortOrder
    user_title?: SortOrder
    deleted_at?: SortOrder
  }

  export type testimonialSumOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type contactOrderByRelevanceInput = {
    fields: contactOrderByRelevanceFieldEnum | contactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    id_url?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pfp_url?: SortOrder
    organisation_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type otpOrderByRelevanceInput = {
    fields: otpOrderByRelevanceFieldEnum | otpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type otpCountOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type otpMaxOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type otpMinOrderByAggregateInput = {
    id?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type password_tokenOrderByRelevanceInput = {
    fields: password_tokenOrderByRelevanceFieldEnum | password_tokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type password_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type password_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type password_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    expires_at?: SortOrder
    user_id?: SortOrder
  }

  export type notificationOrderByRelevanceInput = {
    fields: notificationOrderByRelevanceFieldEnum | notificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    activity?: SortOrder
    completed_at?: SortOrder
    user_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type privacy_settingsOrderByRelevanceInput = {
    fields: privacy_settingsOrderByRelevanceFieldEnum | privacy_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type privacy_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type privacy_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type privacy_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    ads?: SortOrder
    data_sharing?: SortOrder
    marketing_status?: SortOrder
    activity_status?: SortOrder
    user_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type notification_settingsOrderByRelevanceInput = {
    fields: notification_settingsOrderByRelevanceFieldEnum | notification_settingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notification_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type notification_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type notification_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    alerts?: SortOrder
    messages?: SortOrder
    updates?: SortOrder
    billing_alerts?: SortOrder
    email?: SortOrder
    in_app?: SortOrder
    user_id?: SortOrder
  }

  export type plan_typeOrderByRelevanceInput = {
    fields: plan_typeOrderByRelevanceFieldEnum | plan_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type plan_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type plan_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type plan_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type billing_cycleOrderByRelevanceInput = {
    fields: billing_cycleOrderByRelevanceFieldEnum | billing_cycleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type billing_cycleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type billing_cycleAvgOrderByAggregateInput = {
    duration_in_days?: SortOrder
  }

  export type billing_cycleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type billing_cycleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration_in_days?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type billing_cycleSumOrderByAggregateInput = {
    duration_in_days?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Plan_typeScalarRelationFilter = {
    is?: plan_typeWhereInput
    isNot?: plan_typeWhereInput
  }

  export type Billing_cycleScalarRelationFilter = {
    is?: billing_cycleWhereInput
    isNot?: billing_cycleWhereInput
  }

  export type planOrderByRelevanceInput = {
    fields: planOrderByRelevanceFieldEnum | planOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type planCountOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    plan_type_id?: SortOrder
    billing_cycle_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
  }

  export type planAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type planMaxOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    plan_type_id?: SortOrder
    billing_cycle_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
  }

  export type planMinOrderByAggregateInput = {
    id?: SortOrder
    service_id?: SortOrder
    plan_type_id?: SortOrder
    billing_cycle_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
  }

  export type planSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type subscriptionOrderByRelevanceInput = {
    fields: subscriptionOrderByRelevanceFieldEnum | subscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type subscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type subscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleOrderByRelevanceInput = {
    fields: roleOrderByRelevanceFieldEnum | roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notification_settingsCreateNestedManyWithoutUserInput = {
    create?: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput> | notification_settingsCreateWithoutUserInput[] | notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notification_settingsCreateOrConnectWithoutUserInput | notification_settingsCreateOrConnectWithoutUserInput[]
    createMany?: notification_settingsCreateManyUserInputEnvelope
    connect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
  }

  export type organisationCreateNestedManyWithoutUserInput = {
    create?: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput> | organisationCreateWithoutUserInput[] | organisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: organisationCreateOrConnectWithoutUserInput | organisationCreateOrConnectWithoutUserInput[]
    createMany?: organisationCreateManyUserInputEnvelope
    connect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
  }

  export type otpCreateNestedManyWithoutUserInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    createMany?: otpCreateManyUserInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type password_tokenCreateNestedManyWithoutUserInput = {
    create?: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput> | password_tokenCreateWithoutUserInput[] | password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_tokenCreateOrConnectWithoutUserInput | password_tokenCreateOrConnectWithoutUserInput[]
    createMany?: password_tokenCreateManyUserInputEnvelope
    connect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
  }

  export type privacy_settingsCreateNestedManyWithoutUserInput = {
    create?: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput> | privacy_settingsCreateWithoutUserInput[] | privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: privacy_settingsCreateOrConnectWithoutUserInput | privacy_settingsCreateOrConnectWithoutUserInput[]
    createMany?: privacy_settingsCreateManyUserInputEnvelope
    connect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
  }

  export type roleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput> | roleCreateWithoutCreatorInput[] | roleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreatorInput | roleCreateOrConnectWithoutCreatorInput[]
    createMany?: roleCreateManyCreatorInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type serviceCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput> | serviceCreateWithoutUserInput[] | serviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutUserInput | serviceCreateOrConnectWithoutUserInput[]
    createMany?: serviceCreateManyUserInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type service_requestCreateNestedManyWithoutUserInput = {
    create?: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput> | service_requestCreateWithoutUserInput[] | service_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutUserInput | service_requestCreateOrConnectWithoutUserInput[]
    createMany?: service_requestCreateManyUserInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type subscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type testimonialCreateNestedManyWithoutUserInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type plan_typeCreateNestedManyWithoutUserInput = {
    create?: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput> | plan_typeCreateWithoutUserInput[] | plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: plan_typeCreateOrConnectWithoutUserInput | plan_typeCreateOrConnectWithoutUserInput[]
    createMany?: plan_typeCreateManyUserInputEnvelope
    connect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
  }

  export type roleCreateNestedOneWithoutUserInput = {
    create?: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserInput
    connect?: roleWhereUniqueInput
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type notification_settingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput> | notification_settingsCreateWithoutUserInput[] | notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notification_settingsCreateOrConnectWithoutUserInput | notification_settingsCreateOrConnectWithoutUserInput[]
    createMany?: notification_settingsCreateManyUserInputEnvelope
    connect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
  }

  export type organisationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput> | organisationCreateWithoutUserInput[] | organisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: organisationCreateOrConnectWithoutUserInput | organisationCreateOrConnectWithoutUserInput[]
    createMany?: organisationCreateManyUserInputEnvelope
    connect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
  }

  export type otpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    createMany?: otpCreateManyUserInputEnvelope
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
  }

  export type password_tokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput> | password_tokenCreateWithoutUserInput[] | password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_tokenCreateOrConnectWithoutUserInput | password_tokenCreateOrConnectWithoutUserInput[]
    createMany?: password_tokenCreateManyUserInputEnvelope
    connect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
  }

  export type privacy_settingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput> | privacy_settingsCreateWithoutUserInput[] | privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: privacy_settingsCreateOrConnectWithoutUserInput | privacy_settingsCreateOrConnectWithoutUserInput[]
    createMany?: privacy_settingsCreateManyUserInputEnvelope
    connect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
  }

  export type roleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput> | roleCreateWithoutCreatorInput[] | roleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreatorInput | roleCreateOrConnectWithoutCreatorInput[]
    createMany?: roleCreateManyCreatorInputEnvelope
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
  }

  export type serviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput> | serviceCreateWithoutUserInput[] | serviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutUserInput | serviceCreateOrConnectWithoutUserInput[]
    createMany?: serviceCreateManyUserInputEnvelope
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
  }

  export type service_requestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput> | service_requestCreateWithoutUserInput[] | service_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutUserInput | service_requestCreateOrConnectWithoutUserInput[]
    createMany?: service_requestCreateManyUserInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type subscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type testimonialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type plan_typeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput> | plan_typeCreateWithoutUserInput[] | plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: plan_typeCreateOrConnectWithoutUserInput | plan_typeCreateOrConnectWithoutUserInput[]
    createMany?: plan_typeCreateManyUserInputEnvelope
    connect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type notification_settingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput> | notification_settingsCreateWithoutUserInput[] | notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notification_settingsCreateOrConnectWithoutUserInput | notification_settingsCreateOrConnectWithoutUserInput[]
    upsert?: notification_settingsUpsertWithWhereUniqueWithoutUserInput | notification_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notification_settingsCreateManyUserInputEnvelope
    set?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    disconnect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    delete?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    connect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    update?: notification_settingsUpdateWithWhereUniqueWithoutUserInput | notification_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notification_settingsUpdateManyWithWhereWithoutUserInput | notification_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notification_settingsScalarWhereInput | notification_settingsScalarWhereInput[]
  }

  export type organisationUpdateManyWithoutUserNestedInput = {
    create?: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput> | organisationCreateWithoutUserInput[] | organisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: organisationCreateOrConnectWithoutUserInput | organisationCreateOrConnectWithoutUserInput[]
    upsert?: organisationUpsertWithWhereUniqueWithoutUserInput | organisationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: organisationCreateManyUserInputEnvelope
    set?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    disconnect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    delete?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    connect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    update?: organisationUpdateWithWhereUniqueWithoutUserInput | organisationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: organisationUpdateManyWithWhereWithoutUserInput | organisationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: organisationScalarWhereInput | organisationScalarWhereInput[]
  }

  export type otpUpdateManyWithoutUserNestedInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUserInput | otpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: otpCreateManyUserInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUserInput | otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUserInput | otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type password_tokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput> | password_tokenCreateWithoutUserInput[] | password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_tokenCreateOrConnectWithoutUserInput | password_tokenCreateOrConnectWithoutUserInput[]
    upsert?: password_tokenUpsertWithWhereUniqueWithoutUserInput | password_tokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: password_tokenCreateManyUserInputEnvelope
    set?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    disconnect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    delete?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    connect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    update?: password_tokenUpdateWithWhereUniqueWithoutUserInput | password_tokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: password_tokenUpdateManyWithWhereWithoutUserInput | password_tokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: password_tokenScalarWhereInput | password_tokenScalarWhereInput[]
  }

  export type privacy_settingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput> | privacy_settingsCreateWithoutUserInput[] | privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: privacy_settingsCreateOrConnectWithoutUserInput | privacy_settingsCreateOrConnectWithoutUserInput[]
    upsert?: privacy_settingsUpsertWithWhereUniqueWithoutUserInput | privacy_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: privacy_settingsCreateManyUserInputEnvelope
    set?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    disconnect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    delete?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    connect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    update?: privacy_settingsUpdateWithWhereUniqueWithoutUserInput | privacy_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: privacy_settingsUpdateManyWithWhereWithoutUserInput | privacy_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: privacy_settingsScalarWhereInput | privacy_settingsScalarWhereInput[]
  }

  export type roleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput> | roleCreateWithoutCreatorInput[] | roleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreatorInput | roleCreateOrConnectWithoutCreatorInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutCreatorInput | roleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: roleCreateManyCreatorInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutCreatorInput | roleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: roleUpdateManyWithWhereWithoutCreatorInput | roleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type serviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput> | serviceCreateWithoutUserInput[] | serviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutUserInput | serviceCreateOrConnectWithoutUserInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutUserInput | serviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceCreateManyUserInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutUserInput | serviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutUserInput | serviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type service_requestUpdateManyWithoutUserNestedInput = {
    create?: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput> | service_requestCreateWithoutUserInput[] | service_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutUserInput | service_requestCreateOrConnectWithoutUserInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutUserInput | service_requestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: service_requestCreateManyUserInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutUserInput | service_requestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutUserInput | service_requestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type subscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUserInput | subscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUserInput | subscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUserInput | subscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type testimonialUpdateManyWithoutUserNestedInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutUserInput | testimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutUserInput | testimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutUserInput | testimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type plan_typeUpdateManyWithoutUserNestedInput = {
    create?: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput> | plan_typeCreateWithoutUserInput[] | plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: plan_typeCreateOrConnectWithoutUserInput | plan_typeCreateOrConnectWithoutUserInput[]
    upsert?: plan_typeUpsertWithWhereUniqueWithoutUserInput | plan_typeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: plan_typeCreateManyUserInputEnvelope
    set?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    disconnect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    delete?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    connect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    update?: plan_typeUpdateWithWhereUniqueWithoutUserInput | plan_typeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: plan_typeUpdateManyWithWhereWithoutUserInput | plan_typeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: plan_typeScalarWhereInput | plan_typeScalarWhereInput[]
  }

  export type roleUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserInput
    upsert?: roleUpsertWithoutUserInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserInput, roleUpdateWithoutUserInput>, roleUncheckedUpdateWithoutUserInput>
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type notification_settingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput> | notification_settingsCreateWithoutUserInput[] | notification_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notification_settingsCreateOrConnectWithoutUserInput | notification_settingsCreateOrConnectWithoutUserInput[]
    upsert?: notification_settingsUpsertWithWhereUniqueWithoutUserInput | notification_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notification_settingsCreateManyUserInputEnvelope
    set?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    disconnect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    delete?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    connect?: notification_settingsWhereUniqueInput | notification_settingsWhereUniqueInput[]
    update?: notification_settingsUpdateWithWhereUniqueWithoutUserInput | notification_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notification_settingsUpdateManyWithWhereWithoutUserInput | notification_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notification_settingsScalarWhereInput | notification_settingsScalarWhereInput[]
  }

  export type organisationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput> | organisationCreateWithoutUserInput[] | organisationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: organisationCreateOrConnectWithoutUserInput | organisationCreateOrConnectWithoutUserInput[]
    upsert?: organisationUpsertWithWhereUniqueWithoutUserInput | organisationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: organisationCreateManyUserInputEnvelope
    set?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    disconnect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    delete?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    connect?: organisationWhereUniqueInput | organisationWhereUniqueInput[]
    update?: organisationUpdateWithWhereUniqueWithoutUserInput | organisationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: organisationUpdateManyWithWhereWithoutUserInput | organisationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: organisationScalarWhereInput | organisationScalarWhereInput[]
  }

  export type otpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput> | otpCreateWithoutUserInput[] | otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: otpCreateOrConnectWithoutUserInput | otpCreateOrConnectWithoutUserInput[]
    upsert?: otpUpsertWithWhereUniqueWithoutUserInput | otpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: otpCreateManyUserInputEnvelope
    set?: otpWhereUniqueInput | otpWhereUniqueInput[]
    disconnect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    delete?: otpWhereUniqueInput | otpWhereUniqueInput[]
    connect?: otpWhereUniqueInput | otpWhereUniqueInput[]
    update?: otpUpdateWithWhereUniqueWithoutUserInput | otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: otpUpdateManyWithWhereWithoutUserInput | otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: otpScalarWhereInput | otpScalarWhereInput[]
  }

  export type password_tokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput> | password_tokenCreateWithoutUserInput[] | password_tokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_tokenCreateOrConnectWithoutUserInput | password_tokenCreateOrConnectWithoutUserInput[]
    upsert?: password_tokenUpsertWithWhereUniqueWithoutUserInput | password_tokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: password_tokenCreateManyUserInputEnvelope
    set?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    disconnect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    delete?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    connect?: password_tokenWhereUniqueInput | password_tokenWhereUniqueInput[]
    update?: password_tokenUpdateWithWhereUniqueWithoutUserInput | password_tokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: password_tokenUpdateManyWithWhereWithoutUserInput | password_tokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: password_tokenScalarWhereInput | password_tokenScalarWhereInput[]
  }

  export type privacy_settingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput> | privacy_settingsCreateWithoutUserInput[] | privacy_settingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: privacy_settingsCreateOrConnectWithoutUserInput | privacy_settingsCreateOrConnectWithoutUserInput[]
    upsert?: privacy_settingsUpsertWithWhereUniqueWithoutUserInput | privacy_settingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: privacy_settingsCreateManyUserInputEnvelope
    set?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    disconnect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    delete?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    connect?: privacy_settingsWhereUniqueInput | privacy_settingsWhereUniqueInput[]
    update?: privacy_settingsUpdateWithWhereUniqueWithoutUserInput | privacy_settingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: privacy_settingsUpdateManyWithWhereWithoutUserInput | privacy_settingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: privacy_settingsScalarWhereInput | privacy_settingsScalarWhereInput[]
  }

  export type roleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput> | roleCreateWithoutCreatorInput[] | roleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: roleCreateOrConnectWithoutCreatorInput | roleCreateOrConnectWithoutCreatorInput[]
    upsert?: roleUpsertWithWhereUniqueWithoutCreatorInput | roleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: roleCreateManyCreatorInputEnvelope
    set?: roleWhereUniqueInput | roleWhereUniqueInput[]
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[]
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[]
    update?: roleUpdateWithWhereUniqueWithoutCreatorInput | roleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: roleUpdateManyWithWhereWithoutCreatorInput | roleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[]
  }

  export type serviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput> | serviceCreateWithoutUserInput[] | serviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: serviceCreateOrConnectWithoutUserInput | serviceCreateOrConnectWithoutUserInput[]
    upsert?: serviceUpsertWithWhereUniqueWithoutUserInput | serviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: serviceCreateManyUserInputEnvelope
    set?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    disconnect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    delete?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    connect?: serviceWhereUniqueInput | serviceWhereUniqueInput[]
    update?: serviceUpdateWithWhereUniqueWithoutUserInput | serviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: serviceUpdateManyWithWhereWithoutUserInput | serviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: serviceScalarWhereInput | serviceScalarWhereInput[]
  }

  export type service_requestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput> | service_requestCreateWithoutUserInput[] | service_requestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutUserInput | service_requestCreateOrConnectWithoutUserInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutUserInput | service_requestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: service_requestCreateManyUserInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutUserInput | service_requestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutUserInput | service_requestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type subscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput> | subscriptionCreateWithoutUserInput[] | subscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutUserInput | subscriptionCreateOrConnectWithoutUserInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutUserInput | subscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: subscriptionCreateManyUserInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutUserInput | subscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutUserInput | subscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type testimonialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutUserInput | testimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutUserInput | testimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutUserInput | testimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type plan_typeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput> | plan_typeCreateWithoutUserInput[] | plan_typeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: plan_typeCreateOrConnectWithoutUserInput | plan_typeCreateOrConnectWithoutUserInput[]
    upsert?: plan_typeUpsertWithWhereUniqueWithoutUserInput | plan_typeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: plan_typeCreateManyUserInputEnvelope
    set?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    disconnect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    delete?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    connect?: plan_typeWhereUniqueInput | plan_typeWhereUniqueInput[]
    update?: plan_typeUpdateWithWhereUniqueWithoutUserInput | plan_typeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: plan_typeUpdateManyWithWhereWithoutUserInput | plan_typeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: plan_typeScalarWhereInput | plan_typeScalarWhereInput[]
  }

  export type case_studiesCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput> | case_studiesCreateWithoutOrganisationInput[] | case_studiesUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutOrganisationInput | case_studiesCreateOrConnectWithoutOrganisationInput[]
    createMany?: case_studiesCreateManyOrganisationInputEnvelope
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
  }

  export type contactCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput> | contactCreateWithoutOrganisationInput[] | contactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: contactCreateOrConnectWithoutOrganisationInput | contactCreateOrConnectWithoutOrganisationInput[]
    createMany?: contactCreateManyOrganisationInputEnvelope
    connect?: contactWhereUniqueInput | contactWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutOrganisationInput = {
    create?: XOR<userCreateWithoutOrganisationInput, userUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: userCreateOrConnectWithoutOrganisationInput
    connect?: userWhereUniqueInput
  }

  export type case_studiesUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput> | case_studiesCreateWithoutOrganisationInput[] | case_studiesUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutOrganisationInput | case_studiesCreateOrConnectWithoutOrganisationInput[]
    createMany?: case_studiesCreateManyOrganisationInputEnvelope
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
  }

  export type contactUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput> | contactCreateWithoutOrganisationInput[] | contactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: contactCreateOrConnectWithoutOrganisationInput | contactCreateOrConnectWithoutOrganisationInput[]
    createMany?: contactCreateManyOrganisationInputEnvelope
    connect?: contactWhereUniqueInput | contactWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type case_studiesUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput> | case_studiesCreateWithoutOrganisationInput[] | case_studiesUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutOrganisationInput | case_studiesCreateOrConnectWithoutOrganisationInput[]
    upsert?: case_studiesUpsertWithWhereUniqueWithoutOrganisationInput | case_studiesUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: case_studiesCreateManyOrganisationInputEnvelope
    set?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    disconnect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    delete?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    update?: case_studiesUpdateWithWhereUniqueWithoutOrganisationInput | case_studiesUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: case_studiesUpdateManyWithWhereWithoutOrganisationInput | case_studiesUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
  }

  export type contactUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput> | contactCreateWithoutOrganisationInput[] | contactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: contactCreateOrConnectWithoutOrganisationInput | contactCreateOrConnectWithoutOrganisationInput[]
    upsert?: contactUpsertWithWhereUniqueWithoutOrganisationInput | contactUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: contactCreateManyOrganisationInputEnvelope
    set?: contactWhereUniqueInput | contactWhereUniqueInput[]
    disconnect?: contactWhereUniqueInput | contactWhereUniqueInput[]
    delete?: contactWhereUniqueInput | contactWhereUniqueInput[]
    connect?: contactWhereUniqueInput | contactWhereUniqueInput[]
    update?: contactUpdateWithWhereUniqueWithoutOrganisationInput | contactUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: contactUpdateManyWithWhereWithoutOrganisationInput | contactUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: contactScalarWhereInput | contactScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutOrganisationNestedInput = {
    create?: XOR<userCreateWithoutOrganisationInput, userUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: userCreateOrConnectWithoutOrganisationInput
    upsert?: userUpsertWithoutOrganisationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOrganisationInput, userUpdateWithoutOrganisationInput>, userUncheckedUpdateWithoutOrganisationInput>
  }

  export type case_studiesUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput> | case_studiesCreateWithoutOrganisationInput[] | case_studiesUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutOrganisationInput | case_studiesCreateOrConnectWithoutOrganisationInput[]
    upsert?: case_studiesUpsertWithWhereUniqueWithoutOrganisationInput | case_studiesUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: case_studiesCreateManyOrganisationInputEnvelope
    set?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    disconnect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    delete?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    update?: case_studiesUpdateWithWhereUniqueWithoutOrganisationInput | case_studiesUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: case_studiesUpdateManyWithWhereWithoutOrganisationInput | case_studiesUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
  }

  export type contactUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput> | contactCreateWithoutOrganisationInput[] | contactUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: contactCreateOrConnectWithoutOrganisationInput | contactCreateOrConnectWithoutOrganisationInput[]
    upsert?: contactUpsertWithWhereUniqueWithoutOrganisationInput | contactUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: contactCreateManyOrganisationInputEnvelope
    set?: contactWhereUniqueInput | contactWhereUniqueInput[]
    disconnect?: contactWhereUniqueInput | contactWhereUniqueInput[]
    delete?: contactWhereUniqueInput | contactWhereUniqueInput[]
    connect?: contactWhereUniqueInput | contactWhereUniqueInput[]
    update?: contactUpdateWithWhereUniqueWithoutOrganisationInput | contactUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: contactUpdateManyWithWhereWithoutOrganisationInput | contactUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: contactScalarWhereInput | contactScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutServiceInput = {
    create?: XOR<userCreateWithoutServiceInput, userUncheckedCreateWithoutServiceInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceInput
    connect?: userWhereUniqueInput
  }

  export type service_requestCreateNestedManyWithoutServiceInput = {
    create?: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput> | service_requestCreateWithoutServiceInput[] | service_requestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutServiceInput | service_requestCreateOrConnectWithoutServiceInput[]
    createMany?: service_requestCreateManyServiceInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type case_studiesCreateNestedManyWithoutServiceInput = {
    create?: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput> | case_studiesCreateWithoutServiceInput[] | case_studiesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutServiceInput | case_studiesCreateOrConnectWithoutServiceInput[]
    createMany?: case_studiesCreateManyServiceInputEnvelope
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
  }

  export type testimonialCreateNestedManyWithoutServiceInput = {
    create?: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput> | testimonialCreateWithoutServiceInput[] | testimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutServiceInput | testimonialCreateOrConnectWithoutServiceInput[]
    createMany?: testimonialCreateManyServiceInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type planCreateNestedManyWithoutServiceInput = {
    create?: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput> | planCreateWithoutServiceInput[] | planUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: planCreateOrConnectWithoutServiceInput | planCreateOrConnectWithoutServiceInput[]
    createMany?: planCreateManyServiceInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type service_requestUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput> | service_requestCreateWithoutServiceInput[] | service_requestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutServiceInput | service_requestCreateOrConnectWithoutServiceInput[]
    createMany?: service_requestCreateManyServiceInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type case_studiesUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput> | case_studiesCreateWithoutServiceInput[] | case_studiesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutServiceInput | case_studiesCreateOrConnectWithoutServiceInput[]
    createMany?: case_studiesCreateManyServiceInputEnvelope
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
  }

  export type testimonialUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput> | testimonialCreateWithoutServiceInput[] | testimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutServiceInput | testimonialCreateOrConnectWithoutServiceInput[]
    createMany?: testimonialCreateManyServiceInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type planUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput> | planCreateWithoutServiceInput[] | planUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: planCreateOrConnectWithoutServiceInput | planCreateOrConnectWithoutServiceInput[]
    createMany?: planCreateManyServiceInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutServiceNestedInput = {
    create?: XOR<userCreateWithoutServiceInput, userUncheckedCreateWithoutServiceInput>
    connectOrCreate?: userCreateOrConnectWithoutServiceInput
    upsert?: userUpsertWithoutServiceInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutServiceInput, userUpdateWithoutServiceInput>, userUncheckedUpdateWithoutServiceInput>
  }

  export type service_requestUpdateManyWithoutServiceNestedInput = {
    create?: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput> | service_requestCreateWithoutServiceInput[] | service_requestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutServiceInput | service_requestCreateOrConnectWithoutServiceInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutServiceInput | service_requestUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: service_requestCreateManyServiceInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutServiceInput | service_requestUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutServiceInput | service_requestUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type case_studiesUpdateManyWithoutServiceNestedInput = {
    create?: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput> | case_studiesCreateWithoutServiceInput[] | case_studiesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutServiceInput | case_studiesCreateOrConnectWithoutServiceInput[]
    upsert?: case_studiesUpsertWithWhereUniqueWithoutServiceInput | case_studiesUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: case_studiesCreateManyServiceInputEnvelope
    set?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    disconnect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    delete?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    update?: case_studiesUpdateWithWhereUniqueWithoutServiceInput | case_studiesUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: case_studiesUpdateManyWithWhereWithoutServiceInput | case_studiesUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
  }

  export type testimonialUpdateManyWithoutServiceNestedInput = {
    create?: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput> | testimonialCreateWithoutServiceInput[] | testimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutServiceInput | testimonialCreateOrConnectWithoutServiceInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutServiceInput | testimonialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: testimonialCreateManyServiceInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutServiceInput | testimonialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutServiceInput | testimonialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type planUpdateManyWithoutServiceNestedInput = {
    create?: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput> | planCreateWithoutServiceInput[] | planUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: planCreateOrConnectWithoutServiceInput | planCreateOrConnectWithoutServiceInput[]
    upsert?: planUpsertWithWhereUniqueWithoutServiceInput | planUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: planCreateManyServiceInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutServiceInput | planUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: planUpdateManyWithWhereWithoutServiceInput | planUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type service_requestUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput> | service_requestCreateWithoutServiceInput[] | service_requestUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutServiceInput | service_requestCreateOrConnectWithoutServiceInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutServiceInput | service_requestUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: service_requestCreateManyServiceInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutServiceInput | service_requestUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutServiceInput | service_requestUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type case_studiesUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput> | case_studiesCreateWithoutServiceInput[] | case_studiesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: case_studiesCreateOrConnectWithoutServiceInput | case_studiesCreateOrConnectWithoutServiceInput[]
    upsert?: case_studiesUpsertWithWhereUniqueWithoutServiceInput | case_studiesUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: case_studiesCreateManyServiceInputEnvelope
    set?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    disconnect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    delete?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    connect?: case_studiesWhereUniqueInput | case_studiesWhereUniqueInput[]
    update?: case_studiesUpdateWithWhereUniqueWithoutServiceInput | case_studiesUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: case_studiesUpdateManyWithWhereWithoutServiceInput | case_studiesUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
  }

  export type testimonialUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput> | testimonialCreateWithoutServiceInput[] | testimonialUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutServiceInput | testimonialCreateOrConnectWithoutServiceInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutServiceInput | testimonialUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: testimonialCreateManyServiceInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutServiceInput | testimonialUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutServiceInput | testimonialUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type planUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput> | planCreateWithoutServiceInput[] | planUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: planCreateOrConnectWithoutServiceInput | planCreateOrConnectWithoutServiceInput[]
    upsert?: planUpsertWithWhereUniqueWithoutServiceInput | planUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: planCreateManyServiceInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutServiceInput | planUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: planUpdateManyWithWhereWithoutServiceInput | planUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type planCreateNestedOneWithoutService_requestInput = {
    create?: XOR<planCreateWithoutService_requestInput, planUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: planCreateOrConnectWithoutService_requestInput
    connect?: planWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutService_requestInput = {
    create?: XOR<serviceCreateWithoutService_requestInput, serviceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: serviceCreateOrConnectWithoutService_requestInput
    connect?: serviceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutService_requestInput = {
    create?: XOR<userCreateWithoutService_requestInput, userUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: userCreateOrConnectWithoutService_requestInput
    connect?: userWhereUniqueInput
  }

  export type planUpdateOneRequiredWithoutService_requestNestedInput = {
    create?: XOR<planCreateWithoutService_requestInput, planUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: planCreateOrConnectWithoutService_requestInput
    upsert?: planUpsertWithoutService_requestInput
    connect?: planWhereUniqueInput
    update?: XOR<XOR<planUpdateToOneWithWhereWithoutService_requestInput, planUpdateWithoutService_requestInput>, planUncheckedUpdateWithoutService_requestInput>
  }

  export type serviceUpdateOneRequiredWithoutService_requestNestedInput = {
    create?: XOR<serviceCreateWithoutService_requestInput, serviceUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: serviceCreateOrConnectWithoutService_requestInput
    upsert?: serviceUpsertWithoutService_requestInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutService_requestInput, serviceUpdateWithoutService_requestInput>, serviceUncheckedUpdateWithoutService_requestInput>
  }

  export type userUpdateOneRequiredWithoutService_requestNestedInput = {
    create?: XOR<userCreateWithoutService_requestInput, userUncheckedCreateWithoutService_requestInput>
    connectOrCreate?: userCreateOrConnectWithoutService_requestInput
    upsert?: userUpsertWithoutService_requestInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutService_requestInput, userUpdateWithoutService_requestInput>, userUncheckedUpdateWithoutService_requestInput>
  }

  export type organisationCreateNestedOneWithoutCase_studiesInput = {
    create?: XOR<organisationCreateWithoutCase_studiesInput, organisationUncheckedCreateWithoutCase_studiesInput>
    connectOrCreate?: organisationCreateOrConnectWithoutCase_studiesInput
    connect?: organisationWhereUniqueInput
  }

  export type serviceCreateNestedOneWithoutCase_studiesInput = {
    create?: XOR<serviceCreateWithoutCase_studiesInput, serviceUncheckedCreateWithoutCase_studiesInput>
    connectOrCreate?: serviceCreateOrConnectWithoutCase_studiesInput
    connect?: serviceWhereUniqueInput
  }

  export type organisationUpdateOneRequiredWithoutCase_studiesNestedInput = {
    create?: XOR<organisationCreateWithoutCase_studiesInput, organisationUncheckedCreateWithoutCase_studiesInput>
    connectOrCreate?: organisationCreateOrConnectWithoutCase_studiesInput
    upsert?: organisationUpsertWithoutCase_studiesInput
    connect?: organisationWhereUniqueInput
    update?: XOR<XOR<organisationUpdateToOneWithWhereWithoutCase_studiesInput, organisationUpdateWithoutCase_studiesInput>, organisationUncheckedUpdateWithoutCase_studiesInput>
  }

  export type serviceUpdateOneRequiredWithoutCase_studiesNestedInput = {
    create?: XOR<serviceCreateWithoutCase_studiesInput, serviceUncheckedCreateWithoutCase_studiesInput>
    connectOrCreate?: serviceCreateOrConnectWithoutCase_studiesInput
    upsert?: serviceUpsertWithoutCase_studiesInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutCase_studiesInput, serviceUpdateWithoutCase_studiesInput>, serviceUncheckedUpdateWithoutCase_studiesInput>
  }

  export type serviceCreateNestedOneWithoutTestimonialInput = {
    create?: XOR<serviceCreateWithoutTestimonialInput, serviceUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: serviceCreateOrConnectWithoutTestimonialInput
    connect?: serviceWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTestimonialInput = {
    create?: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: userCreateOrConnectWithoutTestimonialInput
    connect?: userWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type serviceUpdateOneRequiredWithoutTestimonialNestedInput = {
    create?: XOR<serviceCreateWithoutTestimonialInput, serviceUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: serviceCreateOrConnectWithoutTestimonialInput
    upsert?: serviceUpsertWithoutTestimonialInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutTestimonialInput, serviceUpdateWithoutTestimonialInput>, serviceUncheckedUpdateWithoutTestimonialInput>
  }

  export type userUpdateOneRequiredWithoutTestimonialNestedInput = {
    create?: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: userCreateOrConnectWithoutTestimonialInput
    upsert?: userUpsertWithoutTestimonialInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTestimonialInput, userUpdateWithoutTestimonialInput>, userUncheckedUpdateWithoutTestimonialInput>
  }

  export type organisationCreateNestedOneWithoutContactInput = {
    create?: XOR<organisationCreateWithoutContactInput, organisationUncheckedCreateWithoutContactInput>
    connectOrCreate?: organisationCreateOrConnectWithoutContactInput
    connect?: organisationWhereUniqueInput
  }

  export type organisationUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<organisationCreateWithoutContactInput, organisationUncheckedCreateWithoutContactInput>
    connectOrCreate?: organisationCreateOrConnectWithoutContactInput
    upsert?: organisationUpsertWithoutContactInput
    connect?: organisationWhereUniqueInput
    update?: XOR<XOR<organisationUpdateToOneWithWhereWithoutContactInput, organisationUpdateWithoutContactInput>, organisationUncheckedUpdateWithoutContactInput>
  }

  export type userCreateNestedOneWithoutOtpInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
    connectOrCreate?: userCreateOrConnectWithoutOtpInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutOtpNestedInput = {
    create?: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
    connectOrCreate?: userCreateOrConnectWithoutOtpInput
    upsert?: userUpsertWithoutOtpInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOtpInput, userUpdateWithoutOtpInput>, userUncheckedUpdateWithoutOtpInput>
  }

  export type userCreateNestedOneWithoutPassword_tokenInput = {
    create?: XOR<userCreateWithoutPassword_tokenInput, userUncheckedCreateWithoutPassword_tokenInput>
    connectOrCreate?: userCreateOrConnectWithoutPassword_tokenInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutPassword_tokenNestedInput = {
    create?: XOR<userCreateWithoutPassword_tokenInput, userUncheckedCreateWithoutPassword_tokenInput>
    connectOrCreate?: userCreateOrConnectWithoutPassword_tokenInput
    upsert?: userUpsertWithoutPassword_tokenInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPassword_tokenInput, userUpdateWithoutPassword_tokenInput>, userUncheckedUpdateWithoutPassword_tokenInput>
  }

  export type userCreateNestedOneWithoutNotificationInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    upsert?: userUpsertWithoutNotificationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationInput, userUpdateWithoutNotificationInput>, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userCreateNestedOneWithoutPrivacy_settingsInput = {
    create?: XOR<userCreateWithoutPrivacy_settingsInput, userUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutPrivacy_settingsInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneRequiredWithoutPrivacy_settingsNestedInput = {
    create?: XOR<userCreateWithoutPrivacy_settingsInput, userUncheckedCreateWithoutPrivacy_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutPrivacy_settingsInput
    upsert?: userUpsertWithoutPrivacy_settingsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPrivacy_settingsInput, userUpdateWithoutPrivacy_settingsInput>, userUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type userCreateNestedOneWithoutNotification_settingsInput = {
    create?: XOR<userCreateWithoutNotification_settingsInput, userUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutNotification_settingsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutNotification_settingsNestedInput = {
    create?: XOR<userCreateWithoutNotification_settingsInput, userUncheckedCreateWithoutNotification_settingsInput>
    connectOrCreate?: userCreateOrConnectWithoutNotification_settingsInput
    upsert?: userUpsertWithoutNotification_settingsInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotification_settingsInput, userUpdateWithoutNotification_settingsInput>, userUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type userCreateNestedOneWithoutPlan_typeInput = {
    create?: XOR<userCreateWithoutPlan_typeInput, userUncheckedCreateWithoutPlan_typeInput>
    connectOrCreate?: userCreateOrConnectWithoutPlan_typeInput
    connect?: userWhereUniqueInput
  }

  export type planCreateNestedManyWithoutPlan_typeInput = {
    create?: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput> | planCreateWithoutPlan_typeInput[] | planUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: planCreateOrConnectWithoutPlan_typeInput | planCreateOrConnectWithoutPlan_typeInput[]
    createMany?: planCreateManyPlan_typeInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type planUncheckedCreateNestedManyWithoutPlan_typeInput = {
    create?: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput> | planCreateWithoutPlan_typeInput[] | planUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: planCreateOrConnectWithoutPlan_typeInput | planCreateOrConnectWithoutPlan_typeInput[]
    createMany?: planCreateManyPlan_typeInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutPlan_typeNestedInput = {
    create?: XOR<userCreateWithoutPlan_typeInput, userUncheckedCreateWithoutPlan_typeInput>
    connectOrCreate?: userCreateOrConnectWithoutPlan_typeInput
    upsert?: userUpsertWithoutPlan_typeInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPlan_typeInput, userUpdateWithoutPlan_typeInput>, userUncheckedUpdateWithoutPlan_typeInput>
  }

  export type planUpdateManyWithoutPlan_typeNestedInput = {
    create?: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput> | planCreateWithoutPlan_typeInput[] | planUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: planCreateOrConnectWithoutPlan_typeInput | planCreateOrConnectWithoutPlan_typeInput[]
    upsert?: planUpsertWithWhereUniqueWithoutPlan_typeInput | planUpsertWithWhereUniqueWithoutPlan_typeInput[]
    createMany?: planCreateManyPlan_typeInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutPlan_typeInput | planUpdateWithWhereUniqueWithoutPlan_typeInput[]
    updateMany?: planUpdateManyWithWhereWithoutPlan_typeInput | planUpdateManyWithWhereWithoutPlan_typeInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type planUncheckedUpdateManyWithoutPlan_typeNestedInput = {
    create?: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput> | planCreateWithoutPlan_typeInput[] | planUncheckedCreateWithoutPlan_typeInput[]
    connectOrCreate?: planCreateOrConnectWithoutPlan_typeInput | planCreateOrConnectWithoutPlan_typeInput[]
    upsert?: planUpsertWithWhereUniqueWithoutPlan_typeInput | planUpsertWithWhereUniqueWithoutPlan_typeInput[]
    createMany?: planCreateManyPlan_typeInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutPlan_typeInput | planUpdateWithWhereUniqueWithoutPlan_typeInput[]
    updateMany?: planUpdateManyWithWhereWithoutPlan_typeInput | planUpdateManyWithWhereWithoutPlan_typeInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type planCreateNestedManyWithoutBilling_cycleInput = {
    create?: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput> | planCreateWithoutBilling_cycleInput[] | planUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: planCreateOrConnectWithoutBilling_cycleInput | planCreateOrConnectWithoutBilling_cycleInput[]
    createMany?: planCreateManyBilling_cycleInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type planUncheckedCreateNestedManyWithoutBilling_cycleInput = {
    create?: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput> | planCreateWithoutBilling_cycleInput[] | planUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: planCreateOrConnectWithoutBilling_cycleInput | planCreateOrConnectWithoutBilling_cycleInput[]
    createMany?: planCreateManyBilling_cycleInputEnvelope
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type planUpdateManyWithoutBilling_cycleNestedInput = {
    create?: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput> | planCreateWithoutBilling_cycleInput[] | planUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: planCreateOrConnectWithoutBilling_cycleInput | planCreateOrConnectWithoutBilling_cycleInput[]
    upsert?: planUpsertWithWhereUniqueWithoutBilling_cycleInput | planUpsertWithWhereUniqueWithoutBilling_cycleInput[]
    createMany?: planCreateManyBilling_cycleInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutBilling_cycleInput | planUpdateWithWhereUniqueWithoutBilling_cycleInput[]
    updateMany?: planUpdateManyWithWhereWithoutBilling_cycleInput | planUpdateManyWithWhereWithoutBilling_cycleInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type planUncheckedUpdateManyWithoutBilling_cycleNestedInput = {
    create?: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput> | planCreateWithoutBilling_cycleInput[] | planUncheckedCreateWithoutBilling_cycleInput[]
    connectOrCreate?: planCreateOrConnectWithoutBilling_cycleInput | planCreateOrConnectWithoutBilling_cycleInput[]
    upsert?: planUpsertWithWhereUniqueWithoutBilling_cycleInput | planUpsertWithWhereUniqueWithoutBilling_cycleInput[]
    createMany?: planCreateManyBilling_cycleInputEnvelope
    set?: planWhereUniqueInput | planWhereUniqueInput[]
    disconnect?: planWhereUniqueInput | planWhereUniqueInput[]
    delete?: planWhereUniqueInput | planWhereUniqueInput[]
    connect?: planWhereUniqueInput | planWhereUniqueInput[]
    update?: planUpdateWithWhereUniqueWithoutBilling_cycleInput | planUpdateWithWhereUniqueWithoutBilling_cycleInput[]
    updateMany?: planUpdateManyWithWhereWithoutBilling_cycleInput | planUpdateManyWithWhereWithoutBilling_cycleInput[]
    deleteMany?: planScalarWhereInput | planScalarWhereInput[]
  }

  export type serviceCreateNestedOneWithoutPlanInput = {
    create?: XOR<serviceCreateWithoutPlanInput, serviceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: serviceCreateOrConnectWithoutPlanInput
    connect?: serviceWhereUniqueInput
  }

  export type plan_typeCreateNestedOneWithoutPlanInput = {
    create?: XOR<plan_typeCreateWithoutPlanInput, plan_typeUncheckedCreateWithoutPlanInput>
    connectOrCreate?: plan_typeCreateOrConnectWithoutPlanInput
    connect?: plan_typeWhereUniqueInput
  }

  export type billing_cycleCreateNestedOneWithoutPlanInput = {
    create?: XOR<billing_cycleCreateWithoutPlanInput, billing_cycleUncheckedCreateWithoutPlanInput>
    connectOrCreate?: billing_cycleCreateOrConnectWithoutPlanInput
    connect?: billing_cycleWhereUniqueInput
  }

  export type service_requestCreateNestedManyWithoutPlanInput = {
    create?: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput> | service_requestCreateWithoutPlanInput[] | service_requestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutPlanInput | service_requestCreateOrConnectWithoutPlanInput[]
    createMany?: service_requestCreateManyPlanInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type subscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type service_requestUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput> | service_requestCreateWithoutPlanInput[] | service_requestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutPlanInput | service_requestCreateOrConnectWithoutPlanInput[]
    createMany?: service_requestCreateManyPlanInputEnvelope
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
  }

  export type subscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
  }

  export type serviceUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<serviceCreateWithoutPlanInput, serviceUncheckedCreateWithoutPlanInput>
    connectOrCreate?: serviceCreateOrConnectWithoutPlanInput
    upsert?: serviceUpsertWithoutPlanInput
    connect?: serviceWhereUniqueInput
    update?: XOR<XOR<serviceUpdateToOneWithWhereWithoutPlanInput, serviceUpdateWithoutPlanInput>, serviceUncheckedUpdateWithoutPlanInput>
  }

  export type plan_typeUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<plan_typeCreateWithoutPlanInput, plan_typeUncheckedCreateWithoutPlanInput>
    connectOrCreate?: plan_typeCreateOrConnectWithoutPlanInput
    upsert?: plan_typeUpsertWithoutPlanInput
    connect?: plan_typeWhereUniqueInput
    update?: XOR<XOR<plan_typeUpdateToOneWithWhereWithoutPlanInput, plan_typeUpdateWithoutPlanInput>, plan_typeUncheckedUpdateWithoutPlanInput>
  }

  export type billing_cycleUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<billing_cycleCreateWithoutPlanInput, billing_cycleUncheckedCreateWithoutPlanInput>
    connectOrCreate?: billing_cycleCreateOrConnectWithoutPlanInput
    upsert?: billing_cycleUpsertWithoutPlanInput
    connect?: billing_cycleWhereUniqueInput
    update?: XOR<XOR<billing_cycleUpdateToOneWithWhereWithoutPlanInput, billing_cycleUpdateWithoutPlanInput>, billing_cycleUncheckedUpdateWithoutPlanInput>
  }

  export type service_requestUpdateManyWithoutPlanNestedInput = {
    create?: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput> | service_requestCreateWithoutPlanInput[] | service_requestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutPlanInput | service_requestCreateOrConnectWithoutPlanInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutPlanInput | service_requestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: service_requestCreateManyPlanInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutPlanInput | service_requestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutPlanInput | service_requestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type subscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutPlanInput | subscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutPlanInput | subscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutPlanInput | subscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type service_requestUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput> | service_requestCreateWithoutPlanInput[] | service_requestUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: service_requestCreateOrConnectWithoutPlanInput | service_requestCreateOrConnectWithoutPlanInput[]
    upsert?: service_requestUpsertWithWhereUniqueWithoutPlanInput | service_requestUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: service_requestCreateManyPlanInputEnvelope
    set?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    disconnect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    delete?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    connect?: service_requestWhereUniqueInput | service_requestWhereUniqueInput[]
    update?: service_requestUpdateWithWhereUniqueWithoutPlanInput | service_requestUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: service_requestUpdateManyWithWhereWithoutPlanInput | service_requestUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
  }

  export type subscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput> | subscriptionCreateWithoutPlanInput[] | subscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: subscriptionCreateOrConnectWithoutPlanInput | subscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: subscriptionUpsertWithWhereUniqueWithoutPlanInput | subscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: subscriptionCreateManyPlanInputEnvelope
    set?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    disconnect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    delete?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    connect?: subscriptionWhereUniqueInput | subscriptionWhereUniqueInput[]
    update?: subscriptionUpdateWithWhereUniqueWithoutPlanInput | subscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: subscriptionUpdateManyWithWhereWithoutPlanInput | subscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
  }

  export type planCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<planCreateWithoutSubscriptionInput, planUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: planCreateOrConnectWithoutSubscriptionInput
    connect?: planWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionInput
    connect?: userWhereUniqueInput
  }

  export type planUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<planCreateWithoutSubscriptionInput, planUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: planCreateOrConnectWithoutSubscriptionInput
    upsert?: planUpsertWithoutSubscriptionInput
    connect?: planWhereUniqueInput
    update?: XOR<XOR<planUpdateToOneWithWhereWithoutSubscriptionInput, planUpdateWithoutSubscriptionInput>, planUncheckedUpdateWithoutSubscriptionInput>
  }

  export type userUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: userCreateOrConnectWithoutSubscriptionInput
    upsert?: userUpsertWithoutSubscriptionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSubscriptionInput, userUpdateWithoutSubscriptionInput>, userUncheckedUpdateWithoutSubscriptionInput>
  }

  export type userCreateNestedOneWithoutCreated_roleInput = {
    create?: XOR<userCreateWithoutCreated_roleInput, userUncheckedCreateWithoutCreated_roleInput>
    connectOrCreate?: userCreateOrConnectWithoutCreated_roleInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateOneWithoutCreated_roleNestedInput = {
    create?: XOR<userCreateWithoutCreated_roleInput, userUncheckedCreateWithoutCreated_roleInput>
    connectOrCreate?: userCreateOrConnectWithoutCreated_roleInput
    upsert?: userUpsertWithoutCreated_roleInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCreated_roleInput, userUpdateWithoutCreated_roleInput>, userUncheckedUpdateWithoutCreated_roleInput>
  }

  export type userUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput> | userCreateWithoutRoleInput[] | userUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userCreateOrConnectWithoutRoleInput | userCreateOrConnectWithoutRoleInput[]
    upsert?: userUpsertWithWhereUniqueWithoutRoleInput | userUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userCreateManyRoleInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutRoleInput | userUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userUpdateManyWithWhereWithoutRoleInput | userUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type notificationCreateWithoutUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateManyUserInputEnvelope = {
    data: notificationCreateManyUserInput | notificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notification_settingsCreateWithoutUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type notification_settingsUncheckedCreateWithoutUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type notification_settingsCreateOrConnectWithoutUserInput = {
    where: notification_settingsWhereUniqueInput
    create: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput>
  }

  export type notification_settingsCreateManyUserInputEnvelope = {
    data: notification_settingsCreateManyUserInput | notification_settingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type organisationCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    case_studies?: case_studiesCreateNestedManyWithoutOrganisationInput
    contact?: contactCreateNestedManyWithoutOrganisationInput
  }

  export type organisationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutOrganisationInput
    contact?: contactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type organisationCreateOrConnectWithoutUserInput = {
    where: organisationWhereUniqueInput
    create: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput>
  }

  export type organisationCreateManyUserInputEnvelope = {
    data: organisationCreateManyUserInput | organisationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type otpCreateWithoutUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type otpUncheckedCreateWithoutUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type otpCreateOrConnectWithoutUserInput = {
    where: otpWhereUniqueInput
    create: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput>
  }

  export type otpCreateManyUserInputEnvelope = {
    data: otpCreateManyUserInput | otpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type password_tokenCreateWithoutUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type password_tokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type password_tokenCreateOrConnectWithoutUserInput = {
    where: password_tokenWhereUniqueInput
    create: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput>
  }

  export type password_tokenCreateManyUserInputEnvelope = {
    data: password_tokenCreateManyUserInput | password_tokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type privacy_settingsCreateWithoutUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type privacy_settingsUncheckedCreateWithoutUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type privacy_settingsCreateOrConnectWithoutUserInput = {
    where: privacy_settingsWhereUniqueInput
    create: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput>
  }

  export type privacy_settingsCreateManyUserInputEnvelope = {
    data: privacy_settingsCreateManyUserInput | privacy_settingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type roleCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    user?: userCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    user?: userUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutCreatorInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput>
  }

  export type roleCreateManyCreatorInputEnvelope = {
    data: roleCreateManyCreatorInput | roleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type serviceCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesCreateNestedManyWithoutServiceInput
    testimonial?: testimonialCreateNestedManyWithoutServiceInput
    plan?: planCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestUncheckedCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutServiceInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutServiceInput
    plan?: planUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutUserInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput>
  }

  export type serviceCreateManyUserInputEnvelope = {
    data: serviceCreateManyUserInput | serviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type service_requestCreateWithoutUserInput = {
    id?: string
    message: string
    requested_at?: Date | string
    status: string
    plan: planCreateNestedOneWithoutService_requestInput
    service: serviceCreateNestedOneWithoutService_requestInput
  }

  export type service_requestUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    service_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type service_requestCreateOrConnectWithoutUserInput = {
    where: service_requestWhereUniqueInput
    create: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput>
  }

  export type service_requestCreateManyUserInputEnvelope = {
    data: service_requestCreateManyUserInput | service_requestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionCreateWithoutUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan: planCreateNestedOneWithoutSubscriptionInput
  }

  export type subscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan_id: string
  }

  export type subscriptionCreateOrConnectWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    create: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput>
  }

  export type subscriptionCreateManyUserInputEnvelope = {
    data: subscriptionCreateManyUserInput | subscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type testimonialCreateWithoutUserInput = {
    id?: string
    message: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
    service: serviceCreateNestedOneWithoutTestimonialInput
  }

  export type testimonialUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    service_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type testimonialCreateOrConnectWithoutUserInput = {
    where: testimonialWhereUniqueInput
    create: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput>
  }

  export type testimonialCreateManyUserInputEnvelope = {
    data: testimonialCreateManyUserInput | testimonialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type plan_typeCreateWithoutUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    plan?: planCreateNestedManyWithoutPlan_typeInput
  }

  export type plan_typeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    plan?: planUncheckedCreateNestedManyWithoutPlan_typeInput
  }

  export type plan_typeCreateOrConnectWithoutUserInput = {
    where: plan_typeWhereUniqueInput
    create: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput>
  }

  export type plan_typeCreateManyUserInputEnvelope = {
    data: plan_typeCreateManyUserInput | plan_typeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type roleCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    creator?: userCreateNestedOneWithoutCreated_roleInput
  }

  export type roleUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    created_by?: string | null
    deleted_at?: Date | string | null
  }

  export type roleCreateOrConnectWithoutUserInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    activity?: StringFilter<"notification"> | string
    completed_at?: DateTimeNullableFilter<"notification"> | Date | string | null
    user_id?: StringFilter<"notification"> | string
  }

  export type notification_settingsUpsertWithWhereUniqueWithoutUserInput = {
    where: notification_settingsWhereUniqueInput
    update: XOR<notification_settingsUpdateWithoutUserInput, notification_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<notification_settingsCreateWithoutUserInput, notification_settingsUncheckedCreateWithoutUserInput>
  }

  export type notification_settingsUpdateWithWhereUniqueWithoutUserInput = {
    where: notification_settingsWhereUniqueInput
    data: XOR<notification_settingsUpdateWithoutUserInput, notification_settingsUncheckedUpdateWithoutUserInput>
  }

  export type notification_settingsUpdateManyWithWhereWithoutUserInput = {
    where: notification_settingsScalarWhereInput
    data: XOR<notification_settingsUpdateManyMutationInput, notification_settingsUncheckedUpdateManyWithoutUserInput>
  }

  export type notification_settingsScalarWhereInput = {
    AND?: notification_settingsScalarWhereInput | notification_settingsScalarWhereInput[]
    OR?: notification_settingsScalarWhereInput[]
    NOT?: notification_settingsScalarWhereInput | notification_settingsScalarWhereInput[]
    id?: StringFilter<"notification_settings"> | string
    alerts?: BoolFilter<"notification_settings"> | boolean
    messages?: BoolFilter<"notification_settings"> | boolean
    updates?: BoolFilter<"notification_settings"> | boolean
    billing_alerts?: BoolFilter<"notification_settings"> | boolean
    email?: BoolFilter<"notification_settings"> | boolean
    in_app?: BoolFilter<"notification_settings"> | boolean
    user_id?: StringFilter<"notification_settings"> | string
  }

  export type organisationUpsertWithWhereUniqueWithoutUserInput = {
    where: organisationWhereUniqueInput
    update: XOR<organisationUpdateWithoutUserInput, organisationUncheckedUpdateWithoutUserInput>
    create: XOR<organisationCreateWithoutUserInput, organisationUncheckedCreateWithoutUserInput>
  }

  export type organisationUpdateWithWhereUniqueWithoutUserInput = {
    where: organisationWhereUniqueInput
    data: XOR<organisationUpdateWithoutUserInput, organisationUncheckedUpdateWithoutUserInput>
  }

  export type organisationUpdateManyWithWhereWithoutUserInput = {
    where: organisationScalarWhereInput
    data: XOR<organisationUpdateManyMutationInput, organisationUncheckedUpdateManyWithoutUserInput>
  }

  export type organisationScalarWhereInput = {
    AND?: organisationScalarWhereInput | organisationScalarWhereInput[]
    OR?: organisationScalarWhereInput[]
    NOT?: organisationScalarWhereInput | organisationScalarWhereInput[]
    id?: StringFilter<"organisation"> | string
    name?: StringFilter<"organisation"> | string
    email?: StringFilter<"organisation"> | string
    address?: StringFilter<"organisation"> | string
    country?: StringFilter<"organisation"> | string
    industry?: StringFilter<"organisation"> | string
    logo_url?: StringFilter<"organisation"> | string
    rc_number?: StringFilter<"organisation"> | string
    staff_size?: StringFilter<"organisation"> | string
    type?: StringFilter<"organisation"> | string
    created_at?: DateTimeFilter<"organisation"> | Date | string
    user_id?: StringFilter<"organisation"> | string
    deleted_at?: DateTimeNullableFilter<"organisation"> | Date | string | null
  }

  export type otpUpsertWithWhereUniqueWithoutUserInput = {
    where: otpWhereUniqueInput
    update: XOR<otpUpdateWithoutUserInput, otpUncheckedUpdateWithoutUserInput>
    create: XOR<otpCreateWithoutUserInput, otpUncheckedCreateWithoutUserInput>
  }

  export type otpUpdateWithWhereUniqueWithoutUserInput = {
    where: otpWhereUniqueInput
    data: XOR<otpUpdateWithoutUserInput, otpUncheckedUpdateWithoutUserInput>
  }

  export type otpUpdateManyWithWhereWithoutUserInput = {
    where: otpScalarWhereInput
    data: XOR<otpUpdateManyMutationInput, otpUncheckedUpdateManyWithoutUserInput>
  }

  export type otpScalarWhereInput = {
    AND?: otpScalarWhereInput | otpScalarWhereInput[]
    OR?: otpScalarWhereInput[]
    NOT?: otpScalarWhereInput | otpScalarWhereInput[]
    id?: StringFilter<"otp"> | string
    otp?: StringFilter<"otp"> | string
    expires_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    created_at?: DateTimeNullableFilter<"otp"> | Date | string | null
    user_id?: StringFilter<"otp"> | string
  }

  export type password_tokenUpsertWithWhereUniqueWithoutUserInput = {
    where: password_tokenWhereUniqueInput
    update: XOR<password_tokenUpdateWithoutUserInput, password_tokenUncheckedUpdateWithoutUserInput>
    create: XOR<password_tokenCreateWithoutUserInput, password_tokenUncheckedCreateWithoutUserInput>
  }

  export type password_tokenUpdateWithWhereUniqueWithoutUserInput = {
    where: password_tokenWhereUniqueInput
    data: XOR<password_tokenUpdateWithoutUserInput, password_tokenUncheckedUpdateWithoutUserInput>
  }

  export type password_tokenUpdateManyWithWhereWithoutUserInput = {
    where: password_tokenScalarWhereInput
    data: XOR<password_tokenUpdateManyMutationInput, password_tokenUncheckedUpdateManyWithoutUserInput>
  }

  export type password_tokenScalarWhereInput = {
    AND?: password_tokenScalarWhereInput | password_tokenScalarWhereInput[]
    OR?: password_tokenScalarWhereInput[]
    NOT?: password_tokenScalarWhereInput | password_tokenScalarWhereInput[]
    id?: StringFilter<"password_token"> | string
    token?: StringFilter<"password_token"> | string
    created_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"password_token"> | Date | string | null
    user_id?: StringFilter<"password_token"> | string
  }

  export type privacy_settingsUpsertWithWhereUniqueWithoutUserInput = {
    where: privacy_settingsWhereUniqueInput
    update: XOR<privacy_settingsUpdateWithoutUserInput, privacy_settingsUncheckedUpdateWithoutUserInput>
    create: XOR<privacy_settingsCreateWithoutUserInput, privacy_settingsUncheckedCreateWithoutUserInput>
  }

  export type privacy_settingsUpdateWithWhereUniqueWithoutUserInput = {
    where: privacy_settingsWhereUniqueInput
    data: XOR<privacy_settingsUpdateWithoutUserInput, privacy_settingsUncheckedUpdateWithoutUserInput>
  }

  export type privacy_settingsUpdateManyWithWhereWithoutUserInput = {
    where: privacy_settingsScalarWhereInput
    data: XOR<privacy_settingsUpdateManyMutationInput, privacy_settingsUncheckedUpdateManyWithoutUserInput>
  }

  export type privacy_settingsScalarWhereInput = {
    AND?: privacy_settingsScalarWhereInput | privacy_settingsScalarWhereInput[]
    OR?: privacy_settingsScalarWhereInput[]
    NOT?: privacy_settingsScalarWhereInput | privacy_settingsScalarWhereInput[]
    id?: StringFilter<"privacy_settings"> | string
    ads?: BoolFilter<"privacy_settings"> | boolean
    data_sharing?: BoolFilter<"privacy_settings"> | boolean
    marketing_status?: BoolFilter<"privacy_settings"> | boolean
    activity_status?: BoolFilter<"privacy_settings"> | boolean
    user_id?: StringFilter<"privacy_settings"> | string
  }

  export type roleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: roleWhereUniqueInput
    update: XOR<roleUpdateWithoutCreatorInput, roleUncheckedUpdateWithoutCreatorInput>
    create: XOR<roleCreateWithoutCreatorInput, roleUncheckedCreateWithoutCreatorInput>
  }

  export type roleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: roleWhereUniqueInput
    data: XOR<roleUpdateWithoutCreatorInput, roleUncheckedUpdateWithoutCreatorInput>
  }

  export type roleUpdateManyWithWhereWithoutCreatorInput = {
    where: roleScalarWhereInput
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type roleScalarWhereInput = {
    AND?: roleScalarWhereInput | roleScalarWhereInput[]
    OR?: roleScalarWhereInput[]
    NOT?: roleScalarWhereInput | roleScalarWhereInput[]
    id?: StringFilter<"role"> | string
    title?: StringFilter<"role"> | string
    description?: StringNullableFilter<"role"> | string | null
    created_at?: DateTimeFilter<"role"> | Date | string
    created_by?: StringNullableFilter<"role"> | string | null
    deleted_at?: DateTimeNullableFilter<"role"> | Date | string | null
  }

  export type serviceUpsertWithWhereUniqueWithoutUserInput = {
    where: serviceWhereUniqueInput
    update: XOR<serviceUpdateWithoutUserInput, serviceUncheckedUpdateWithoutUserInput>
    create: XOR<serviceCreateWithoutUserInput, serviceUncheckedCreateWithoutUserInput>
  }

  export type serviceUpdateWithWhereUniqueWithoutUserInput = {
    where: serviceWhereUniqueInput
    data: XOR<serviceUpdateWithoutUserInput, serviceUncheckedUpdateWithoutUserInput>
  }

  export type serviceUpdateManyWithWhereWithoutUserInput = {
    where: serviceScalarWhereInput
    data: XOR<serviceUpdateManyMutationInput, serviceUncheckedUpdateManyWithoutUserInput>
  }

  export type serviceScalarWhereInput = {
    AND?: serviceScalarWhereInput | serviceScalarWhereInput[]
    OR?: serviceScalarWhereInput[]
    NOT?: serviceScalarWhereInput | serviceScalarWhereInput[]
    id?: StringFilter<"service"> | string
    title?: StringFilter<"service"> | string
    description?: StringFilter<"service"> | string
    subtitle?: StringFilter<"service"> | string
    created_at?: DateTimeNullableFilter<"service"> | Date | string | null
    admin_id?: StringFilter<"service"> | string
    banner_url?: StringFilter<"service"> | string
    deleted_at?: DateTimeNullableFilter<"service"> | Date | string | null
  }

  export type service_requestUpsertWithWhereUniqueWithoutUserInput = {
    where: service_requestWhereUniqueInput
    update: XOR<service_requestUpdateWithoutUserInput, service_requestUncheckedUpdateWithoutUserInput>
    create: XOR<service_requestCreateWithoutUserInput, service_requestUncheckedCreateWithoutUserInput>
  }

  export type service_requestUpdateWithWhereUniqueWithoutUserInput = {
    where: service_requestWhereUniqueInput
    data: XOR<service_requestUpdateWithoutUserInput, service_requestUncheckedUpdateWithoutUserInput>
  }

  export type service_requestUpdateManyWithWhereWithoutUserInput = {
    where: service_requestScalarWhereInput
    data: XOR<service_requestUpdateManyMutationInput, service_requestUncheckedUpdateManyWithoutUserInput>
  }

  export type service_requestScalarWhereInput = {
    AND?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
    OR?: service_requestScalarWhereInput[]
    NOT?: service_requestScalarWhereInput | service_requestScalarWhereInput[]
    id?: StringFilter<"service_request"> | string
    message?: StringFilter<"service_request"> | string
    service_id?: StringFilter<"service_request"> | string
    user_id?: StringFilter<"service_request"> | string
    requested_at?: DateTimeFilter<"service_request"> | Date | string
    status?: StringFilter<"service_request"> | string
    plan_id?: StringFilter<"service_request"> | string
  }

  export type subscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    update: XOR<subscriptionUpdateWithoutUserInput, subscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<subscriptionCreateWithoutUserInput, subscriptionUncheckedCreateWithoutUserInput>
  }

  export type subscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: subscriptionWhereUniqueInput
    data: XOR<subscriptionUpdateWithoutUserInput, subscriptionUncheckedUpdateWithoutUserInput>
  }

  export type subscriptionUpdateManyWithWhereWithoutUserInput = {
    where: subscriptionScalarWhereInput
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type subscriptionScalarWhereInput = {
    AND?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    OR?: subscriptionScalarWhereInput[]
    NOT?: subscriptionScalarWhereInput | subscriptionScalarWhereInput[]
    id?: StringFilter<"subscription"> | string
    start_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    end_date?: DateTimeNullableFilter<"subscription"> | Date | string | null
    status?: StringFilter<"subscription"> | string
    user_id?: StringFilter<"subscription"> | string
    plan_id?: StringFilter<"subscription"> | string
  }

  export type testimonialUpsertWithWhereUniqueWithoutUserInput = {
    where: testimonialWhereUniqueInput
    update: XOR<testimonialUpdateWithoutUserInput, testimonialUncheckedUpdateWithoutUserInput>
    create: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput>
  }

  export type testimonialUpdateWithWhereUniqueWithoutUserInput = {
    where: testimonialWhereUniqueInput
    data: XOR<testimonialUpdateWithoutUserInput, testimonialUncheckedUpdateWithoutUserInput>
  }

  export type testimonialUpdateManyWithWhereWithoutUserInput = {
    where: testimonialScalarWhereInput
    data: XOR<testimonialUpdateManyMutationInput, testimonialUncheckedUpdateManyWithoutUserInput>
  }

  export type testimonialScalarWhereInput = {
    AND?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
    OR?: testimonialScalarWhereInput[]
    NOT?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
    id?: StringFilter<"testimonial"> | string
    message?: StringFilter<"testimonial"> | string
    user_id?: StringFilter<"testimonial"> | string
    service_id?: StringFilter<"testimonial"> | string
    stars?: DecimalFilter<"testimonial"> | Decimal | DecimalJsLike | number | string
    user_title?: StringFilter<"testimonial"> | string
    deleted_at?: DateTimeNullableFilter<"testimonial"> | Date | string | null
  }

  export type plan_typeUpsertWithWhereUniqueWithoutUserInput = {
    where: plan_typeWhereUniqueInput
    update: XOR<plan_typeUpdateWithoutUserInput, plan_typeUncheckedUpdateWithoutUserInput>
    create: XOR<plan_typeCreateWithoutUserInput, plan_typeUncheckedCreateWithoutUserInput>
  }

  export type plan_typeUpdateWithWhereUniqueWithoutUserInput = {
    where: plan_typeWhereUniqueInput
    data: XOR<plan_typeUpdateWithoutUserInput, plan_typeUncheckedUpdateWithoutUserInput>
  }

  export type plan_typeUpdateManyWithWhereWithoutUserInput = {
    where: plan_typeScalarWhereInput
    data: XOR<plan_typeUpdateManyMutationInput, plan_typeUncheckedUpdateManyWithoutUserInput>
  }

  export type plan_typeScalarWhereInput = {
    AND?: plan_typeScalarWhereInput | plan_typeScalarWhereInput[]
    OR?: plan_typeScalarWhereInput[]
    NOT?: plan_typeScalarWhereInput | plan_typeScalarWhereInput[]
    id?: StringFilter<"plan_type"> | string
    name?: StringFilter<"plan_type"> | string
    created_at?: DateTimeFilter<"plan_type"> | Date | string
    created_by?: StringFilter<"plan_type"> | string
    deleted_at?: DateTimeNullableFilter<"plan_type"> | Date | string | null
  }

  export type roleUpsertWithoutUserInput = {
    update: XOR<roleUpdateWithoutUserInput, roleUncheckedUpdateWithoutUserInput>
    create: XOR<roleCreateWithoutUserInput, roleUncheckedCreateWithoutUserInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserInput, roleUncheckedUpdateWithoutUserInput>
  }

  export type roleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: userUpdateOneWithoutCreated_roleNestedInput
  }

  export type roleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_studiesCreateWithoutOrganisationInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service: serviceCreateNestedOneWithoutCase_studiesInput
  }

  export type case_studiesUncheckedCreateWithoutOrganisationInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service_id: string
  }

  export type case_studiesCreateOrConnectWithoutOrganisationInput = {
    where: case_studiesWhereUniqueInput
    create: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput>
  }

  export type case_studiesCreateManyOrganisationInputEnvelope = {
    data: case_studiesCreateManyOrganisationInput | case_studiesCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type contactCreateWithoutOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactUncheckedCreateWithoutOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type contactCreateOrConnectWithoutOrganisationInput = {
    where: contactWhereUniqueInput
    create: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput>
  }

  export type contactCreateManyOrganisationInputEnvelope = {
    data: contactCreateManyOrganisationInput | contactCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutOrganisationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutOrganisationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOrganisationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOrganisationInput, userUncheckedCreateWithoutOrganisationInput>
  }

  export type case_studiesUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: case_studiesWhereUniqueInput
    update: XOR<case_studiesUpdateWithoutOrganisationInput, case_studiesUncheckedUpdateWithoutOrganisationInput>
    create: XOR<case_studiesCreateWithoutOrganisationInput, case_studiesUncheckedCreateWithoutOrganisationInput>
  }

  export type case_studiesUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: case_studiesWhereUniqueInput
    data: XOR<case_studiesUpdateWithoutOrganisationInput, case_studiesUncheckedUpdateWithoutOrganisationInput>
  }

  export type case_studiesUpdateManyWithWhereWithoutOrganisationInput = {
    where: case_studiesScalarWhereInput
    data: XOR<case_studiesUpdateManyMutationInput, case_studiesUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type case_studiesScalarWhereInput = {
    AND?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
    OR?: case_studiesScalarWhereInput[]
    NOT?: case_studiesScalarWhereInput | case_studiesScalarWhereInput[]
    id?: StringFilter<"case_studies"> | string
    banner?: StringFilter<"case_studies"> | string
    challenge?: StringFilter<"case_studies"> | string
    challenge_img?: StringFilter<"case_studies"> | string
    solution?: StringFilter<"case_studies"> | string
    solution_img?: StringFilter<"case_studies"> | string
    result?: StringFilter<"case_studies"> | string
    result_img?: StringFilter<"case_studies"> | string
    service_id?: StringFilter<"case_studies"> | string
    organisation_id?: StringFilter<"case_studies"> | string
  }

  export type contactUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: contactWhereUniqueInput
    update: XOR<contactUpdateWithoutOrganisationInput, contactUncheckedUpdateWithoutOrganisationInput>
    create: XOR<contactCreateWithoutOrganisationInput, contactUncheckedCreateWithoutOrganisationInput>
  }

  export type contactUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: contactWhereUniqueInput
    data: XOR<contactUpdateWithoutOrganisationInput, contactUncheckedUpdateWithoutOrganisationInput>
  }

  export type contactUpdateManyWithWhereWithoutOrganisationInput = {
    where: contactScalarWhereInput
    data: XOR<contactUpdateManyMutationInput, contactUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type contactScalarWhereInput = {
    AND?: contactScalarWhereInput | contactScalarWhereInput[]
    OR?: contactScalarWhereInput[]
    NOT?: contactScalarWhereInput | contactScalarWhereInput[]
    id?: StringFilter<"contact"> | string
    name?: StringFilter<"contact"> | string
    pfp_url?: StringFilter<"contact"> | string
    organisation_id?: StringFilter<"contact"> | string
    id_url?: JsonFilter<"contact">
    created_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"contact"> | Date | string | null
  }

  export type userUpsertWithoutOrganisationInput = {
    update: XOR<userUpdateWithoutOrganisationInput, userUncheckedUpdateWithoutOrganisationInput>
    create: XOR<userCreateWithoutOrganisationInput, userUncheckedCreateWithoutOrganisationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOrganisationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOrganisationInput, userUncheckedUpdateWithoutOrganisationInput>
  }

  export type userUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutServiceInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutServiceInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutServiceInput, userUncheckedCreateWithoutServiceInput>
  }

  export type service_requestCreateWithoutServiceInput = {
    id?: string
    message: string
    requested_at?: Date | string
    status: string
    plan: planCreateNestedOneWithoutService_requestInput
    user: userCreateNestedOneWithoutService_requestInput
  }

  export type service_requestUncheckedCreateWithoutServiceInput = {
    id?: string
    message: string
    user_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type service_requestCreateOrConnectWithoutServiceInput = {
    where: service_requestWhereUniqueInput
    create: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput>
  }

  export type service_requestCreateManyServiceInputEnvelope = {
    data: service_requestCreateManyServiceInput | service_requestCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type case_studiesCreateWithoutServiceInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    organisation: organisationCreateNestedOneWithoutCase_studiesInput
  }

  export type case_studiesUncheckedCreateWithoutServiceInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    organisation_id: string
  }

  export type case_studiesCreateOrConnectWithoutServiceInput = {
    where: case_studiesWhereUniqueInput
    create: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput>
  }

  export type case_studiesCreateManyServiceInputEnvelope = {
    data: case_studiesCreateManyServiceInput | case_studiesCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type testimonialCreateWithoutServiceInput = {
    id?: string
    message: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutTestimonialInput
  }

  export type testimonialUncheckedCreateWithoutServiceInput = {
    id?: string
    message: string
    user_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type testimonialCreateOrConnectWithoutServiceInput = {
    where: testimonialWhereUniqueInput
    create: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput>
  }

  export type testimonialCreateManyServiceInputEnvelope = {
    data: testimonialCreateManyServiceInput | testimonialCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type planCreateWithoutServiceInput = {
    id?: string
    price: number
    description: string
    plan_type: plan_typeCreateNestedOneWithoutPlanInput
    billing_cycle: billing_cycleCreateNestedOneWithoutPlanInput
    service_request?: service_requestCreateNestedManyWithoutPlanInput
    subscription?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutServiceInput = {
    id?: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
    service_request?: service_requestUncheckedCreateNestedManyWithoutPlanInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutServiceInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput>
  }

  export type planCreateManyServiceInputEnvelope = {
    data: planCreateManyServiceInput | planCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutServiceInput = {
    update: XOR<userUpdateWithoutServiceInput, userUncheckedUpdateWithoutServiceInput>
    create: XOR<userCreateWithoutServiceInput, userUncheckedCreateWithoutServiceInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutServiceInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutServiceInput, userUncheckedUpdateWithoutServiceInput>
  }

  export type userUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type service_requestUpsertWithWhereUniqueWithoutServiceInput = {
    where: service_requestWhereUniqueInput
    update: XOR<service_requestUpdateWithoutServiceInput, service_requestUncheckedUpdateWithoutServiceInput>
    create: XOR<service_requestCreateWithoutServiceInput, service_requestUncheckedCreateWithoutServiceInput>
  }

  export type service_requestUpdateWithWhereUniqueWithoutServiceInput = {
    where: service_requestWhereUniqueInput
    data: XOR<service_requestUpdateWithoutServiceInput, service_requestUncheckedUpdateWithoutServiceInput>
  }

  export type service_requestUpdateManyWithWhereWithoutServiceInput = {
    where: service_requestScalarWhereInput
    data: XOR<service_requestUpdateManyMutationInput, service_requestUncheckedUpdateManyWithoutServiceInput>
  }

  export type case_studiesUpsertWithWhereUniqueWithoutServiceInput = {
    where: case_studiesWhereUniqueInput
    update: XOR<case_studiesUpdateWithoutServiceInput, case_studiesUncheckedUpdateWithoutServiceInput>
    create: XOR<case_studiesCreateWithoutServiceInput, case_studiesUncheckedCreateWithoutServiceInput>
  }

  export type case_studiesUpdateWithWhereUniqueWithoutServiceInput = {
    where: case_studiesWhereUniqueInput
    data: XOR<case_studiesUpdateWithoutServiceInput, case_studiesUncheckedUpdateWithoutServiceInput>
  }

  export type case_studiesUpdateManyWithWhereWithoutServiceInput = {
    where: case_studiesScalarWhereInput
    data: XOR<case_studiesUpdateManyMutationInput, case_studiesUncheckedUpdateManyWithoutServiceInput>
  }

  export type testimonialUpsertWithWhereUniqueWithoutServiceInput = {
    where: testimonialWhereUniqueInput
    update: XOR<testimonialUpdateWithoutServiceInput, testimonialUncheckedUpdateWithoutServiceInput>
    create: XOR<testimonialCreateWithoutServiceInput, testimonialUncheckedCreateWithoutServiceInput>
  }

  export type testimonialUpdateWithWhereUniqueWithoutServiceInput = {
    where: testimonialWhereUniqueInput
    data: XOR<testimonialUpdateWithoutServiceInput, testimonialUncheckedUpdateWithoutServiceInput>
  }

  export type testimonialUpdateManyWithWhereWithoutServiceInput = {
    where: testimonialScalarWhereInput
    data: XOR<testimonialUpdateManyMutationInput, testimonialUncheckedUpdateManyWithoutServiceInput>
  }

  export type planUpsertWithWhereUniqueWithoutServiceInput = {
    where: planWhereUniqueInput
    update: XOR<planUpdateWithoutServiceInput, planUncheckedUpdateWithoutServiceInput>
    create: XOR<planCreateWithoutServiceInput, planUncheckedCreateWithoutServiceInput>
  }

  export type planUpdateWithWhereUniqueWithoutServiceInput = {
    where: planWhereUniqueInput
    data: XOR<planUpdateWithoutServiceInput, planUncheckedUpdateWithoutServiceInput>
  }

  export type planUpdateManyWithWhereWithoutServiceInput = {
    where: planScalarWhereInput
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyWithoutServiceInput>
  }

  export type planScalarWhereInput = {
    AND?: planScalarWhereInput | planScalarWhereInput[]
    OR?: planScalarWhereInput[]
    NOT?: planScalarWhereInput | planScalarWhereInput[]
    id?: StringFilter<"plan"> | string
    service_id?: StringFilter<"plan"> | string
    plan_type_id?: StringFilter<"plan"> | string
    billing_cycle_id?: StringFilter<"plan"> | string
    price?: IntFilter<"plan"> | number
    description?: StringFilter<"plan"> | string
  }

  export type planCreateWithoutService_requestInput = {
    id?: string
    price: number
    description: string
    service: serviceCreateNestedOneWithoutPlanInput
    plan_type: plan_typeCreateNestedOneWithoutPlanInput
    billing_cycle: billing_cycleCreateNestedOneWithoutPlanInput
    subscription?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutService_requestInput = {
    id?: string
    service_id: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
    subscription?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutService_requestInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutService_requestInput, planUncheckedCreateWithoutService_requestInput>
  }

  export type serviceCreateWithoutService_requestInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutServiceInput
    case_studies?: case_studiesCreateNestedManyWithoutServiceInput
    testimonial?: testimonialCreateNestedManyWithoutServiceInput
    plan?: planCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutService_requestInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutServiceInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutServiceInput
    plan?: planUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutService_requestInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutService_requestInput, serviceUncheckedCreateWithoutService_requestInput>
  }

  export type userCreateWithoutService_requestInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutService_requestInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutService_requestInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutService_requestInput, userUncheckedCreateWithoutService_requestInput>
  }

  export type planUpsertWithoutService_requestInput = {
    update: XOR<planUpdateWithoutService_requestInput, planUncheckedUpdateWithoutService_requestInput>
    create: XOR<planCreateWithoutService_requestInput, planUncheckedCreateWithoutService_requestInput>
    where?: planWhereInput
  }

  export type planUpdateToOneWithWhereWithoutService_requestInput = {
    where?: planWhereInput
    data: XOR<planUpdateWithoutService_requestInput, planUncheckedUpdateWithoutService_requestInput>
  }

  export type planUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutPlanNestedInput
    plan_type?: plan_typeUpdateOneRequiredWithoutPlanNestedInput
    billing_cycle?: billing_cycleUpdateOneRequiredWithoutPlanNestedInput
    subscription?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    subscription?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type serviceUpsertWithoutService_requestInput = {
    update: XOR<serviceUpdateWithoutService_requestInput, serviceUncheckedUpdateWithoutService_requestInput>
    create: XOR<serviceCreateWithoutService_requestInput, serviceUncheckedCreateWithoutService_requestInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutService_requestInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutService_requestInput, serviceUncheckedUpdateWithoutService_requestInput>
  }

  export type serviceUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceNestedInput
    case_studies?: case_studiesUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUpdateManyWithoutServiceNestedInput
    plan?: planUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUncheckedUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutServiceNestedInput
    plan?: planUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type userUpsertWithoutService_requestInput = {
    update: XOR<userUpdateWithoutService_requestInput, userUncheckedUpdateWithoutService_requestInput>
    create: XOR<userCreateWithoutService_requestInput, userUncheckedCreateWithoutService_requestInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutService_requestInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutService_requestInput, userUncheckedUpdateWithoutService_requestInput>
  }

  export type userUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutService_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type organisationCreateWithoutCase_studiesInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    contact?: contactCreateNestedManyWithoutOrganisationInput
    user: userCreateNestedOneWithoutOrganisationInput
  }

  export type organisationUncheckedCreateWithoutCase_studiesInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    contact?: contactUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type organisationCreateOrConnectWithoutCase_studiesInput = {
    where: organisationWhereUniqueInput
    create: XOR<organisationCreateWithoutCase_studiesInput, organisationUncheckedCreateWithoutCase_studiesInput>
  }

  export type serviceCreateWithoutCase_studiesInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutServiceInput
    service_request?: service_requestCreateNestedManyWithoutServiceInput
    testimonial?: testimonialCreateNestedManyWithoutServiceInput
    plan?: planCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutCase_studiesInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestUncheckedCreateNestedManyWithoutServiceInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutServiceInput
    plan?: planUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutCase_studiesInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutCase_studiesInput, serviceUncheckedCreateWithoutCase_studiesInput>
  }

  export type organisationUpsertWithoutCase_studiesInput = {
    update: XOR<organisationUpdateWithoutCase_studiesInput, organisationUncheckedUpdateWithoutCase_studiesInput>
    create: XOR<organisationCreateWithoutCase_studiesInput, organisationUncheckedCreateWithoutCase_studiesInput>
    where?: organisationWhereInput
  }

  export type organisationUpdateToOneWithWhereWithoutCase_studiesInput = {
    where?: organisationWhereInput
    data: XOR<organisationUpdateWithoutCase_studiesInput, organisationUncheckedUpdateWithoutCase_studiesInput>
  }

  export type organisationUpdateWithoutCase_studiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contact?: contactUpdateManyWithoutOrganisationNestedInput
    user?: userUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type organisationUncheckedUpdateWithoutCase_studiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contact?: contactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type serviceUpsertWithoutCase_studiesInput = {
    update: XOR<serviceUpdateWithoutCase_studiesInput, serviceUncheckedUpdateWithoutCase_studiesInput>
    create: XOR<serviceCreateWithoutCase_studiesInput, serviceUncheckedCreateWithoutCase_studiesInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutCase_studiesInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutCase_studiesInput, serviceUncheckedUpdateWithoutCase_studiesInput>
  }

  export type serviceUpdateWithoutCase_studiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceNestedInput
    service_request?: service_requestUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUpdateManyWithoutServiceNestedInput
    plan?: planUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutCase_studiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUncheckedUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutServiceNestedInput
    plan?: planUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceCreateWithoutTestimonialInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutServiceInput
    service_request?: service_requestCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesCreateNestedManyWithoutServiceInput
    plan?: planCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutTestimonialInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestUncheckedCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutServiceInput
    plan?: planUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutTestimonialInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutTestimonialInput, serviceUncheckedCreateWithoutTestimonialInput>
  }

  export type userCreateWithoutTestimonialInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutTestimonialInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTestimonialInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
  }

  export type serviceUpsertWithoutTestimonialInput = {
    update: XOR<serviceUpdateWithoutTestimonialInput, serviceUncheckedUpdateWithoutTestimonialInput>
    create: XOR<serviceCreateWithoutTestimonialInput, serviceUncheckedCreateWithoutTestimonialInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutTestimonialInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutTestimonialInput, serviceUncheckedUpdateWithoutTestimonialInput>
  }

  export type serviceUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceNestedInput
    service_request?: service_requestUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUpdateManyWithoutServiceNestedInput
    plan?: planUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUncheckedUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUncheckedUpdateManyWithoutServiceNestedInput
    plan?: planUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type userUpsertWithoutTestimonialInput = {
    update: XOR<userUpdateWithoutTestimonialInput, userUncheckedUpdateWithoutTestimonialInput>
    create: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTestimonialInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTestimonialInput, userUncheckedUpdateWithoutTestimonialInput>
  }

  export type userUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTestimonialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type organisationCreateWithoutContactInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    case_studies?: case_studiesCreateNestedManyWithoutOrganisationInput
    user: userCreateNestedOneWithoutOrganisationInput
  }

  export type organisationUncheckedCreateWithoutContactInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    user_id: string
    deleted_at?: Date | string | null
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type organisationCreateOrConnectWithoutContactInput = {
    where: organisationWhereUniqueInput
    create: XOR<organisationCreateWithoutContactInput, organisationUncheckedCreateWithoutContactInput>
  }

  export type organisationUpsertWithoutContactInput = {
    update: XOR<organisationUpdateWithoutContactInput, organisationUncheckedUpdateWithoutContactInput>
    create: XOR<organisationCreateWithoutContactInput, organisationUncheckedCreateWithoutContactInput>
    where?: organisationWhereInput
  }

  export type organisationUpdateToOneWithWhereWithoutContactInput = {
    where?: organisationWhereInput
    data: XOR<organisationUpdateWithoutContactInput, organisationUncheckedUpdateWithoutContactInput>
  }

  export type organisationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUpdateManyWithoutOrganisationNestedInput
    user?: userUpdateOneRequiredWithoutOrganisationNestedInput
  }

  export type organisationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type userCreateWithoutOtpInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutOtpInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOtpInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
  }

  export type userUpsertWithoutOtpInput = {
    update: XOR<userUpdateWithoutOtpInput, userUncheckedUpdateWithoutOtpInput>
    create: XOR<userCreateWithoutOtpInput, userUncheckedCreateWithoutOtpInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOtpInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOtpInput, userUncheckedUpdateWithoutOtpInput>
  }

  export type userUpdateWithoutOtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutPassword_tokenInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPassword_tokenInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPassword_tokenInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPassword_tokenInput, userUncheckedCreateWithoutPassword_tokenInput>
  }

  export type userUpsertWithoutPassword_tokenInput = {
    update: XOR<userUpdateWithoutPassword_tokenInput, userUncheckedUpdateWithoutPassword_tokenInput>
    create: XOR<userCreateWithoutPassword_tokenInput, userUncheckedCreateWithoutPassword_tokenInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPassword_tokenInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPassword_tokenInput, userUncheckedUpdateWithoutPassword_tokenInput>
  }

  export type userUpdateWithoutPassword_tokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPassword_tokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutNotificationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
  }

  export type userUpsertWithoutNotificationInput = {
    update: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutPrivacy_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPrivacy_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPrivacy_settingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPrivacy_settingsInput, userUncheckedCreateWithoutPrivacy_settingsInput>
  }

  export type userUpsertWithoutPrivacy_settingsInput = {
    update: XOR<userUpdateWithoutPrivacy_settingsInput, userUncheckedUpdateWithoutPrivacy_settingsInput>
    create: XOR<userCreateWithoutPrivacy_settingsInput, userUncheckedCreateWithoutPrivacy_settingsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPrivacy_settingsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPrivacy_settingsInput, userUncheckedUpdateWithoutPrivacy_settingsInput>
  }

  export type userUpdateWithoutPrivacy_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPrivacy_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutNotification_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotification_settingsInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotification_settingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotification_settingsInput, userUncheckedCreateWithoutNotification_settingsInput>
  }

  export type userUpsertWithoutNotification_settingsInput = {
    update: XOR<userUpdateWithoutNotification_settingsInput, userUncheckedUpdateWithoutNotification_settingsInput>
    create: XOR<userCreateWithoutNotification_settingsInput, userUncheckedCreateWithoutNotification_settingsInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotification_settingsInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotification_settingsInput, userUncheckedUpdateWithoutNotification_settingsInput>
  }

  export type userUpdateWithoutNotification_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotification_settingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutPlan_typeInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPlan_typeInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPlan_typeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPlan_typeInput, userUncheckedCreateWithoutPlan_typeInput>
  }

  export type planCreateWithoutPlan_typeInput = {
    id?: string
    price: number
    description: string
    service: serviceCreateNestedOneWithoutPlanInput
    billing_cycle: billing_cycleCreateNestedOneWithoutPlanInput
    service_request?: service_requestCreateNestedManyWithoutPlanInput
    subscription?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutPlan_typeInput = {
    id?: string
    service_id: string
    billing_cycle_id: string
    price: number
    description: string
    service_request?: service_requestUncheckedCreateNestedManyWithoutPlanInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutPlan_typeInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput>
  }

  export type planCreateManyPlan_typeInputEnvelope = {
    data: planCreateManyPlan_typeInput | planCreateManyPlan_typeInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutPlan_typeInput = {
    update: XOR<userUpdateWithoutPlan_typeInput, userUncheckedUpdateWithoutPlan_typeInput>
    create: XOR<userCreateWithoutPlan_typeInput, userUncheckedCreateWithoutPlan_typeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPlan_typeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPlan_typeInput, userUncheckedUpdateWithoutPlan_typeInput>
  }

  export type userUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type planUpsertWithWhereUniqueWithoutPlan_typeInput = {
    where: planWhereUniqueInput
    update: XOR<planUpdateWithoutPlan_typeInput, planUncheckedUpdateWithoutPlan_typeInput>
    create: XOR<planCreateWithoutPlan_typeInput, planUncheckedCreateWithoutPlan_typeInput>
  }

  export type planUpdateWithWhereUniqueWithoutPlan_typeInput = {
    where: planWhereUniqueInput
    data: XOR<planUpdateWithoutPlan_typeInput, planUncheckedUpdateWithoutPlan_typeInput>
  }

  export type planUpdateManyWithWhereWithoutPlan_typeInput = {
    where: planScalarWhereInput
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyWithoutPlan_typeInput>
  }

  export type planCreateWithoutBilling_cycleInput = {
    id?: string
    price: number
    description: string
    service: serviceCreateNestedOneWithoutPlanInput
    plan_type: plan_typeCreateNestedOneWithoutPlanInput
    service_request?: service_requestCreateNestedManyWithoutPlanInput
    subscription?: subscriptionCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutBilling_cycleInput = {
    id?: string
    service_id: string
    plan_type_id: string
    price: number
    description: string
    service_request?: service_requestUncheckedCreateNestedManyWithoutPlanInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutBilling_cycleInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput>
  }

  export type planCreateManyBilling_cycleInputEnvelope = {
    data: planCreateManyBilling_cycleInput | planCreateManyBilling_cycleInput[]
    skipDuplicates?: boolean
  }

  export type planUpsertWithWhereUniqueWithoutBilling_cycleInput = {
    where: planWhereUniqueInput
    update: XOR<planUpdateWithoutBilling_cycleInput, planUncheckedUpdateWithoutBilling_cycleInput>
    create: XOR<planCreateWithoutBilling_cycleInput, planUncheckedCreateWithoutBilling_cycleInput>
  }

  export type planUpdateWithWhereUniqueWithoutBilling_cycleInput = {
    where: planWhereUniqueInput
    data: XOR<planUpdateWithoutBilling_cycleInput, planUncheckedUpdateWithoutBilling_cycleInput>
  }

  export type planUpdateManyWithWhereWithoutBilling_cycleInput = {
    where: planScalarWhereInput
    data: XOR<planUpdateManyMutationInput, planUncheckedUpdateManyWithoutBilling_cycleInput>
  }

  export type serviceCreateWithoutPlanInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutServiceInput
    service_request?: service_requestCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesCreateNestedManyWithoutServiceInput
    testimonial?: testimonialCreateNestedManyWithoutServiceInput
  }

  export type serviceUncheckedCreateWithoutPlanInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    admin_id: string
    banner_url: string
    deleted_at?: Date | string | null
    service_request?: service_requestUncheckedCreateNestedManyWithoutServiceInput
    case_studies?: case_studiesUncheckedCreateNestedManyWithoutServiceInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutServiceInput
  }

  export type serviceCreateOrConnectWithoutPlanInput = {
    where: serviceWhereUniqueInput
    create: XOR<serviceCreateWithoutPlanInput, serviceUncheckedCreateWithoutPlanInput>
  }

  export type plan_typeCreateWithoutPlanInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutPlan_typeInput
  }

  export type plan_typeUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    created_at?: Date | string
    created_by: string
    deleted_at?: Date | string | null
  }

  export type plan_typeCreateOrConnectWithoutPlanInput = {
    where: plan_typeWhereUniqueInput
    create: XOR<plan_typeCreateWithoutPlanInput, plan_typeUncheckedCreateWithoutPlanInput>
  }

  export type billing_cycleCreateWithoutPlanInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type billing_cycleUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    duration_in_days: number
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type billing_cycleCreateOrConnectWithoutPlanInput = {
    where: billing_cycleWhereUniqueInput
    create: XOR<billing_cycleCreateWithoutPlanInput, billing_cycleUncheckedCreateWithoutPlanInput>
  }

  export type service_requestCreateWithoutPlanInput = {
    id?: string
    message: string
    requested_at?: Date | string
    status: string
    service: serviceCreateNestedOneWithoutService_requestInput
    user: userCreateNestedOneWithoutService_requestInput
  }

  export type service_requestUncheckedCreateWithoutPlanInput = {
    id?: string
    message: string
    service_id: string
    user_id: string
    requested_at?: Date | string
    status: string
  }

  export type service_requestCreateOrConnectWithoutPlanInput = {
    where: service_requestWhereUniqueInput
    create: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput>
  }

  export type service_requestCreateManyPlanInputEnvelope = {
    data: service_requestCreateManyPlanInput | service_requestCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionCreateWithoutPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user: userCreateNestedOneWithoutSubscriptionInput
  }

  export type subscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
  }

  export type subscriptionCreateOrConnectWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    create: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput>
  }

  export type subscriptionCreateManyPlanInputEnvelope = {
    data: subscriptionCreateManyPlanInput | subscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type serviceUpsertWithoutPlanInput = {
    update: XOR<serviceUpdateWithoutPlanInput, serviceUncheckedUpdateWithoutPlanInput>
    create: XOR<serviceCreateWithoutPlanInput, serviceUncheckedCreateWithoutPlanInput>
    where?: serviceWhereInput
  }

  export type serviceUpdateToOneWithWhereWithoutPlanInput = {
    where?: serviceWhereInput
    data: XOR<serviceUpdateWithoutPlanInput, serviceUncheckedUpdateWithoutPlanInput>
  }

  export type serviceUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutServiceNestedInput
    service_request?: service_requestUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_id?: StringFieldUpdateOperationsInput | string
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUncheckedUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUncheckedUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type plan_typeUpsertWithoutPlanInput = {
    update: XOR<plan_typeUpdateWithoutPlanInput, plan_typeUncheckedUpdateWithoutPlanInput>
    create: XOR<plan_typeCreateWithoutPlanInput, plan_typeUncheckedCreateWithoutPlanInput>
    where?: plan_typeWhereInput
  }

  export type plan_typeUpdateToOneWithWhereWithoutPlanInput = {
    where?: plan_typeWhereInput
    data: XOR<plan_typeUpdateWithoutPlanInput, plan_typeUncheckedUpdateWithoutPlanInput>
  }

  export type plan_typeUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutPlan_typeNestedInput
  }

  export type plan_typeUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type billing_cycleUpsertWithoutPlanInput = {
    update: XOR<billing_cycleUpdateWithoutPlanInput, billing_cycleUncheckedUpdateWithoutPlanInput>
    create: XOR<billing_cycleCreateWithoutPlanInput, billing_cycleUncheckedCreateWithoutPlanInput>
    where?: billing_cycleWhereInput
  }

  export type billing_cycleUpdateToOneWithWhereWithoutPlanInput = {
    where?: billing_cycleWhereInput
    data: XOR<billing_cycleUpdateWithoutPlanInput, billing_cycleUncheckedUpdateWithoutPlanInput>
  }

  export type billing_cycleUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type billing_cycleUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration_in_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type service_requestUpsertWithWhereUniqueWithoutPlanInput = {
    where: service_requestWhereUniqueInput
    update: XOR<service_requestUpdateWithoutPlanInput, service_requestUncheckedUpdateWithoutPlanInput>
    create: XOR<service_requestCreateWithoutPlanInput, service_requestUncheckedCreateWithoutPlanInput>
  }

  export type service_requestUpdateWithWhereUniqueWithoutPlanInput = {
    where: service_requestWhereUniqueInput
    data: XOR<service_requestUpdateWithoutPlanInput, service_requestUncheckedUpdateWithoutPlanInput>
  }

  export type service_requestUpdateManyWithWhereWithoutPlanInput = {
    where: service_requestScalarWhereInput
    data: XOR<service_requestUpdateManyMutationInput, service_requestUncheckedUpdateManyWithoutPlanInput>
  }

  export type subscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    update: XOR<subscriptionUpdateWithoutPlanInput, subscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<subscriptionCreateWithoutPlanInput, subscriptionUncheckedCreateWithoutPlanInput>
  }

  export type subscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: subscriptionWhereUniqueInput
    data: XOR<subscriptionUpdateWithoutPlanInput, subscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type subscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: subscriptionScalarWhereInput
    data: XOR<subscriptionUpdateManyMutationInput, subscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type planCreateWithoutSubscriptionInput = {
    id?: string
    price: number
    description: string
    service: serviceCreateNestedOneWithoutPlanInput
    plan_type: plan_typeCreateNestedOneWithoutPlanInput
    billing_cycle: billing_cycleCreateNestedOneWithoutPlanInput
    service_request?: service_requestCreateNestedManyWithoutPlanInput
  }

  export type planUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    service_id: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
    service_request?: service_requestUncheckedCreateNestedManyWithoutPlanInput
  }

  export type planCreateOrConnectWithoutSubscriptionInput = {
    where: planWhereUniqueInput
    create: XOR<planCreateWithoutSubscriptionInput, planUncheckedCreateWithoutSubscriptionInput>
  }

  export type userCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSubscriptionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
  }

  export type planUpsertWithoutSubscriptionInput = {
    update: XOR<planUpdateWithoutSubscriptionInput, planUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<planCreateWithoutSubscriptionInput, planUncheckedCreateWithoutSubscriptionInput>
    where?: planWhereInput
  }

  export type planUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: planWhereInput
    data: XOR<planUpdateWithoutSubscriptionInput, planUncheckedUpdateWithoutSubscriptionInput>
  }

  export type planUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutPlanNestedInput
    plan_type?: plan_typeUpdateOneRequiredWithoutPlanNestedInput
    billing_cycle?: billing_cycleUpdateOneRequiredWithoutPlanNestedInput
    service_request?: service_requestUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service_request?: service_requestUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type userUpsertWithoutSubscriptionInput = {
    update: XOR<userUpdateWithoutSubscriptionInput, userUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<userCreateWithoutSubscriptionInput, userUncheckedCreateWithoutSubscriptionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSubscriptionInput, userUncheckedUpdateWithoutSubscriptionInput>
  }

  export type userUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCreated_roleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
    role: roleCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutCreated_roleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    role_id: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCreated_roleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCreated_roleInput, userUncheckedCreateWithoutCreated_roleInput>
  }

  export type userCreateWithoutRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsCreateNestedManyWithoutUserInput
    organisation?: organisationCreateNestedManyWithoutUserInput
    otp?: otpCreateNestedManyWithoutUserInput
    password_token?: password_tokenCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsCreateNestedManyWithoutUserInput
    created_role?: roleCreateNestedManyWithoutCreatorInput
    service?: serviceCreateNestedManyWithoutUserInput
    service_request?: service_requestCreateNestedManyWithoutUserInput
    subscription?: subscriptionCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
    plan_type?: plan_typeCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    notification_settings?: notification_settingsUncheckedCreateNestedManyWithoutUserInput
    organisation?: organisationUncheckedCreateNestedManyWithoutUserInput
    otp?: otpUncheckedCreateNestedManyWithoutUserInput
    password_token?: password_tokenUncheckedCreateNestedManyWithoutUserInput
    privacy_settings?: privacy_settingsUncheckedCreateNestedManyWithoutUserInput
    created_role?: roleUncheckedCreateNestedManyWithoutCreatorInput
    service?: serviceUncheckedCreateNestedManyWithoutUserInput
    service_request?: service_requestUncheckedCreateNestedManyWithoutUserInput
    subscription?: subscriptionUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
    plan_type?: plan_typeUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRoleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userCreateManyRoleInputEnvelope = {
    data: userCreateManyRoleInput | userCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutCreated_roleInput = {
    update: XOR<userUpdateWithoutCreated_roleInput, userUncheckedUpdateWithoutCreated_roleInput>
    create: XOR<userCreateWithoutCreated_roleInput, userUncheckedCreateWithoutCreated_roleInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCreated_roleInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCreated_roleInput, userUncheckedUpdateWithoutCreated_roleInput>
  }

  export type userUpdateWithoutCreated_roleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
    role?: roleUpdateOneRequiredWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCreated_roleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
    create: XOR<userCreateWithoutRoleInput, userUncheckedCreateWithoutRoleInput>
  }

  export type userUpdateWithWhereUniqueWithoutRoleInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutRoleInput, userUncheckedUpdateWithoutRoleInput>
  }

  export type userUpdateManyWithWhereWithoutRoleInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutRoleInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    tel?: StringFilter<"user"> | string
    country?: StringFilter<"user"> | string
    address?: StringFilter<"user"> | string
    category?: StringFilter<"user"> | string
    pfp_url?: StringNullableFilter<"user"> | string | null
    id_url?: JsonNullableFilter<"user">
    business_status?: BoolNullableFilter<"user"> | boolean | null
    registered_with_a_business?: BoolNullableFilter<"user"> | boolean | null
    password?: StringFilter<"user"> | string
    status?: StringFilter<"user"> | string
    role_id?: StringFilter<"user"> | string
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
  }

  export type notificationCreateManyUserInput = {
    id?: string
    activity: string
    completed_at?: Date | string | null
  }

  export type notification_settingsCreateManyUserInput = {
    id?: string
    alerts?: boolean
    messages?: boolean
    updates?: boolean
    billing_alerts?: boolean
    email?: boolean
    in_app?: boolean
  }

  export type organisationCreateManyUserInput = {
    id?: string
    name: string
    email: string
    address: string
    country: string
    industry: string
    logo_url: string
    rc_number: string
    staff_size: string
    type: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type otpCreateManyUserInput = {
    id?: string
    otp: string
    expires_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type password_tokenCreateManyUserInput = {
    id?: string
    token: string
    created_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type privacy_settingsCreateManyUserInput = {
    id?: string
    ads?: boolean
    data_sharing?: boolean
    marketing_status?: boolean
    activity_status?: boolean
  }

  export type roleCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type serviceCreateManyUserInput = {
    id?: string
    title: string
    description: string
    subtitle: string
    created_at?: Date | string | null
    banner_url: string
    deleted_at?: Date | string | null
  }

  export type service_requestCreateManyUserInput = {
    id?: string
    message: string
    service_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type subscriptionCreateManyUserInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    plan_id: string
  }

  export type testimonialCreateManyUserInput = {
    id?: string
    message: string
    service_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type plan_typeCreateManyUserInput = {
    id?: string
    name: string
    created_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activity?: StringFieldUpdateOperationsInput | string
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notification_settingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_settingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_settingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alerts?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    updates?: BoolFieldUpdateOperationsInput | boolean
    billing_alerts?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    in_app?: BoolFieldUpdateOperationsInput | boolean
  }

  export type organisationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUpdateManyWithoutOrganisationNestedInput
    contact?: contactUpdateManyWithoutOrganisationNestedInput
  }

  export type organisationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case_studies?: case_studiesUncheckedUpdateManyWithoutOrganisationNestedInput
    contact?: contactUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type organisationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    logo_url?: StringFieldUpdateOperationsInput | string
    rc_number?: StringFieldUpdateOperationsInput | string
    staff_size?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type otpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_tokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_tokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_tokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type privacy_settingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type privacy_settingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type privacy_settingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ads?: BoolFieldUpdateOperationsInput | boolean
    data_sharing?: BoolFieldUpdateOperationsInput | boolean
    marketing_status?: BoolFieldUpdateOperationsInput | boolean
    activity_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type roleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUpdateManyWithoutServiceNestedInput
    plan?: planUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_request?: service_requestUncheckedUpdateManyWithoutServiceNestedInput
    case_studies?: case_studiesUncheckedUpdateManyWithoutServiceNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutServiceNestedInput
    plan?: planUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type serviceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner_url?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type service_requestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: planUpdateOneRequiredWithoutService_requestNestedInput
    service?: serviceUpdateOneRequiredWithoutService_requestNestedInput
  }

  export type service_requestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan?: planUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type subscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type testimonialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: serviceUpdateOneRequiredWithoutTestimonialNestedInput
  }

  export type testimonialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testimonialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plan_typeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUpdateManyWithoutPlan_typeNestedInput
  }

  export type plan_typeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plan?: planUncheckedUpdateManyWithoutPlan_typeNestedInput
  }

  export type plan_typeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type case_studiesCreateManyOrganisationInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    service_id: string
  }

  export type contactCreateManyOrganisationInput = {
    id?: string
    name: string
    pfp_url: string
    id_url: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type case_studiesUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutCase_studiesNestedInput
  }

  export type case_studiesUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesUncheckedUpdateManyWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type contactUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUncheckedUpdateManyWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pfp_url?: StringFieldUpdateOperationsInput | string
    id_url?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type service_requestCreateManyServiceInput = {
    id?: string
    message: string
    user_id: string
    requested_at?: Date | string
    status: string
    plan_id: string
  }

  export type case_studiesCreateManyServiceInput = {
    id?: string
    banner: string
    challenge: string
    challenge_img: string
    solution: string
    solution_img: string
    result: string
    result_img: string
    organisation_id: string
  }

  export type testimonialCreateManyServiceInput = {
    id?: string
    message: string
    user_id: string
    stars: Decimal | DecimalJsLike | number | string
    user_title: string
    deleted_at?: Date | string | null
  }

  export type planCreateManyServiceInput = {
    id?: string
    plan_type_id: string
    billing_cycle_id: string
    price: number
    description: string
  }

  export type service_requestUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan?: planUpdateOneRequiredWithoutService_requestNestedInput
    user?: userUpdateOneRequiredWithoutService_requestNestedInput
  }

  export type service_requestUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    organisation?: organisationUpdateOneRequiredWithoutCase_studiesNestedInput
  }

  export type case_studiesUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
  }

  export type case_studiesUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    challenge?: StringFieldUpdateOperationsInput | string
    challenge_img?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    solution_img?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    result_img?: StringFieldUpdateOperationsInput | string
    organisation_id?: StringFieldUpdateOperationsInput | string
  }

  export type testimonialUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutTestimonialNestedInput
  }

  export type testimonialUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testimonialUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    stars?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_title?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type planUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    plan_type?: plan_typeUpdateOneRequiredWithoutPlanNestedInput
    billing_cycle?: billing_cycleUpdateOneRequiredWithoutPlanNestedInput
    service_request?: service_requestUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service_request?: service_requestUncheckedUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type planCreateManyPlan_typeInput = {
    id?: string
    service_id: string
    billing_cycle_id: string
    price: number
    description: string
  }

  export type planUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutPlanNestedInput
    billing_cycle?: billing_cycleUpdateOneRequiredWithoutPlanNestedInput
    service_request?: service_requestUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service_request?: service_requestUncheckedUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateManyWithoutPlan_typeInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    billing_cycle_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type planCreateManyBilling_cycleInput = {
    id?: string
    service_id: string
    plan_type_id: string
    price: number
    description: string
  }

  export type planUpdateWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutPlanNestedInput
    plan_type?: plan_typeUpdateOneRequiredWithoutPlanNestedInput
    service_request?: service_requestUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    service_request?: service_requestUncheckedUpdateManyWithoutPlanNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type planUncheckedUpdateManyWithoutBilling_cycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    plan_type_id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestCreateManyPlanInput = {
    id?: string
    message: string
    service_id: string
    user_id: string
    requested_at?: Date | string
    status: string
  }

  export type subscriptionCreateManyPlanInput = {
    id?: string
    start_date?: Date | string | null
    end_date?: Date | string | null
    status: string
    user_id: string
  }

  export type service_requestUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    service?: serviceUpdateOneRequiredWithoutService_requestNestedInput
    user?: userUpdateOneRequiredWithoutService_requestNestedInput
  }

  export type service_requestUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type service_requestUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type subscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateManyRoleInput = {
    id?: string
    name: string
    email: string
    tel: string
    country: string
    address: string
    category: string
    pfp_url?: string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: boolean | null
    registered_with_a_business?: boolean | null
    password: string
    status?: string
    created_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type userUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUpdateManyWithoutUserNestedInput
    organisation?: organisationUpdateManyWithoutUserNestedInput
    otp?: otpUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUpdateManyWithoutUserNestedInput
    created_role?: roleUpdateManyWithoutCreatorNestedInput
    service?: serviceUpdateManyWithoutUserNestedInput
    service_request?: service_requestUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    notification_settings?: notification_settingsUncheckedUpdateManyWithoutUserNestedInput
    organisation?: organisationUncheckedUpdateManyWithoutUserNestedInput
    otp?: otpUncheckedUpdateManyWithoutUserNestedInput
    password_token?: password_tokenUncheckedUpdateManyWithoutUserNestedInput
    privacy_settings?: privacy_settingsUncheckedUpdateManyWithoutUserNestedInput
    created_role?: roleUncheckedUpdateManyWithoutCreatorNestedInput
    service?: serviceUncheckedUpdateManyWithoutUserNestedInput
    service_request?: service_requestUncheckedUpdateManyWithoutUserNestedInput
    subscription?: subscriptionUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
    plan_type?: plan_typeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    pfp_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_url?: NullableJsonNullValueInput | InputJsonValue
    business_status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered_with_a_business?: NullableBoolFieldUpdateOperationsInput | boolean | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}